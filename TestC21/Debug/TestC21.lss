
TestC21.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00007684  00000000  00000000  00010000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     000001e4  20000000  00007684  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000031b0  200001e4  00007868  000201e4  2**2
                  ALLOC
  3 .stack        00002004  20003394  0000aa18  000201e4  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  000201e4  2**0
                  CONTENTS, READONLY
  5 .comment      00000059  00000000  00000000  0002020c  2**0
                  CONTENTS, READONLY
  6 .debug_info   000362d2  00000000  00000000  00020265  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000045f0  00000000  00000000  00056537  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    00004a8f  00000000  00000000  0005ab27  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00000d68  00000000  00000000  0005f5b6  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000bd8  00000000  00000000  0006031e  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  00024c60  00000000  00000000  00060ef6  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0001496c  00000000  00000000  00085b56  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    000addcd  00000000  00000000  0009a4c2  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00003138  00000000  00000000  00148290  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
       0:	98 53 00 20 55 69 00 00 d9 69 00 00 d9 69 00 00     .S. Ui...i...i..
	...
      2c:	d9 69 00 00 00 00 00 00 00 00 00 00 d1 30 00 00     .i...........0..
      3c:	19 31 00 00 d9 69 00 00 d9 69 00 00 d9 69 00 00     .1...i...i...i..
      4c:	d9 69 00 00 d9 69 00 00 d9 69 00 00 d9 69 00 00     .i...i...i...i..
      5c:	d9 69 00 00 d9 69 00 00 d9 1e 00 00 f1 1e 00 00     .i...i..........
      6c:	09 1f 00 00 21 1f 00 00 39 1f 00 00 51 1f 00 00     ....!...9...Q...
      7c:	1d 5a 00 00 d9 69 00 00 d9 69 00 00 d9 69 00 00     .Z...i...i...i..
      8c:	d9 69 00 00 d9 69 00 00 d9 69 00 00 d9 69 00 00     .i...i...i...i..
      9c:	d9 69 00 00 d9 69 00 00 d9 69 00 00 d9 69 00 00     .i...i...i...i..
      ac:	d9 69 00 00 d9 69 00 00 d9 69 00 00 d9 69 00 00     .i...i...i...i..

000000bc <__do_global_dtors_aux>:
      bc:	b510      	push	{r4, lr}
      be:	4c06      	ldr	r4, [pc, #24]	; (d8 <__do_global_dtors_aux+0x1c>)
      c0:	7823      	ldrb	r3, [r4, #0]
      c2:	2b00      	cmp	r3, #0
      c4:	d107      	bne.n	d6 <__do_global_dtors_aux+0x1a>
      c6:	4b05      	ldr	r3, [pc, #20]	; (dc <__do_global_dtors_aux+0x20>)
      c8:	2b00      	cmp	r3, #0
      ca:	d002      	beq.n	d2 <__do_global_dtors_aux+0x16>
      cc:	4804      	ldr	r0, [pc, #16]	; (e0 <__do_global_dtors_aux+0x24>)
      ce:	e000      	b.n	d2 <__do_global_dtors_aux+0x16>
      d0:	bf00      	nop
      d2:	2301      	movs	r3, #1
      d4:	7023      	strb	r3, [r4, #0]
      d6:	bd10      	pop	{r4, pc}
      d8:	200001e4 	.word	0x200001e4
      dc:	00000000 	.word	0x00000000
      e0:	00007684 	.word	0x00007684

000000e4 <frame_dummy>:
      e4:	4b08      	ldr	r3, [pc, #32]	; (108 <frame_dummy+0x24>)
      e6:	b510      	push	{r4, lr}
      e8:	2b00      	cmp	r3, #0
      ea:	d003      	beq.n	f4 <frame_dummy+0x10>
      ec:	4907      	ldr	r1, [pc, #28]	; (10c <frame_dummy+0x28>)
      ee:	4808      	ldr	r0, [pc, #32]	; (110 <frame_dummy+0x2c>)
      f0:	e000      	b.n	f4 <frame_dummy+0x10>
      f2:	bf00      	nop
      f4:	4807      	ldr	r0, [pc, #28]	; (114 <frame_dummy+0x30>)
      f6:	6803      	ldr	r3, [r0, #0]
      f8:	2b00      	cmp	r3, #0
      fa:	d100      	bne.n	fe <frame_dummy+0x1a>
      fc:	bd10      	pop	{r4, pc}
      fe:	4b06      	ldr	r3, [pc, #24]	; (118 <frame_dummy+0x34>)
     100:	2b00      	cmp	r3, #0
     102:	d0fb      	beq.n	fc <frame_dummy+0x18>
     104:	4798      	blx	r3
     106:	e7f9      	b.n	fc <frame_dummy+0x18>
     108:	00000000 	.word	0x00000000
     10c:	200001e8 	.word	0x200001e8
     110:	00007684 	.word	0x00007684
     114:	00007684 	.word	0x00007684
     118:	00000000 	.word	0x00000000

0000011c <system_gclk_chan_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void system_gclk_chan_get_config_defaults(
		struct system_gclk_chan_config *const config)
{
     11c:	b580      	push	{r7, lr}
     11e:	b082      	sub	sp, #8
     120:	af00      	add	r7, sp, #0
     122:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->source_generator = GCLK_GENERATOR_0;
     124:	687b      	ldr	r3, [r7, #4]
     126:	2200      	movs	r2, #0
     128:	701a      	strb	r2, [r3, #0]
}
     12a:	46c0      	nop			; (mov r8, r8)
     12c:	46bd      	mov	sp, r7
     12e:	b002      	add	sp, #8
     130:	bd80      	pop	{r7, pc}
	...

00000134 <system_ahb_clock_set_mask>:
 *
 * \param[in] ahb_mask  AHB clock mask to enable
 */
static inline void system_ahb_clock_set_mask(
		const uint32_t ahb_mask)
{
     134:	b580      	push	{r7, lr}
     136:	b082      	sub	sp, #8
     138:	af00      	add	r7, sp, #0
     13a:	6078      	str	r0, [r7, #4]
	MCLK->AHBMASK.reg |= ahb_mask;
     13c:	4b04      	ldr	r3, [pc, #16]	; (150 <system_ahb_clock_set_mask+0x1c>)
     13e:	4a04      	ldr	r2, [pc, #16]	; (150 <system_ahb_clock_set_mask+0x1c>)
     140:	6911      	ldr	r1, [r2, #16]
     142:	687a      	ldr	r2, [r7, #4]
     144:	430a      	orrs	r2, r1
     146:	611a      	str	r2, [r3, #16]
}
     148:	46c0      	nop			; (mov r8, r8)
     14a:	46bd      	mov	sp, r7
     14c:	b002      	add	sp, #8
     14e:	bd80      	pop	{r7, pc}
     150:	40000800 	.word	0x40000800

00000154 <_can_message_memory_init>:
static struct can_standard_message_filter_element can1_rx_standard_filter[CONF_CAN1_RX_STANDARD_ID_FILTER_NUM];
COMPILER_ALIGNED(4)
static struct can_extended_message_filter_element can1_rx_extended_filter[CONF_CAN1_RX_EXTENDED_ID_FILTER_NUM];

static void _can_message_memory_init(Can *hw)
{
     154:	b580      	push	{r7, lr}
     156:	b084      	sub	sp, #16
     158:	af00      	add	r7, sp, #0
     15a:	6078      	str	r0, [r7, #4]
int i;
for (i = 0; i < CONF_CAN0_RX_FIFO_0_NUM; i++)
     15c:	2300      	movs	r3, #0
     15e:	60fb      	str	r3, [r7, #12]
     160:	e00b      	b.n	17a <_can_message_memory_init+0x26>
    memset(&can0_rx_fifo_0[i], 0, sizeof(struct can_rx_element_fifo_0));
     162:	68fb      	ldr	r3, [r7, #12]
     164:	011a      	lsls	r2, r3, #4
     166:	4b4c      	ldr	r3, [pc, #304]	; (298 <_can_message_memory_init+0x144>)
     168:	18d3      	adds	r3, r2, r3
     16a:	2210      	movs	r2, #16
     16c:	2100      	movs	r1, #0
     16e:	0018      	movs	r0, r3
     170:	4b4a      	ldr	r3, [pc, #296]	; (29c <_can_message_memory_init+0x148>)
     172:	4798      	blx	r3
for (i = 0; i < CONF_CAN0_RX_FIFO_0_NUM; i++)
     174:	68fb      	ldr	r3, [r7, #12]
     176:	3301      	adds	r3, #1
     178:	60fb      	str	r3, [r7, #12]
     17a:	68fb      	ldr	r3, [r7, #12]
     17c:	2b0f      	cmp	r3, #15
     17e:	ddf0      	ble.n	162 <_can_message_memory_init+0xe>

	if (hw == CAN0) {
     180:	687b      	ldr	r3, [r7, #4]
     182:	4a47      	ldr	r2, [pc, #284]	; (2a0 <_can_message_memory_init+0x14c>)
     184:	4293      	cmp	r3, r2
     186:	d13c      	bne.n	202 <_can_message_memory_init+0xae>
		hw->SIDFC.reg = CAN_SIDFC_FLSSA((uint32_t)can0_rx_standard_filter) |
     188:	4b46      	ldr	r3, [pc, #280]	; (2a4 <_can_message_memory_init+0x150>)
     18a:	041b      	lsls	r3, r3, #16
     18c:	0c1b      	lsrs	r3, r3, #16
     18e:	22a0      	movs	r2, #160	; 0xa0
     190:	02d2      	lsls	r2, r2, #11
     192:	431a      	orrs	r2, r3
     194:	687b      	ldr	r3, [r7, #4]
     196:	2184      	movs	r1, #132	; 0x84
     198:	505a      	str	r2, [r3, r1]
				CAN_SIDFC_LSS(CONF_CAN0_RX_STANDARD_ID_FILTER_NUM);
		hw->XIDFC.reg = CAN_XIDFC_FLESA((uint32_t)can0_rx_extended_filter) |
     19a:	4b43      	ldr	r3, [pc, #268]	; (2a8 <_can_message_memory_init+0x154>)
     19c:	041b      	lsls	r3, r3, #16
     19e:	0c1b      	lsrs	r3, r3, #16
     1a0:	22a0      	movs	r2, #160	; 0xa0
     1a2:	0312      	lsls	r2, r2, #12
     1a4:	431a      	orrs	r2, r3
     1a6:	687b      	ldr	r3, [r7, #4]
     1a8:	2188      	movs	r1, #136	; 0x88
     1aa:	505a      	str	r2, [r3, r1]
				CAN_XIDFC_LSE(CONF_CAN0_RX_EXTENDED_ID_FILTER_NUM);
		hw->RXF0C.reg = CAN_RXF0C_F0SA((uint32_t)can0_rx_fifo_0) |
     1ac:	4b3a      	ldr	r3, [pc, #232]	; (298 <_can_message_memory_init+0x144>)
     1ae:	041b      	lsls	r3, r3, #16
     1b0:	0c1b      	lsrs	r3, r3, #16
     1b2:	2280      	movs	r2, #128	; 0x80
     1b4:	0352      	lsls	r2, r2, #13
     1b6:	431a      	orrs	r2, r3
     1b8:	687b      	ldr	r3, [r7, #4]
     1ba:	21a0      	movs	r1, #160	; 0xa0
     1bc:	505a      	str	r2, [r3, r1]
				CAN_RXF0C_F0S(CONF_CAN0_RX_FIFO_0_NUM);
		hw->RXF1C.reg = CAN_RXF1C_F1SA((uint32_t)can0_rx_fifo_1) |
     1be:	4b3b      	ldr	r3, [pc, #236]	; (2ac <_can_message_memory_init+0x158>)
     1c0:	041b      	lsls	r3, r3, #16
     1c2:	0c1b      	lsrs	r3, r3, #16
     1c4:	2280      	movs	r2, #128	; 0x80
     1c6:	0352      	lsls	r2, r2, #13
     1c8:	431a      	orrs	r2, r3
     1ca:	687b      	ldr	r3, [r7, #4]
     1cc:	21b0      	movs	r1, #176	; 0xb0
     1ce:	505a      	str	r2, [r3, r1]
				CAN_RXF1C_F1S(CONF_CAN0_RX_FIFO_1_NUM);
		hw->RXBC.reg = CAN_RXBC_RBSA((uint32_t)can0_rx_buffer);
     1d0:	4b37      	ldr	r3, [pc, #220]	; (2b0 <_can_message_memory_init+0x15c>)
     1d2:	041b      	lsls	r3, r3, #16
     1d4:	0c1a      	lsrs	r2, r3, #16
     1d6:	687b      	ldr	r3, [r7, #4]
     1d8:	21ac      	movs	r1, #172	; 0xac
     1da:	505a      	str	r2, [r3, r1]
		hw->TXBC.reg = CAN_TXBC_TBSA((uint32_t)can0_tx_buffer) |
     1dc:	4b35      	ldr	r3, [pc, #212]	; (2b4 <_can_message_memory_init+0x160>)
     1de:	041b      	lsls	r3, r3, #16
     1e0:	0c1b      	lsrs	r3, r3, #16
				CAN_TXBC_NDTB(CONF_CAN0_TX_BUFFER_NUM) |
     1e2:	2280      	movs	r2, #128	; 0x80
     1e4:	04d2      	lsls	r2, r2, #19
     1e6:	431a      	orrs	r2, r3
		hw->TXBC.reg = CAN_TXBC_TBSA((uint32_t)can0_tx_buffer) |
     1e8:	687b      	ldr	r3, [r7, #4]
     1ea:	21c0      	movs	r1, #192	; 0xc0
     1ec:	505a      	str	r2, [r3, r1]
				CAN_TXBC_TFQS(CONF_CAN0_TX_FIFO_QUEUE_NUM);
		hw->TXEFC.reg = CAN_TXEFC_EFSA((uint32_t)can0_tx_event_fifo) |
     1ee:	4b32      	ldr	r3, [pc, #200]	; (2b8 <_can_message_memory_init+0x164>)
     1f0:	041b      	lsls	r3, r3, #16
     1f2:	0c1b      	lsrs	r3, r3, #16
     1f4:	2280      	movs	r2, #128	; 0x80
     1f6:	0312      	lsls	r2, r2, #12
     1f8:	431a      	orrs	r2, r3
     1fa:	687b      	ldr	r3, [r7, #4]
     1fc:	21f0      	movs	r1, #240	; 0xf0
     1fe:	505a      	str	r2, [r3, r1]
     200:	e03e      	b.n	280 <_can_message_memory_init+0x12c>
				CAN_TXEFC_EFS(CONF_CAN0_TX_EVENT_FIFO);
	} else if (hw == CAN1) {
     202:	687b      	ldr	r3, [r7, #4]
     204:	4a2d      	ldr	r2, [pc, #180]	; (2bc <_can_message_memory_init+0x168>)
     206:	4293      	cmp	r3, r2
     208:	d13a      	bne.n	280 <_can_message_memory_init+0x12c>
		hw->SIDFC.reg = CAN_SIDFC_FLSSA((uint32_t)can1_rx_standard_filter) |
     20a:	4b2d      	ldr	r3, [pc, #180]	; (2c0 <_can_message_memory_init+0x16c>)
     20c:	041b      	lsls	r3, r3, #16
     20e:	0c1b      	lsrs	r3, r3, #16
     210:	2280      	movs	r2, #128	; 0x80
     212:	0252      	lsls	r2, r2, #9
     214:	431a      	orrs	r2, r3
     216:	687b      	ldr	r3, [r7, #4]
     218:	2184      	movs	r1, #132	; 0x84
     21a:	505a      	str	r2, [r3, r1]
				CAN_SIDFC_LSS(CONF_CAN1_RX_STANDARD_ID_FILTER_NUM);
		hw->XIDFC.reg = CAN_XIDFC_FLESA((uint32_t)can1_rx_extended_filter) |
     21c:	4b29      	ldr	r3, [pc, #164]	; (2c4 <_can_message_memory_init+0x170>)
     21e:	041b      	lsls	r3, r3, #16
     220:	0c1b      	lsrs	r3, r3, #16
     222:	2280      	movs	r2, #128	; 0x80
     224:	0252      	lsls	r2, r2, #9
     226:	431a      	orrs	r2, r3
     228:	687b      	ldr	r3, [r7, #4]
     22a:	2188      	movs	r1, #136	; 0x88
     22c:	505a      	str	r2, [r3, r1]
				CAN_XIDFC_LSE(CONF_CAN1_RX_EXTENDED_ID_FILTER_NUM);
		hw->RXF0C.reg = CAN_RXF0C_F0SA((uint32_t)can1_rx_fifo_0) |
     22e:	4b26      	ldr	r3, [pc, #152]	; (2c8 <_can_message_memory_init+0x174>)
     230:	041b      	lsls	r3, r3, #16
     232:	0c1b      	lsrs	r3, r3, #16
     234:	2280      	movs	r2, #128	; 0x80
     236:	0352      	lsls	r2, r2, #13
     238:	431a      	orrs	r2, r3
     23a:	687b      	ldr	r3, [r7, #4]
     23c:	21a0      	movs	r1, #160	; 0xa0
     23e:	505a      	str	r2, [r3, r1]
				CAN_RXF0C_F0S(CONF_CAN1_RX_FIFO_0_NUM);
		hw->RXF1C.reg = CAN_RXF1C_F1SA((uint32_t)can1_rx_fifo_1) |
     240:	4b22      	ldr	r3, [pc, #136]	; (2cc <_can_message_memory_init+0x178>)
     242:	041b      	lsls	r3, r3, #16
     244:	0c1b      	lsrs	r3, r3, #16
     246:	2280      	movs	r2, #128	; 0x80
     248:	0352      	lsls	r2, r2, #13
     24a:	431a      	orrs	r2, r3
     24c:	687b      	ldr	r3, [r7, #4]
     24e:	21b0      	movs	r1, #176	; 0xb0
     250:	505a      	str	r2, [r3, r1]
				CAN_RXF1C_F1S(CONF_CAN1_RX_FIFO_1_NUM);
		hw->RXBC.reg = CAN_RXBC_RBSA((uint32_t)can1_rx_buffer);
     252:	4b1f      	ldr	r3, [pc, #124]	; (2d0 <_can_message_memory_init+0x17c>)
     254:	041b      	lsls	r3, r3, #16
     256:	0c1a      	lsrs	r2, r3, #16
     258:	687b      	ldr	r3, [r7, #4]
     25a:	21ac      	movs	r1, #172	; 0xac
     25c:	505a      	str	r2, [r3, r1]
		hw->TXBC.reg = CAN_TXBC_TBSA((uint32_t)can1_tx_buffer) |
     25e:	4b1d      	ldr	r3, [pc, #116]	; (2d4 <_can_message_memory_init+0x180>)
     260:	041b      	lsls	r3, r3, #16
     262:	0c1b      	lsrs	r3, r3, #16
				CAN_TXBC_NDTB(CONF_CAN1_TX_BUFFER_NUM) |
     264:	4a1c      	ldr	r2, [pc, #112]	; (2d8 <_can_message_memory_init+0x184>)
     266:	431a      	orrs	r2, r3
		hw->TXBC.reg = CAN_TXBC_TBSA((uint32_t)can1_tx_buffer) |
     268:	687b      	ldr	r3, [r7, #4]
     26a:	21c0      	movs	r1, #192	; 0xc0
     26c:	505a      	str	r2, [r3, r1]
				CAN_TXBC_TFQS(CONF_CAN1_TX_FIFO_QUEUE_NUM);
		hw->TXEFC.reg = CAN_TXEFC_EFSA((uint32_t)can1_tx_event_fifo) |
     26e:	4b1b      	ldr	r3, [pc, #108]	; (2dc <_can_message_memory_init+0x188>)
     270:	041b      	lsls	r3, r3, #16
     272:	0c1b      	lsrs	r3, r3, #16
     274:	2280      	movs	r2, #128	; 0x80
     276:	0312      	lsls	r2, r2, #12
     278:	431a      	orrs	r2, r3
     27a:	687b      	ldr	r3, [r7, #4]
     27c:	21f0      	movs	r1, #240	; 0xf0
     27e:	505a      	str	r2, [r3, r1]
	 * The corresponding setting value in register is 0/1//2/3/4/5/6/7.
	 * To simplify the calculation, seperate to two group 8/12/16/20/24 which
	 * increased with 4 and 32/48/64 which increased with 16.
	 */
	if (CONF_CAN_ELEMENT_DATA_SIZE <= 24) {
		hw->RXESC.reg = CAN_RXESC_RBDS((CONF_CAN_ELEMENT_DATA_SIZE - 8) / 4) |
     280:	687b      	ldr	r3, [r7, #4]
     282:	22bc      	movs	r2, #188	; 0xbc
     284:	2100      	movs	r1, #0
     286:	5099      	str	r1, [r3, r2]
				CAN_RXESC_F0DS((CONF_CAN_ELEMENT_DATA_SIZE - 8) / 4) |
				CAN_RXESC_F1DS((CONF_CAN_ELEMENT_DATA_SIZE - 8) / 4);
		hw->TXESC.reg = CAN_TXESC_TBDS((CONF_CAN_ELEMENT_DATA_SIZE - 8) / 4);
     288:	687b      	ldr	r3, [r7, #4]
     28a:	22c8      	movs	r2, #200	; 0xc8
     28c:	2100      	movs	r1, #0
     28e:	5099      	str	r1, [r3, r2]
		hw->RXESC.reg = CAN_RXESC_RBDS((CONF_CAN_ELEMENT_DATA_SIZE - 32) / 16 + 5) |
				CAN_RXESC_F0DS((CONF_CAN_ELEMENT_DATA_SIZE - 32) / 16 + 5) |
				CAN_RXESC_F1DS((CONF_CAN_ELEMENT_DATA_SIZE - 32) / 16 + 5);
		hw->TXESC.reg = CAN_TXESC_TBDS((CONF_CAN_ELEMENT_DATA_SIZE - 32) / 16 + 5);
	}
}
     290:	46c0      	nop			; (mov r8, r8)
     292:	46bd      	mov	sp, r7
     294:	b004      	add	sp, #16
     296:	bd80      	pop	{r7, pc}
     298:	20000200 	.word	0x20000200
     29c:	00006c37 	.word	0x00006c37
     2a0:	42001c00 	.word	0x42001c00
     2a4:	20000480 	.word	0x20000480
     2a8:	20000494 	.word	0x20000494
     2ac:	20000300 	.word	0x20000300
     2b0:	20000200 	.word	0x20000200
     2b4:	20000400 	.word	0x20000400
     2b8:	20000440 	.word	0x20000440
     2bc:	42002000 	.word	0x42002000
     2c0:	200008a4 	.word	0x200008a4
     2c4:	200008a8 	.word	0x200008a8
     2c8:	200005e4 	.word	0x200005e4
     2cc:	200006e4 	.word	0x200006e4
     2d0:	200004e4 	.word	0x200004e4
     2d4:	200007e4 	.word	0x200007e4
     2d8:	04040000 	.word	0x04040000
     2dc:	20000864 	.word	0x20000864

000002e0 <_can_set_configuration>:

static void _can_set_configuration(Can *hw, struct can_config *config)
{
     2e0:	b580      	push	{r7, lr}
     2e2:	b082      	sub	sp, #8
     2e4:	af00      	add	r7, sp, #0
     2e6:	6078      	str	r0, [r7, #4]
     2e8:	6039      	str	r1, [r7, #0]
	/* Timing setting. */
	hw->NBTP.reg = CAN_NBTP_NBRP(CONF_CAN_NBTP_NBRP_VALUE) |
     2ea:	687b      	ldr	r3, [r7, #4]
     2ec:	4a86      	ldr	r2, [pc, #536]	; (508 <_can_set_configuration+0x228>)
     2ee:	61da      	str	r2, [r3, #28]
			CAN_NBTP_NSJW(CONF_CAN_NBTP_NSJW_VALUE) |
			CAN_NBTP_NTSEG1(CONF_CAN_NBTP_NTSEG1_VALUE) |
			CAN_NBTP_NTSEG2(CONF_CAN_NBTP_NTSEG2_VALUE);
	hw->DBTP.reg = CAN_DBTP_DBRP(CONF_CAN_DBTP_DBRP_VALUE) |
     2f0:	687b      	ldr	r3, [r7, #4]
     2f2:	4a86      	ldr	r2, [pc, #536]	; (50c <_can_set_configuration+0x22c>)
     2f4:	60da      	str	r2, [r3, #12]
			CAN_DBTP_DSJW(CONF_CAN_DBTP_DSJW_VALUE) |
			CAN_DBTP_DTSEG1(CONF_CAN_DBTP_DTSEG1_VALUE) |
			CAN_DBTP_DTSEG2(CONF_CAN_DBTP_DTSEG2_VALUE);

	if (config->tdc_enable) {
     2f6:	683b      	ldr	r3, [r7, #0]
     2f8:	7b9b      	ldrb	r3, [r3, #14]
     2fa:	2b00      	cmp	r3, #0
     2fc:	d006      	beq.n	30c <_can_set_configuration+0x2c>
		hw->DBTP.reg |= CAN_DBTP_TDC;
     2fe:	687b      	ldr	r3, [r7, #4]
     300:	68db      	ldr	r3, [r3, #12]
     302:	2280      	movs	r2, #128	; 0x80
     304:	0412      	lsls	r2, r2, #16
     306:	431a      	orrs	r2, r3
     308:	687b      	ldr	r3, [r7, #4]
     30a:	60da      	str	r2, [r3, #12]
	}
	
	if (config->run_in_standby) {
     30c:	683b      	ldr	r3, [r7, #0]
     30e:	785b      	ldrb	r3, [r3, #1]
     310:	2b00      	cmp	r3, #0
     312:	d005      	beq.n	320 <_can_set_configuration+0x40>
		hw->MRCFG.reg |= 0x01<<6;
     314:	687b      	ldr	r3, [r7, #4]
     316:	689b      	ldr	r3, [r3, #8]
     318:	2240      	movs	r2, #64	; 0x40
     31a:	431a      	orrs	r2, r3
     31c:	687b      	ldr	r3, [r7, #4]
     31e:	609a      	str	r2, [r3, #8]
	}

	hw->RWD.reg |= CAN_RWD_WDC(config->watchdog_configuration);
     320:	687b      	ldr	r3, [r7, #4]
     322:	695b      	ldr	r3, [r3, #20]
     324:	683a      	ldr	r2, [r7, #0]
     326:	7892      	ldrb	r2, [r2, #2]
     328:	431a      	orrs	r2, r3
     32a:	687b      	ldr	r3, [r7, #4]
     32c:	615a      	str	r2, [r3, #20]

	if (config->transmit_pause) {
     32e:	683b      	ldr	r3, [r7, #0]
     330:	78db      	ldrb	r3, [r3, #3]
     332:	2b00      	cmp	r3, #0
     334:	d006      	beq.n	344 <_can_set_configuration+0x64>
		hw->CCCR.reg |= CAN_CCCR_TXP;
     336:	687b      	ldr	r3, [r7, #4]
     338:	699b      	ldr	r3, [r3, #24]
     33a:	2280      	movs	r2, #128	; 0x80
     33c:	01d2      	lsls	r2, r2, #7
     33e:	431a      	orrs	r2, r3
     340:	687b      	ldr	r3, [r7, #4]
     342:	619a      	str	r2, [r3, #24]
	}

	if (config->edge_filtering) {
     344:	683b      	ldr	r3, [r7, #0]
     346:	791b      	ldrb	r3, [r3, #4]
     348:	2b00      	cmp	r3, #0
     34a:	d006      	beq.n	35a <_can_set_configuration+0x7a>
		hw->CCCR.reg |= CAN_CCCR_EFBI;
     34c:	687b      	ldr	r3, [r7, #4]
     34e:	699b      	ldr	r3, [r3, #24]
     350:	2280      	movs	r2, #128	; 0x80
     352:	0192      	lsls	r2, r2, #6
     354:	431a      	orrs	r2, r3
     356:	687b      	ldr	r3, [r7, #4]
     358:	619a      	str	r2, [r3, #24]
	}

	if (config->protocol_exception_handling) {
     35a:	683b      	ldr	r3, [r7, #0]
     35c:	795b      	ldrb	r3, [r3, #5]
     35e:	2b00      	cmp	r3, #0
     360:	d006      	beq.n	370 <_can_set_configuration+0x90>
		hw->CCCR.reg |= CAN_CCCR_PXHD;
     362:	687b      	ldr	r3, [r7, #4]
     364:	699b      	ldr	r3, [r3, #24]
     366:	2280      	movs	r2, #128	; 0x80
     368:	0152      	lsls	r2, r2, #5
     36a:	431a      	orrs	r2, r3
     36c:	687b      	ldr	r3, [r7, #4]
     36e:	619a      	str	r2, [r3, #24]
	}

	if (!config->automatic_retransmission) {
     370:	683b      	ldr	r3, [r7, #0]
     372:	799b      	ldrb	r3, [r3, #6]
     374:	2201      	movs	r2, #1
     376:	4053      	eors	r3, r2
     378:	b2db      	uxtb	r3, r3
     37a:	2b00      	cmp	r3, #0
     37c:	d005      	beq.n	38a <_can_set_configuration+0xaa>
		hw->CCCR.reg |= CAN_CCCR_DAR;
     37e:	687b      	ldr	r3, [r7, #4]
     380:	699b      	ldr	r3, [r3, #24]
     382:	2240      	movs	r2, #64	; 0x40
     384:	431a      	orrs	r2, r3
     386:	687b      	ldr	r3, [r7, #4]
     388:	619a      	str	r2, [r3, #24]
	}

	if (config->clock_stop_request) {
     38a:	683b      	ldr	r3, [r7, #0]
     38c:	79db      	ldrb	r3, [r3, #7]
     38e:	2b00      	cmp	r3, #0
     390:	d005      	beq.n	39e <_can_set_configuration+0xbe>
		hw->CCCR.reg |= CAN_CCCR_CSR;
     392:	687b      	ldr	r3, [r7, #4]
     394:	699b      	ldr	r3, [r3, #24]
     396:	2210      	movs	r2, #16
     398:	431a      	orrs	r2, r3
     39a:	687b      	ldr	r3, [r7, #4]
     39c:	619a      	str	r2, [r3, #24]
	}

	if (config->clock_stop_acknowledge) {
     39e:	683b      	ldr	r3, [r7, #0]
     3a0:	7a1b      	ldrb	r3, [r3, #8]
     3a2:	2b00      	cmp	r3, #0
     3a4:	d005      	beq.n	3b2 <_can_set_configuration+0xd2>
		hw->CCCR.reg |= CAN_CCCR_CSA;
     3a6:	687b      	ldr	r3, [r7, #4]
     3a8:	699b      	ldr	r3, [r3, #24]
     3aa:	2208      	movs	r2, #8
     3ac:	431a      	orrs	r2, r3
     3ae:	687b      	ldr	r3, [r7, #4]
     3b0:	619a      	str	r2, [r3, #24]
	}

	hw->TSCC.reg = CAN_TSCC_TCP(config->timestamp_prescaler) |
     3b2:	683b      	ldr	r3, [r7, #0]
     3b4:	7a5b      	ldrb	r3, [r3, #9]
     3b6:	041b      	lsls	r3, r3, #16
     3b8:	001a      	movs	r2, r3
     3ba:	23f0      	movs	r3, #240	; 0xf0
     3bc:	031b      	lsls	r3, r3, #12
     3be:	4013      	ands	r3, r2
     3c0:	2201      	movs	r2, #1
     3c2:	431a      	orrs	r2, r3
     3c4:	687b      	ldr	r3, [r7, #4]
     3c6:	621a      	str	r2, [r3, #32]
			CAN_TSCC_TSS_INC_Val;

	hw->TOCC.reg = CAN_TOCC_TOP(config->timeout_period) |
     3c8:	683b      	ldr	r3, [r7, #0]
     3ca:	895b      	ldrh	r3, [r3, #10]
     3cc:	041b      	lsls	r3, r3, #16
     3ce:	001a      	movs	r2, r3
			config->timeout_mode | config->timeout_enable;
     3d0:	683b      	ldr	r3, [r7, #0]
     3d2:	7b1b      	ldrb	r3, [r3, #12]
	hw->TOCC.reg = CAN_TOCC_TOP(config->timeout_period) |
     3d4:	4313      	orrs	r3, r2
			config->timeout_mode | config->timeout_enable;
     3d6:	683a      	ldr	r2, [r7, #0]
     3d8:	7b52      	ldrb	r2, [r2, #13]
     3da:	431a      	orrs	r2, r3
	hw->TOCC.reg = CAN_TOCC_TOP(config->timeout_period) |
     3dc:	687b      	ldr	r3, [r7, #4]
     3de:	629a      	str	r2, [r3, #40]	; 0x28

	hw->TDCR.reg = CAN_TDCR_TDCO(config->delay_compensation_offset) |
     3e0:	683b      	ldr	r3, [r7, #0]
     3e2:	7bdb      	ldrb	r3, [r3, #15]
     3e4:	021b      	lsls	r3, r3, #8
     3e6:	001a      	movs	r2, r3
     3e8:	23fe      	movs	r3, #254	; 0xfe
     3ea:	01db      	lsls	r3, r3, #7
     3ec:	401a      	ands	r2, r3
			CAN_TDCR_TDCF(config->delay_compensation_filter_window_length);
     3ee:	683b      	ldr	r3, [r7, #0]
     3f0:	7c1b      	ldrb	r3, [r3, #16]
     3f2:	0019      	movs	r1, r3
     3f4:	237f      	movs	r3, #127	; 0x7f
     3f6:	400b      	ands	r3, r1
	hw->TDCR.reg = CAN_TDCR_TDCO(config->delay_compensation_offset) |
     3f8:	431a      	orrs	r2, r3
     3fa:	687b      	ldr	r3, [r7, #4]
     3fc:	649a      	str	r2, [r3, #72]	; 0x48

	hw->GFC.reg = CAN_GFC_ANFS(config->nonmatching_frames_action_standard) |
     3fe:	683b      	ldr	r3, [r7, #0]
     400:	7c5b      	ldrb	r3, [r3, #17]
     402:	011b      	lsls	r3, r3, #4
     404:	001a      	movs	r2, r3
     406:	2330      	movs	r3, #48	; 0x30
     408:	401a      	ands	r2, r3
			CAN_GFC_ANFE(config->nonmatching_frames_action_extended);
     40a:	683b      	ldr	r3, [r7, #0]
     40c:	7c9b      	ldrb	r3, [r3, #18]
     40e:	009b      	lsls	r3, r3, #2
     410:	0019      	movs	r1, r3
     412:	230c      	movs	r3, #12
     414:	400b      	ands	r3, r1
	hw->GFC.reg = CAN_GFC_ANFS(config->nonmatching_frames_action_standard) |
     416:	431a      	orrs	r2, r3
     418:	687b      	ldr	r3, [r7, #4]
     41a:	2180      	movs	r1, #128	; 0x80
     41c:	505a      	str	r2, [r3, r1]
	if (config->remote_frames_standard_reject) {
     41e:	683b      	ldr	r3, [r7, #0]
     420:	7cdb      	ldrb	r3, [r3, #19]
     422:	2b00      	cmp	r3, #0
     424:	d007      	beq.n	436 <_can_set_configuration+0x156>
		hw->GFC.reg |= CAN_GFC_RRFS;
     426:	687b      	ldr	r3, [r7, #4]
     428:	2280      	movs	r2, #128	; 0x80
     42a:	589b      	ldr	r3, [r3, r2]
     42c:	2202      	movs	r2, #2
     42e:	431a      	orrs	r2, r3
     430:	687b      	ldr	r3, [r7, #4]
     432:	2180      	movs	r1, #128	; 0x80
     434:	505a      	str	r2, [r3, r1]
	}
	if (config->remote_frames_extended_reject) {
     436:	683b      	ldr	r3, [r7, #0]
     438:	7d1b      	ldrb	r3, [r3, #20]
     43a:	2b00      	cmp	r3, #0
     43c:	d007      	beq.n	44e <_can_set_configuration+0x16e>
		hw->GFC.reg |= CAN_GFC_RRFE;
     43e:	687b      	ldr	r3, [r7, #4]
     440:	2280      	movs	r2, #128	; 0x80
     442:	589b      	ldr	r3, [r3, r2]
     444:	2201      	movs	r2, #1
     446:	431a      	orrs	r2, r3
     448:	687b      	ldr	r3, [r7, #4]
     44a:	2180      	movs	r1, #128	; 0x80
     44c:	505a      	str	r2, [r3, r1]
	}

	hw->XIDAM.reg = config->extended_id_mask;
     44e:	683b      	ldr	r3, [r7, #0]
     450:	699a      	ldr	r2, [r3, #24]
     452:	687b      	ldr	r3, [r7, #4]
     454:	2190      	movs	r1, #144	; 0x90
     456:	505a      	str	r2, [r3, r1]

	if (config->rx_fifo_0_overwrite) {
     458:	683b      	ldr	r3, [r7, #0]
     45a:	7f1b      	ldrb	r3, [r3, #28]
     45c:	2b00      	cmp	r3, #0
     45e:	d008      	beq.n	472 <_can_set_configuration+0x192>
		hw->RXF0C.reg |= CAN_RXF0C_F0OM;
     460:	687b      	ldr	r3, [r7, #4]
     462:	22a0      	movs	r2, #160	; 0xa0
     464:	589b      	ldr	r3, [r3, r2]
     466:	2280      	movs	r2, #128	; 0x80
     468:	0612      	lsls	r2, r2, #24
     46a:	431a      	orrs	r2, r3
     46c:	687b      	ldr	r3, [r7, #4]
     46e:	21a0      	movs	r1, #160	; 0xa0
     470:	505a      	str	r2, [r3, r1]
	}
	hw->RXF0C.reg |= CAN_RXF0C_F0WM(config->rx_fifo_0_watermark);
     472:	687b      	ldr	r3, [r7, #4]
     474:	22a0      	movs	r2, #160	; 0xa0
     476:	589a      	ldr	r2, [r3, r2]
     478:	683b      	ldr	r3, [r7, #0]
     47a:	7f5b      	ldrb	r3, [r3, #29]
     47c:	061b      	lsls	r3, r3, #24
     47e:	0019      	movs	r1, r3
     480:	23fe      	movs	r3, #254	; 0xfe
     482:	05db      	lsls	r3, r3, #23
     484:	400b      	ands	r3, r1
     486:	431a      	orrs	r2, r3
     488:	687b      	ldr	r3, [r7, #4]
     48a:	21a0      	movs	r1, #160	; 0xa0
     48c:	505a      	str	r2, [r3, r1]

	if (config->rx_fifo_1_overwrite) {
     48e:	683b      	ldr	r3, [r7, #0]
     490:	7f9b      	ldrb	r3, [r3, #30]
     492:	2b00      	cmp	r3, #0
     494:	d008      	beq.n	4a8 <_can_set_configuration+0x1c8>
		hw->RXF1C.reg |= CAN_RXF1C_F1OM;
     496:	687b      	ldr	r3, [r7, #4]
     498:	22b0      	movs	r2, #176	; 0xb0
     49a:	589b      	ldr	r3, [r3, r2]
     49c:	2280      	movs	r2, #128	; 0x80
     49e:	0612      	lsls	r2, r2, #24
     4a0:	431a      	orrs	r2, r3
     4a2:	687b      	ldr	r3, [r7, #4]
     4a4:	21b0      	movs	r1, #176	; 0xb0
     4a6:	505a      	str	r2, [r3, r1]
	}
	hw->RXF1C.reg |= CAN_RXF1C_F1WM(config->rx_fifo_1_watermark);
     4a8:	687b      	ldr	r3, [r7, #4]
     4aa:	22b0      	movs	r2, #176	; 0xb0
     4ac:	589a      	ldr	r2, [r3, r2]
     4ae:	683b      	ldr	r3, [r7, #0]
     4b0:	7fdb      	ldrb	r3, [r3, #31]
     4b2:	061b      	lsls	r3, r3, #24
     4b4:	0019      	movs	r1, r3
     4b6:	23fe      	movs	r3, #254	; 0xfe
     4b8:	05db      	lsls	r3, r3, #23
     4ba:	400b      	ands	r3, r1
     4bc:	431a      	orrs	r2, r3
     4be:	687b      	ldr	r3, [r7, #4]
     4c0:	21b0      	movs	r1, #176	; 0xb0
     4c2:	505a      	str	r2, [r3, r1]

	if (config->tx_queue_mode) {
     4c4:	683b      	ldr	r3, [r7, #0]
     4c6:	2220      	movs	r2, #32
     4c8:	5c9b      	ldrb	r3, [r3, r2]
     4ca:	2b00      	cmp	r3, #0
     4cc:	d008      	beq.n	4e0 <_can_set_configuration+0x200>
		hw->TXBC.reg |= CAN_TXBC_TFQM;
     4ce:	687b      	ldr	r3, [r7, #4]
     4d0:	22c0      	movs	r2, #192	; 0xc0
     4d2:	589b      	ldr	r3, [r3, r2]
     4d4:	2280      	movs	r2, #128	; 0x80
     4d6:	05d2      	lsls	r2, r2, #23
     4d8:	431a      	orrs	r2, r3
     4da:	687b      	ldr	r3, [r7, #4]
     4dc:	21c0      	movs	r1, #192	; 0xc0
     4de:	505a      	str	r2, [r3, r1]
	}

	hw->TXEFC.reg |= CAN_TXEFC_EFWM(config->tx_event_fifo_watermark);
     4e0:	687b      	ldr	r3, [r7, #4]
     4e2:	22f0      	movs	r2, #240	; 0xf0
     4e4:	589a      	ldr	r2, [r3, r2]
     4e6:	683b      	ldr	r3, [r7, #0]
     4e8:	2121      	movs	r1, #33	; 0x21
     4ea:	5c5b      	ldrb	r3, [r3, r1]
     4ec:	061b      	lsls	r3, r3, #24
     4ee:	0019      	movs	r1, r3
     4f0:	23fc      	movs	r3, #252	; 0xfc
     4f2:	059b      	lsls	r3, r3, #22
     4f4:	400b      	ands	r3, r1
     4f6:	431a      	orrs	r2, r3
     4f8:	687b      	ldr	r3, [r7, #4]
     4fa:	21f0      	movs	r1, #240	; 0xf0
     4fc:	505a      	str	r2, [r3, r1]
}
     4fe:	46c0      	nop			; (mov r8, r8)
     500:	46bd      	mov	sp, r7
     502:	b002      	add	sp, #8
     504:	bd80      	pop	{r7, pc}
     506:	46c0      	nop			; (mov r8, r8)
     508:	06050a03 	.word	0x06050a03
     50c:	00050a33 	.word	0x00050a33

00000510 <_can_enable_peripheral_clock>:

static void _can_enable_peripheral_clock(struct can_module *const module_inst)
{
     510:	b580      	push	{r7, lr}
     512:	b082      	sub	sp, #8
     514:	af00      	add	r7, sp, #0
     516:	6078      	str	r0, [r7, #4]
	if (module_inst->hw == CAN0) {
     518:	687b      	ldr	r3, [r7, #4]
     51a:	681b      	ldr	r3, [r3, #0]
     51c:	4a0b      	ldr	r2, [pc, #44]	; (54c <_can_enable_peripheral_clock+0x3c>)
     51e:	4293      	cmp	r3, r2
     520:	d105      	bne.n	52e <_can_enable_peripheral_clock+0x1e>
		/* Turn on the digital interface clock. */
		system_ahb_clock_set_mask(MCLK_AHBMASK_CAN0);
     522:	2380      	movs	r3, #128	; 0x80
     524:	005b      	lsls	r3, r3, #1
     526:	0018      	movs	r0, r3
     528:	4b09      	ldr	r3, [pc, #36]	; (550 <_can_enable_peripheral_clock+0x40>)
     52a:	4798      	blx	r3
	} else if (module_inst->hw == CAN1) {
		/* Turn on the digital interface clock. */
		system_ahb_clock_set_mask(MCLK_AHBMASK_CAN1);
	}
}
     52c:	e009      	b.n	542 <_can_enable_peripheral_clock+0x32>
	} else if (module_inst->hw == CAN1) {
     52e:	687b      	ldr	r3, [r7, #4]
     530:	681b      	ldr	r3, [r3, #0]
     532:	4a08      	ldr	r2, [pc, #32]	; (554 <_can_enable_peripheral_clock+0x44>)
     534:	4293      	cmp	r3, r2
     536:	d104      	bne.n	542 <_can_enable_peripheral_clock+0x32>
		system_ahb_clock_set_mask(MCLK_AHBMASK_CAN1);
     538:	2380      	movs	r3, #128	; 0x80
     53a:	009b      	lsls	r3, r3, #2
     53c:	0018      	movs	r0, r3
     53e:	4b04      	ldr	r3, [pc, #16]	; (550 <_can_enable_peripheral_clock+0x40>)
     540:	4798      	blx	r3
}
     542:	46c0      	nop			; (mov r8, r8)
     544:	46bd      	mov	sp, r7
     546:	b002      	add	sp, #8
     548:	bd80      	pop	{r7, pc}
     54a:	46c0      	nop			; (mov r8, r8)
     54c:	42001c00 	.word	0x42001c00
     550:	00000135 	.word	0x00000135
     554:	42002000 	.word	0x42002000

00000558 <can_init>:

void can_init(struct can_module *const module_inst, Can *hw,
		struct can_config *config)
{
     558:	b580      	push	{r7, lr}
     55a:	b084      	sub	sp, #16
     55c:	af00      	add	r7, sp, #0
     55e:	60f8      	str	r0, [r7, #12]
     560:	60b9      	str	r1, [r7, #8]
     562:	607a      	str	r2, [r7, #4]
	Assert(module_inst);
	Assert(hw);
	Assert(config);

	/* Associate the software module instance with the hardware module */
	module_inst->hw = hw;
     564:	68fb      	ldr	r3, [r7, #12]
     566:	68ba      	ldr	r2, [r7, #8]
     568:	601a      	str	r2, [r3, #0]

	/* Enable peripheral clock */
	_can_enable_peripheral_clock(module_inst);
     56a:	68fb      	ldr	r3, [r7, #12]
     56c:	0018      	movs	r0, r3
     56e:	4b22      	ldr	r3, [pc, #136]	; (5f8 <can_init+0xa0>)
     570:	4798      	blx	r3

	/* Configure GCLK channel */
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
     572:	4b22      	ldr	r3, [pc, #136]	; (5fc <can_init+0xa4>)
     574:	0018      	movs	r0, r3
     576:	4b22      	ldr	r3, [pc, #136]	; (600 <can_init+0xa8>)
     578:	4798      	blx	r3
	gclk_chan_conf.source_generator = config->clock_source;
     57a:	687b      	ldr	r3, [r7, #4]
     57c:	781a      	ldrb	r2, [r3, #0]
     57e:	4b1f      	ldr	r3, [pc, #124]	; (5fc <can_init+0xa4>)
     580:	701a      	strb	r2, [r3, #0]

	if (hw == CAN0) {
     582:	68bb      	ldr	r3, [r7, #8]
     584:	4a1f      	ldr	r2, [pc, #124]	; (604 <can_init+0xac>)
     586:	4293      	cmp	r3, r2
     588:	d108      	bne.n	59c <can_init+0x44>
		system_gclk_chan_set_config(CAN0_GCLK_ID, &gclk_chan_conf);
     58a:	4b1c      	ldr	r3, [pc, #112]	; (5fc <can_init+0xa4>)
     58c:	0019      	movs	r1, r3
     58e:	201a      	movs	r0, #26
     590:	4b1d      	ldr	r3, [pc, #116]	; (608 <can_init+0xb0>)
     592:	4798      	blx	r3
		system_gclk_chan_enable(CAN0_GCLK_ID);
     594:	201a      	movs	r0, #26
     596:	4b1d      	ldr	r3, [pc, #116]	; (60c <can_init+0xb4>)
     598:	4798      	blx	r3
     59a:	e00b      	b.n	5b4 <can_init+0x5c>
	} else if (hw == CAN1) {
     59c:	68bb      	ldr	r3, [r7, #8]
     59e:	4a1c      	ldr	r2, [pc, #112]	; (610 <can_init+0xb8>)
     5a0:	4293      	cmp	r3, r2
     5a2:	d107      	bne.n	5b4 <can_init+0x5c>
		system_gclk_chan_set_config(CAN1_GCLK_ID, &gclk_chan_conf);
     5a4:	4b15      	ldr	r3, [pc, #84]	; (5fc <can_init+0xa4>)
     5a6:	0019      	movs	r1, r3
     5a8:	201b      	movs	r0, #27
     5aa:	4b17      	ldr	r3, [pc, #92]	; (608 <can_init+0xb0>)
     5ac:	4798      	blx	r3
		system_gclk_chan_enable(CAN1_GCLK_ID);
     5ae:	201b      	movs	r0, #27
     5b0:	4b16      	ldr	r3, [pc, #88]	; (60c <can_init+0xb4>)
     5b2:	4798      	blx	r3
	}


	/* Configuration Change Enable. */
	hw->CCCR.reg |= CAN_CCCR_CCE;
     5b4:	68bb      	ldr	r3, [r7, #8]
     5b6:	699b      	ldr	r3, [r3, #24]
     5b8:	2202      	movs	r2, #2
     5ba:	431a      	orrs	r2, r3
     5bc:	68bb      	ldr	r3, [r7, #8]
     5be:	619a      	str	r2, [r3, #24]

	/* Initialize the message memory address. */
	_can_message_memory_init(hw);
     5c0:	68bb      	ldr	r3, [r7, #8]
     5c2:	0018      	movs	r0, r3
     5c4:	4b13      	ldr	r3, [pc, #76]	; (614 <can_init+0xbc>)
     5c6:	4798      	blx	r3

	/* Set the configuration. */
	_can_set_configuration(hw, config);
     5c8:	687a      	ldr	r2, [r7, #4]
     5ca:	68bb      	ldr	r3, [r7, #8]
     5cc:	0011      	movs	r1, r2
     5ce:	0018      	movs	r0, r3
     5d0:	4b11      	ldr	r3, [pc, #68]	; (618 <can_init+0xc0>)
     5d2:	4798      	blx	r3

	/* Enable the interrupt setting which no need change. */
	hw->ILE.reg = CAN_ILE_EINT0 | CAN_ILE_EINT1;
     5d4:	68bb      	ldr	r3, [r7, #8]
     5d6:	2203      	movs	r2, #3
     5d8:	65da      	str	r2, [r3, #92]	; 0x5c
	hw->TXBTIE.reg = CAN_TXBTIE_MASK;
     5da:	68bb      	ldr	r3, [r7, #8]
     5dc:	21e0      	movs	r1, #224	; 0xe0
     5de:	2201      	movs	r2, #1
     5e0:	4252      	negs	r2, r2
     5e2:	505a      	str	r2, [r3, r1]
	hw->TXBCIE.reg = CAN_TXBCIE_MASK;
     5e4:	68bb      	ldr	r3, [r7, #8]
     5e6:	21e4      	movs	r1, #228	; 0xe4
     5e8:	2201      	movs	r2, #1
     5ea:	4252      	negs	r2, r2
     5ec:	505a      	str	r2, [r3, r1]
}
     5ee:	46c0      	nop			; (mov r8, r8)
     5f0:	46bd      	mov	sp, r7
     5f2:	b004      	add	sp, #16
     5f4:	bd80      	pop	{r7, pc}
     5f6:	46c0      	nop			; (mov r8, r8)
     5f8:	00000511 	.word	0x00000511
     5fc:	20003304 	.word	0x20003304
     600:	0000011d 	.word	0x0000011d
     604:	42001c00 	.word	0x42001c00
     608:	00006659 	.word	0x00006659
     60c:	00006699 	.word	0x00006699
     610:	42002000 	.word	0x42002000
     614:	00000155 	.word	0x00000155
     618:	000002e1 	.word	0x000002e1

0000061c <can_set_baudrate>:

void can_set_baudrate(Can *hw, uint32_t baudrate)
{
     61c:	b580      	push	{r7, lr}
     61e:	b088      	sub	sp, #32
     620:	af00      	add	r7, sp, #0
     622:	6078      	str	r0, [r7, #4]
     624:	6039      	str	r1, [r7, #0]
	uint32_t gclk_can_value = 0;
     626:	2300      	movs	r3, #0
     628:	61fb      	str	r3, [r7, #28]
	uint32_t can_nbtp_nbrp_value;
	uint32_t can_nbtp_nsgw_value = 3, can_nbtp_ntseg1_value = 10, can_nbtp_ntseg2_value = 3;
     62a:	2303      	movs	r3, #3
     62c:	61bb      	str	r3, [r7, #24]
     62e:	230a      	movs	r3, #10
     630:	617b      	str	r3, [r7, #20]
     632:	2303      	movs	r3, #3
     634:	613b      	str	r3, [r7, #16]
	
	if (hw == CAN0) {
     636:	687b      	ldr	r3, [r7, #4]
     638:	4a1b      	ldr	r2, [pc, #108]	; (6a8 <can_set_baudrate+0x8c>)
     63a:	4293      	cmp	r3, r2
     63c:	d105      	bne.n	64a <can_set_baudrate+0x2e>
		gclk_can_value = system_gclk_chan_get_hz(CAN0_GCLK_ID);
     63e:	201a      	movs	r0, #26
     640:	4b1a      	ldr	r3, [pc, #104]	; (6ac <can_set_baudrate+0x90>)
     642:	4798      	blx	r3
     644:	0003      	movs	r3, r0
     646:	61fb      	str	r3, [r7, #28]
     648:	e008      	b.n	65c <can_set_baudrate+0x40>
		} else if (hw == CAN1) {
     64a:	687b      	ldr	r3, [r7, #4]
     64c:	4a18      	ldr	r2, [pc, #96]	; (6b0 <can_set_baudrate+0x94>)
     64e:	4293      	cmp	r3, r2
     650:	d104      	bne.n	65c <can_set_baudrate+0x40>
		gclk_can_value = system_gclk_chan_get_hz(CAN1_GCLK_ID);
     652:	201b      	movs	r0, #27
     654:	4b15      	ldr	r3, [pc, #84]	; (6ac <can_set_baudrate+0x90>)
     656:	4798      	blx	r3
     658:	0003      	movs	r3, r0
     65a:	61fb      	str	r3, [r7, #28]
	}
	
	can_nbtp_nbrp_value = gclk_can_value / baudrate / (3 + can_nbtp_ntseg1_value + can_nbtp_ntseg2_value);
     65c:	4b15      	ldr	r3, [pc, #84]	; (6b4 <can_set_baudrate+0x98>)
     65e:	6839      	ldr	r1, [r7, #0]
     660:	69f8      	ldr	r0, [r7, #28]
     662:	4798      	blx	r3
     664:	0003      	movs	r3, r0
     666:	0018      	movs	r0, r3
     668:	697a      	ldr	r2, [r7, #20]
     66a:	693b      	ldr	r3, [r7, #16]
     66c:	18d3      	adds	r3, r2, r3
     66e:	1cda      	adds	r2, r3, #3
     670:	4b10      	ldr	r3, [pc, #64]	; (6b4 <can_set_baudrate+0x98>)
     672:	0011      	movs	r1, r2
     674:	4798      	blx	r3
     676:	0003      	movs	r3, r0
     678:	60fb      	str	r3, [r7, #12]
	
	hw->NBTP.reg = CAN_NBTP_NBRP(can_nbtp_nbrp_value) |
     67a:	68fb      	ldr	r3, [r7, #12]
     67c:	041b      	lsls	r3, r3, #16
     67e:	4a0e      	ldr	r2, [pc, #56]	; (6b8 <can_set_baudrate+0x9c>)
     680:	401a      	ands	r2, r3
			CAN_NBTP_NSJW(can_nbtp_nsgw_value) |
     682:	69bb      	ldr	r3, [r7, #24]
     684:	065b      	lsls	r3, r3, #25
	hw->NBTP.reg = CAN_NBTP_NBRP(can_nbtp_nbrp_value) |
     686:	431a      	orrs	r2, r3
			CAN_NBTP_NTSEG1(can_nbtp_ntseg1_value) |
     688:	697b      	ldr	r3, [r7, #20]
     68a:	021b      	lsls	r3, r3, #8
     68c:	041b      	lsls	r3, r3, #16
     68e:	0c1b      	lsrs	r3, r3, #16
			CAN_NBTP_NSJW(can_nbtp_nsgw_value) |
     690:	431a      	orrs	r2, r3
			CAN_NBTP_NTSEG2(can_nbtp_ntseg2_value);
     692:	693b      	ldr	r3, [r7, #16]
     694:	217f      	movs	r1, #127	; 0x7f
     696:	400b      	ands	r3, r1
			CAN_NBTP_NTSEG1(can_nbtp_ntseg1_value) |
     698:	431a      	orrs	r2, r3
	hw->NBTP.reg = CAN_NBTP_NBRP(can_nbtp_nbrp_value) |
     69a:	687b      	ldr	r3, [r7, #4]
     69c:	61da      	str	r2, [r3, #28]
}
     69e:	46c0      	nop			; (mov r8, r8)
     6a0:	46bd      	mov	sp, r7
     6a2:	b008      	add	sp, #32
     6a4:	bd80      	pop	{r7, pc}
     6a6:	46c0      	nop			; (mov r8, r8)
     6a8:	42001c00 	.word	0x42001c00
     6ac:	00006749 	.word	0x00006749
     6b0:	42002000 	.word	0x42002000
     6b4:	00006a1d 	.word	0x00006a1d
     6b8:	01ff0000 	.word	0x01ff0000

000006bc <can_start>:
			CAN_DBTP_DTSEG1(can_fd_dbtp_dtseg1_value) |
			CAN_DBTP_DTSEG2(can_fd_dbtp_dtseg2_value);
}

void can_start(struct can_module *const module_inst)
{
     6bc:	b580      	push	{r7, lr}
     6be:	b082      	sub	sp, #8
     6c0:	af00      	add	r7, sp, #0
     6c2:	6078      	str	r0, [r7, #4]
	module_inst->hw->CCCR.reg &= ~CAN_CCCR_INIT;
     6c4:	687b      	ldr	r3, [r7, #4]
     6c6:	681b      	ldr	r3, [r3, #0]
     6c8:	687a      	ldr	r2, [r7, #4]
     6ca:	6812      	ldr	r2, [r2, #0]
     6cc:	6992      	ldr	r2, [r2, #24]
     6ce:	2101      	movs	r1, #1
     6d0:	438a      	bics	r2, r1
     6d2:	619a      	str	r2, [r3, #24]
	/* Wait for the sync. */
	while (module_inst->hw->CCCR.reg & CAN_CCCR_INIT);
     6d4:	46c0      	nop			; (mov r8, r8)
     6d6:	687b      	ldr	r3, [r7, #4]
     6d8:	681b      	ldr	r3, [r3, #0]
     6da:	699b      	ldr	r3, [r3, #24]
     6dc:	2201      	movs	r2, #1
     6de:	4013      	ands	r3, r2
     6e0:	d1f9      	bne.n	6d6 <can_start+0x1a>
}
     6e2:	46c0      	nop			; (mov r8, r8)
     6e4:	46bd      	mov	sp, r7
     6e6:	b002      	add	sp, #8
     6e8:	bd80      	pop	{r7, pc}

000006ea <can_stop>:

void can_stop(struct can_module *const module_inst)
{
     6ea:	b580      	push	{r7, lr}
     6ec:	b082      	sub	sp, #8
     6ee:	af00      	add	r7, sp, #0
     6f0:	6078      	str	r0, [r7, #4]
	module_inst->hw->CCCR.reg |= CAN_CCCR_INIT;
     6f2:	687b      	ldr	r3, [r7, #4]
     6f4:	681b      	ldr	r3, [r3, #0]
     6f6:	687a      	ldr	r2, [r7, #4]
     6f8:	6812      	ldr	r2, [r2, #0]
     6fa:	6992      	ldr	r2, [r2, #24]
     6fc:	2101      	movs	r1, #1
     6fe:	430a      	orrs	r2, r1
     700:	619a      	str	r2, [r3, #24]
	/* Wait for the sync. */
	while (!(module_inst->hw->CCCR.reg & CAN_CCCR_INIT));
     702:	46c0      	nop			; (mov r8, r8)
     704:	687b      	ldr	r3, [r7, #4]
     706:	681b      	ldr	r3, [r3, #0]
     708:	699b      	ldr	r3, [r3, #24]
     70a:	2201      	movs	r2, #1
     70c:	4013      	ands	r3, r2
     70e:	d0f9      	beq.n	704 <can_stop+0x1a>
}
     710:	46c0      	nop			; (mov r8, r8)
     712:	46bd      	mov	sp, r7
     714:	b002      	add	sp, #8
     716:	bd80      	pop	{r7, pc}

00000718 <can_set_rx_standard_filter>:
}

enum status_code can_set_rx_standard_filter(
		struct can_module *const module_inst,
		struct can_standard_message_filter_element *sd_filter, uint32_t index)
{
     718:	b580      	push	{r7, lr}
     71a:	b084      	sub	sp, #16
     71c:	af00      	add	r7, sp, #0
     71e:	60f8      	str	r0, [r7, #12]
     720:	60b9      	str	r1, [r7, #8]
     722:	607a      	str	r2, [r7, #4]
	if (module_inst->hw == CAN0) {
     724:	68fb      	ldr	r3, [r7, #12]
     726:	681b      	ldr	r3, [r3, #0]
     728:	4a0e      	ldr	r2, [pc, #56]	; (764 <can_set_rx_standard_filter+0x4c>)
     72a:	4293      	cmp	r3, r2
     72c:	d107      	bne.n	73e <can_set_rx_standard_filter+0x26>
		can0_rx_standard_filter[index].S0.reg = sd_filter->S0.reg;
     72e:	68bb      	ldr	r3, [r7, #8]
     730:	6819      	ldr	r1, [r3, #0]
     732:	4b0d      	ldr	r3, [pc, #52]	; (768 <can_set_rx_standard_filter+0x50>)
     734:	687a      	ldr	r2, [r7, #4]
     736:	0092      	lsls	r2, r2, #2
     738:	50d1      	str	r1, [r2, r3]
		return STATUS_OK;
     73a:	2300      	movs	r3, #0
     73c:	e00d      	b.n	75a <can_set_rx_standard_filter+0x42>
	} else if (module_inst->hw == CAN1) {
     73e:	68fb      	ldr	r3, [r7, #12]
     740:	681b      	ldr	r3, [r3, #0]
     742:	4a0a      	ldr	r2, [pc, #40]	; (76c <can_set_rx_standard_filter+0x54>)
     744:	4293      	cmp	r3, r2
     746:	d107      	bne.n	758 <can_set_rx_standard_filter+0x40>
		can1_rx_standard_filter[index].S0.reg = sd_filter->S0.reg;
     748:	68bb      	ldr	r3, [r7, #8]
     74a:	6819      	ldr	r1, [r3, #0]
     74c:	4b08      	ldr	r3, [pc, #32]	; (770 <can_set_rx_standard_filter+0x58>)
     74e:	687a      	ldr	r2, [r7, #4]
     750:	0092      	lsls	r2, r2, #2
     752:	50d1      	str	r1, [r2, r3]
		return STATUS_OK;
     754:	2300      	movs	r3, #0
     756:	e000      	b.n	75a <can_set_rx_standard_filter+0x42>
	}
	return STATUS_ERR_INVALID_ARG;
     758:	2317      	movs	r3, #23
}
     75a:	0018      	movs	r0, r3
     75c:	46bd      	mov	sp, r7
     75e:	b004      	add	sp, #16
     760:	bd80      	pop	{r7, pc}
     762:	46c0      	nop			; (mov r8, r8)
     764:	42001c00 	.word	0x42001c00
     768:	20000480 	.word	0x20000480
     76c:	42002000 	.word	0x42002000
     770:	200008a4 	.word	0x200008a4

00000774 <can_set_rx_extended_filter>:

enum status_code can_set_rx_extended_filter(
		struct can_module *const module_inst,
		struct can_extended_message_filter_element *et_filter, uint32_t index)
{
     774:	b580      	push	{r7, lr}
     776:	b084      	sub	sp, #16
     778:	af00      	add	r7, sp, #0
     77a:	60f8      	str	r0, [r7, #12]
     77c:	60b9      	str	r1, [r7, #8]
     77e:	607a      	str	r2, [r7, #4]
	if (module_inst->hw == CAN0) {
     780:	68fb      	ldr	r3, [r7, #12]
     782:	681b      	ldr	r3, [r3, #0]
     784:	4a16      	ldr	r2, [pc, #88]	; (7e0 <can_set_rx_extended_filter+0x6c>)
     786:	4293      	cmp	r3, r2
     788:	d10f      	bne.n	7aa <can_set_rx_extended_filter+0x36>
		can0_rx_extended_filter[index].F0.reg = et_filter->F0.reg;
     78a:	68bb      	ldr	r3, [r7, #8]
     78c:	6819      	ldr	r1, [r3, #0]
     78e:	4b15      	ldr	r3, [pc, #84]	; (7e4 <can_set_rx_extended_filter+0x70>)
     790:	687a      	ldr	r2, [r7, #4]
     792:	00d2      	lsls	r2, r2, #3
     794:	50d1      	str	r1, [r2, r3]
		can0_rx_extended_filter[index].F1.reg = et_filter->F1.reg;
     796:	68bb      	ldr	r3, [r7, #8]
     798:	685a      	ldr	r2, [r3, #4]
     79a:	4912      	ldr	r1, [pc, #72]	; (7e4 <can_set_rx_extended_filter+0x70>)
     79c:	687b      	ldr	r3, [r7, #4]
     79e:	00db      	lsls	r3, r3, #3
     7a0:	18cb      	adds	r3, r1, r3
     7a2:	3304      	adds	r3, #4
     7a4:	601a      	str	r2, [r3, #0]
		return STATUS_OK;
     7a6:	2300      	movs	r3, #0
     7a8:	e015      	b.n	7d6 <can_set_rx_extended_filter+0x62>
	} else if (module_inst->hw == CAN1) {
     7aa:	68fb      	ldr	r3, [r7, #12]
     7ac:	681b      	ldr	r3, [r3, #0]
     7ae:	4a0e      	ldr	r2, [pc, #56]	; (7e8 <can_set_rx_extended_filter+0x74>)
     7b0:	4293      	cmp	r3, r2
     7b2:	d10f      	bne.n	7d4 <can_set_rx_extended_filter+0x60>
		can1_rx_extended_filter[index].F0.reg = et_filter->F0.reg;
     7b4:	68bb      	ldr	r3, [r7, #8]
     7b6:	6819      	ldr	r1, [r3, #0]
     7b8:	4b0c      	ldr	r3, [pc, #48]	; (7ec <can_set_rx_extended_filter+0x78>)
     7ba:	687a      	ldr	r2, [r7, #4]
     7bc:	00d2      	lsls	r2, r2, #3
     7be:	50d1      	str	r1, [r2, r3]
		can1_rx_extended_filter[index].F1.reg = et_filter->F1.reg;
     7c0:	68bb      	ldr	r3, [r7, #8]
     7c2:	685a      	ldr	r2, [r3, #4]
     7c4:	4909      	ldr	r1, [pc, #36]	; (7ec <can_set_rx_extended_filter+0x78>)
     7c6:	687b      	ldr	r3, [r7, #4]
     7c8:	00db      	lsls	r3, r3, #3
     7ca:	18cb      	adds	r3, r1, r3
     7cc:	3304      	adds	r3, #4
     7ce:	601a      	str	r2, [r3, #0]
		return STATUS_OK;
     7d0:	2300      	movs	r3, #0
     7d2:	e000      	b.n	7d6 <can_set_rx_extended_filter+0x62>
	}
	return STATUS_ERR_INVALID_ARG;
     7d4:	2317      	movs	r3, #23
}
     7d6:	0018      	movs	r0, r3
     7d8:	46bd      	mov	sp, r7
     7da:	b004      	add	sp, #16
     7dc:	bd80      	pop	{r7, pc}
     7de:	46c0      	nop			; (mov r8, r8)
     7e0:	42001c00 	.word	0x42001c00
     7e4:	20000494 	.word	0x20000494
     7e8:	42002000 	.word	0x42002000
     7ec:	200008a8 	.word	0x200008a8

000007f0 <can_set_tx_buffer_element>:
}

enum status_code can_set_tx_buffer_element(
		struct can_module *const module_inst,
		struct can_tx_element *tx_element, uint32_t index)
{
     7f0:	b580      	push	{r7, lr}
     7f2:	b086      	sub	sp, #24
     7f4:	af00      	add	r7, sp, #0
     7f6:	60f8      	str	r0, [r7, #12]
     7f8:	60b9      	str	r1, [r7, #8]
     7fa:	607a      	str	r2, [r7, #4]
	uint32_t i;
	if (module_inst->hw == CAN0) {
     7fc:	68fb      	ldr	r3, [r7, #12]
     7fe:	681b      	ldr	r3, [r3, #0]
     800:	4a2d      	ldr	r2, [pc, #180]	; (8b8 <can_set_tx_buffer_element+0xc8>)
     802:	4293      	cmp	r3, r2
     804:	d126      	bne.n	854 <can_set_tx_buffer_element+0x64>
		can0_tx_buffer[index].T0.reg = tx_element->T0.reg;
     806:	68bb      	ldr	r3, [r7, #8]
     808:	6819      	ldr	r1, [r3, #0]
     80a:	4b2c      	ldr	r3, [pc, #176]	; (8bc <can_set_tx_buffer_element+0xcc>)
     80c:	687a      	ldr	r2, [r7, #4]
     80e:	0112      	lsls	r2, r2, #4
     810:	50d1      	str	r1, [r2, r3]
		can0_tx_buffer[index].T1.reg = tx_element->T1.reg;
     812:	68bb      	ldr	r3, [r7, #8]
     814:	685a      	ldr	r2, [r3, #4]
     816:	4929      	ldr	r1, [pc, #164]	; (8bc <can_set_tx_buffer_element+0xcc>)
     818:	687b      	ldr	r3, [r7, #4]
     81a:	011b      	lsls	r3, r3, #4
     81c:	18cb      	adds	r3, r1, r3
     81e:	3304      	adds	r3, #4
     820:	601a      	str	r2, [r3, #0]
		for (i = 0; i < CONF_CAN_ELEMENT_DATA_SIZE; i++) {
     822:	2300      	movs	r3, #0
     824:	617b      	str	r3, [r7, #20]
     826:	e010      	b.n	84a <can_set_tx_buffer_element+0x5a>
			can0_tx_buffer[index].data[i] = tx_element->data[i];
     828:	68ba      	ldr	r2, [r7, #8]
     82a:	697b      	ldr	r3, [r7, #20]
     82c:	18d3      	adds	r3, r2, r3
     82e:	3308      	adds	r3, #8
     830:	7819      	ldrb	r1, [r3, #0]
     832:	4a22      	ldr	r2, [pc, #136]	; (8bc <can_set_tx_buffer_element+0xcc>)
     834:	687b      	ldr	r3, [r7, #4]
     836:	011b      	lsls	r3, r3, #4
     838:	18d2      	adds	r2, r2, r3
     83a:	697b      	ldr	r3, [r7, #20]
     83c:	18d3      	adds	r3, r2, r3
     83e:	3308      	adds	r3, #8
     840:	1c0a      	adds	r2, r1, #0
     842:	701a      	strb	r2, [r3, #0]
		for (i = 0; i < CONF_CAN_ELEMENT_DATA_SIZE; i++) {
     844:	697b      	ldr	r3, [r7, #20]
     846:	3301      	adds	r3, #1
     848:	617b      	str	r3, [r7, #20]
     84a:	697b      	ldr	r3, [r7, #20]
     84c:	2b07      	cmp	r3, #7
     84e:	d9eb      	bls.n	828 <can_set_tx_buffer_element+0x38>
		}
		return STATUS_OK;
     850:	2300      	movs	r3, #0
     852:	e02c      	b.n	8ae <can_set_tx_buffer_element+0xbe>
	} else if (module_inst->hw == CAN1) {
     854:	68fb      	ldr	r3, [r7, #12]
     856:	681b      	ldr	r3, [r3, #0]
     858:	4a19      	ldr	r2, [pc, #100]	; (8c0 <can_set_tx_buffer_element+0xd0>)
     85a:	4293      	cmp	r3, r2
     85c:	d126      	bne.n	8ac <can_set_tx_buffer_element+0xbc>
		can1_tx_buffer[index].T0.reg = tx_element->T0.reg;
     85e:	68bb      	ldr	r3, [r7, #8]
     860:	6819      	ldr	r1, [r3, #0]
     862:	4b18      	ldr	r3, [pc, #96]	; (8c4 <can_set_tx_buffer_element+0xd4>)
     864:	687a      	ldr	r2, [r7, #4]
     866:	0112      	lsls	r2, r2, #4
     868:	50d1      	str	r1, [r2, r3]
		can1_tx_buffer[index].T1.reg = tx_element->T1.reg;
     86a:	68bb      	ldr	r3, [r7, #8]
     86c:	685a      	ldr	r2, [r3, #4]
     86e:	4915      	ldr	r1, [pc, #84]	; (8c4 <can_set_tx_buffer_element+0xd4>)
     870:	687b      	ldr	r3, [r7, #4]
     872:	011b      	lsls	r3, r3, #4
     874:	18cb      	adds	r3, r1, r3
     876:	3304      	adds	r3, #4
     878:	601a      	str	r2, [r3, #0]
		for (i = 0; i < CONF_CAN_ELEMENT_DATA_SIZE; i++) {
     87a:	2300      	movs	r3, #0
     87c:	617b      	str	r3, [r7, #20]
     87e:	e010      	b.n	8a2 <can_set_tx_buffer_element+0xb2>
			can1_tx_buffer[index].data[i] = tx_element->data[i];
     880:	68ba      	ldr	r2, [r7, #8]
     882:	697b      	ldr	r3, [r7, #20]
     884:	18d3      	adds	r3, r2, r3
     886:	3308      	adds	r3, #8
     888:	7819      	ldrb	r1, [r3, #0]
     88a:	4a0e      	ldr	r2, [pc, #56]	; (8c4 <can_set_tx_buffer_element+0xd4>)
     88c:	687b      	ldr	r3, [r7, #4]
     88e:	011b      	lsls	r3, r3, #4
     890:	18d2      	adds	r2, r2, r3
     892:	697b      	ldr	r3, [r7, #20]
     894:	18d3      	adds	r3, r2, r3
     896:	3308      	adds	r3, #8
     898:	1c0a      	adds	r2, r1, #0
     89a:	701a      	strb	r2, [r3, #0]
		for (i = 0; i < CONF_CAN_ELEMENT_DATA_SIZE; i++) {
     89c:	697b      	ldr	r3, [r7, #20]
     89e:	3301      	adds	r3, #1
     8a0:	617b      	str	r3, [r7, #20]
     8a2:	697b      	ldr	r3, [r7, #20]
     8a4:	2b07      	cmp	r3, #7
     8a6:	d9eb      	bls.n	880 <can_set_tx_buffer_element+0x90>
		}
		return STATUS_OK;
     8a8:	2300      	movs	r3, #0
     8aa:	e000      	b.n	8ae <can_set_tx_buffer_element+0xbe>
	}
	return STATUS_ERR_INVALID_ARG;
     8ac:	2317      	movs	r3, #23
}
     8ae:	0018      	movs	r0, r3
     8b0:	46bd      	mov	sp, r7
     8b2:	b006      	add	sp, #24
     8b4:	bd80      	pop	{r7, pc}
     8b6:	46c0      	nop			; (mov r8, r8)
     8b8:	42001c00 	.word	0x42001c00
     8bc:	20000400 	.word	0x20000400
     8c0:	42002000 	.word	0x42002000
     8c4:	200007e4 	.word	0x200007e4

000008c8 <can_rx_get_fifo_status>:
 *
 * \return Rx FIFO status value.
 */
static inline uint32_t can_rx_get_fifo_status(
		struct can_module *const module_inst, bool fifo_number)
{
     8c8:	b580      	push	{r7, lr}
     8ca:	b082      	sub	sp, #8
     8cc:	af00      	add	r7, sp, #0
     8ce:	6078      	str	r0, [r7, #4]
     8d0:	000a      	movs	r2, r1
     8d2:	1cfb      	adds	r3, r7, #3
     8d4:	701a      	strb	r2, [r3, #0]
	if (!fifo_number) {
     8d6:	1cfb      	adds	r3, r7, #3
     8d8:	781b      	ldrb	r3, [r3, #0]
     8da:	2201      	movs	r2, #1
     8dc:	4053      	eors	r3, r2
     8de:	b2db      	uxtb	r3, r3
     8e0:	2b00      	cmp	r3, #0
     8e2:	d004      	beq.n	8ee <can_rx_get_fifo_status+0x26>
		return module_inst->hw->RXF0S.reg;
     8e4:	687b      	ldr	r3, [r7, #4]
     8e6:	681b      	ldr	r3, [r3, #0]
     8e8:	22a4      	movs	r2, #164	; 0xa4
     8ea:	589b      	ldr	r3, [r3, r2]
     8ec:	e003      	b.n	8f6 <can_rx_get_fifo_status+0x2e>
	} else {
		return module_inst->hw->RXF1S.reg;
     8ee:	687b      	ldr	r3, [r7, #4]
     8f0:	681b      	ldr	r3, [r3, #0]
     8f2:	22b4      	movs	r2, #180	; 0xb4
     8f4:	589b      	ldr	r3, [r3, r2]
	}
}
     8f6:	0018      	movs	r0, r3
     8f8:	46bd      	mov	sp, r7
     8fa:	b002      	add	sp, #8
     8fc:	bd80      	pop	{r7, pc}

000008fe <can_rx_fifo_acknowledge>:
 * \param[in] fifo_number  Rx FIFO 0 or 1
 * \param[in] index  Index offset in FIFO
 */
static inline void can_rx_fifo_acknowledge(
		struct can_module *const module_inst, bool fifo_number, uint32_t index)
{
     8fe:	b580      	push	{r7, lr}
     900:	b084      	sub	sp, #16
     902:	af00      	add	r7, sp, #0
     904:	60f8      	str	r0, [r7, #12]
     906:	607a      	str	r2, [r7, #4]
     908:	230b      	movs	r3, #11
     90a:	18fb      	adds	r3, r7, r3
     90c:	1c0a      	adds	r2, r1, #0
     90e:	701a      	strb	r2, [r3, #0]
	if (!fifo_number) {
     910:	230b      	movs	r3, #11
     912:	18fb      	adds	r3, r7, r3
     914:	781b      	ldrb	r3, [r3, #0]
     916:	2201      	movs	r2, #1
     918:	4053      	eors	r3, r2
     91a:	b2db      	uxtb	r3, r3
     91c:	2b00      	cmp	r3, #0
     91e:	d007      	beq.n	930 <can_rx_fifo_acknowledge+0x32>
		module_inst->hw->RXF0A.reg = CAN_RXF0A_F0AI(index);
     920:	68fb      	ldr	r3, [r7, #12]
     922:	681b      	ldr	r3, [r3, #0]
     924:	687a      	ldr	r2, [r7, #4]
     926:	213f      	movs	r1, #63	; 0x3f
     928:	400a      	ands	r2, r1
     92a:	21a8      	movs	r1, #168	; 0xa8
     92c:	505a      	str	r2, [r3, r1]
	} else {
		module_inst->hw->RXF1A.reg = CAN_RXF1A_F1AI(index);
	}
}
     92e:	e006      	b.n	93e <can_rx_fifo_acknowledge+0x40>
		module_inst->hw->RXF1A.reg = CAN_RXF1A_F1AI(index);
     930:	68fb      	ldr	r3, [r7, #12]
     932:	681b      	ldr	r3, [r3, #0]
     934:	687a      	ldr	r2, [r7, #4]
     936:	213f      	movs	r1, #63	; 0x3f
     938:	400a      	ands	r2, r1
     93a:	21b8      	movs	r1, #184	; 0xb8
     93c:	505a      	str	r2, [r3, r1]
}
     93e:	46c0      	nop			; (mov r8, r8)
     940:	46bd      	mov	sp, r7
     942:	b004      	add	sp, #16
     944:	bd80      	pop	{r7, pc}
	...

00000948 <can_get_standard_message_filter_element_default>:
 *
 * \param[out] sd_filter  Pointer to standard filter element struct to initialize to default values
 */
static inline void can_get_standard_message_filter_element_default(
		struct can_standard_message_filter_element *sd_filter)
{
     948:	b580      	push	{r7, lr}
     94a:	b082      	sub	sp, #8
     94c:	af00      	add	r7, sp, #0
     94e:	6078      	str	r0, [r7, #4]
	sd_filter->S0.reg = CAN_STANDARD_MESSAGE_FILTER_ELEMENT_S0_SFID2_Msk |
     950:	687b      	ldr	r3, [r7, #4]
     952:	4a03      	ldr	r2, [pc, #12]	; (960 <can_get_standard_message_filter_element_default+0x18>)
     954:	601a      	str	r2, [r3, #0]
			CAN_STANDARD_MESSAGE_FILTER_ELEMENT_S0_SFID1(0) |
			CAN_STANDARD_MESSAGE_FILTER_ELEMENT_S0_SFEC(
			CAN_STANDARD_MESSAGE_FILTER_ELEMENT_S0_SFEC_STF0M_Val) |
			CAN_STANDARD_MESSAGE_FILTER_ELEMENT_S0_SFT_CLASSIC;
}
     956:	46c0      	nop			; (mov r8, r8)
     958:	46bd      	mov	sp, r7
     95a:	b002      	add	sp, #8
     95c:	bd80      	pop	{r7, pc}
     95e:	46c0      	nop			; (mov r8, r8)
     960:	880007ff 	.word	0x880007ff

00000964 <can_get_extended_message_filter_element_default>:
 *
 * \param[out] et_filter  Pointer to extended filter element struct to initialize to default values
 */
static inline void can_get_extended_message_filter_element_default(
		struct can_extended_message_filter_element *et_filter)
{
     964:	b580      	push	{r7, lr}
     966:	b082      	sub	sp, #8
     968:	af00      	add	r7, sp, #0
     96a:	6078      	str	r0, [r7, #4]
	et_filter->F0.reg = CAN_EXTENDED_MESSAGE_FILTER_ELEMENT_F0_EFID1(0) |
     96c:	687b      	ldr	r3, [r7, #4]
     96e:	2280      	movs	r2, #128	; 0x80
     970:	05d2      	lsls	r2, r2, #23
     972:	601a      	str	r2, [r3, #0]
			CAN_EXTENDED_MESSAGE_FILTER_ELEMENT_F0_EFEC(
			CAN_EXTENDED_MESSAGE_FILTER_ELEMENT_F0_EFEC_STF1M_Val);
	et_filter->F1.reg = CAN_EXTENDED_MESSAGE_FILTER_ELEMENT_F1_EFID2_Msk |
     974:	687b      	ldr	r3, [r7, #4]
     976:	4a03      	ldr	r2, [pc, #12]	; (984 <can_get_extended_message_filter_element_default+0x20>)
     978:	605a      	str	r2, [r3, #4]
			CAN_EXTENDED_MESSAGE_FILTER_ELEMENT_F1_EFT_CLASSIC;
}
     97a:	46c0      	nop			; (mov r8, r8)
     97c:	46bd      	mov	sp, r7
     97e:	b002      	add	sp, #8
     980:	bd80      	pop	{r7, pc}
     982:	46c0      	nop			; (mov r8, r8)
     984:	9fffffff 	.word	0x9fffffff

00000988 <can_filter_add>:

/*
 * Look for the first free slot in the filter table and insert filter 
 */
int can_filter_add(CAN_HW_FILTER *x)
{
     988:	b580      	push	{r7, lr}
     98a:	b088      	sub	sp, #32
     98c:	af00      	add	r7, sp, #0
     98e:	6078      	str	r0, [r7, #4]
    int i;
    if (x->ext) {
     990:	687b      	ldr	r3, [r7, #4]
     992:	7a1b      	ldrb	r3, [r3, #8]
     994:	2b00      	cmp	r3, #0
     996:	d042      	beq.n	a1e <can_filter_add+0x96>
        uint32_t *p = (uint32_t *) pHwFiltersX;
     998:	4b44      	ldr	r3, [pc, #272]	; (aac <can_filter_add+0x124>)
     99a:	681b      	ldr	r3, [r3, #0]
     99c:	61bb      	str	r3, [r7, #24]
        struct can_extended_message_filter_element filter;

        /* Scan filter table for empty slot */
        for (i = 0; i < CONF_CAN0_RX_EXTENDED_ID_FILTER_NUM; i++) {
     99e:	2300      	movs	r3, #0
     9a0:	61fb      	str	r3, [r7, #28]
     9a2:	e009      	b.n	9b8 <can_filter_add+0x30>
            if (*p == 0)
     9a4:	69bb      	ldr	r3, [r7, #24]
     9a6:	681b      	ldr	r3, [r3, #0]
     9a8:	2b00      	cmp	r3, #0
     9aa:	d009      	beq.n	9c0 <can_filter_add+0x38>
                break;
            p += 2;
     9ac:	69bb      	ldr	r3, [r7, #24]
     9ae:	3308      	adds	r3, #8
     9b0:	61bb      	str	r3, [r7, #24]
        for (i = 0; i < CONF_CAN0_RX_EXTENDED_ID_FILTER_NUM; i++) {
     9b2:	69fb      	ldr	r3, [r7, #28]
     9b4:	3301      	adds	r3, #1
     9b6:	61fb      	str	r3, [r7, #28]
     9b8:	69fb      	ldr	r3, [r7, #28]
     9ba:	2b09      	cmp	r3, #9
     9bc:	ddf2      	ble.n	9a4 <can_filter_add+0x1c>
     9be:	e000      	b.n	9c2 <can_filter_add+0x3a>
                break;
     9c0:	46c0      	nop			; (mov r8, r8)
        }

        if (i == CONF_CAN0_RX_STANDARD_ID_FILTER_NUM)
     9c2:	69fb      	ldr	r3, [r7, #28]
     9c4:	2b05      	cmp	r3, #5
     9c6:	d102      	bne.n	9ce <can_filter_add+0x46>
            return -1;
     9c8:	2301      	movs	r3, #1
     9ca:	425b      	negs	r3, r3
     9cc:	e06a      	b.n	aa4 <can_filter_add+0x11c>

        can_get_extended_message_filter_element_default(&filter);
     9ce:	230c      	movs	r3, #12
     9d0:	18fb      	adds	r3, r7, r3
     9d2:	0018      	movs	r0, r3
     9d4:	4b36      	ldr	r3, [pc, #216]	; (ab0 <can_filter_add+0x128>)
     9d6:	4798      	blx	r3
        filter.F0.bit.EFID1 = x->filter;
     9d8:	687b      	ldr	r3, [r7, #4]
     9da:	681b      	ldr	r3, [r3, #0]
     9dc:	00db      	lsls	r3, r3, #3
     9de:	08d9      	lsrs	r1, r3, #3
     9e0:	230c      	movs	r3, #12
     9e2:	18fb      	adds	r3, r7, r3
     9e4:	681a      	ldr	r2, [r3, #0]
     9e6:	00c9      	lsls	r1, r1, #3
     9e8:	08c9      	lsrs	r1, r1, #3
     9ea:	0f52      	lsrs	r2, r2, #29
     9ec:	0752      	lsls	r2, r2, #29
     9ee:	430a      	orrs	r2, r1
     9f0:	601a      	str	r2, [r3, #0]
        filter.F1.bit.EFID2 = x->mask;
     9f2:	687b      	ldr	r3, [r7, #4]
     9f4:	685b      	ldr	r3, [r3, #4]
     9f6:	00db      	lsls	r3, r3, #3
     9f8:	08d9      	lsrs	r1, r3, #3
     9fa:	230c      	movs	r3, #12
     9fc:	18fb      	adds	r3, r7, r3
     9fe:	685a      	ldr	r2, [r3, #4]
     a00:	00c9      	lsls	r1, r1, #3
     a02:	08c9      	lsrs	r1, r1, #3
     a04:	0f52      	lsrs	r2, r2, #29
     a06:	0752      	lsls	r2, r2, #29
     a08:	430a      	orrs	r2, r1
     a0a:	605a      	str	r2, [r3, #4]
        can_set_rx_extended_filter(pCAN, &filter, i); 
     a0c:	4b29      	ldr	r3, [pc, #164]	; (ab4 <can_filter_add+0x12c>)
     a0e:	681b      	ldr	r3, [r3, #0]
     a10:	69fa      	ldr	r2, [r7, #28]
     a12:	210c      	movs	r1, #12
     a14:	1879      	adds	r1, r7, r1
     a16:	0018      	movs	r0, r3
     a18:	4b27      	ldr	r3, [pc, #156]	; (ab8 <can_filter_add+0x130>)
     a1a:	4798      	blx	r3
     a1c:	e041      	b.n	aa2 <can_filter_add+0x11a>
    }
    else {
        uint32_t *p = (uint32_t *) pHwFilters;
     a1e:	4b27      	ldr	r3, [pc, #156]	; (abc <can_filter_add+0x134>)
     a20:	681b      	ldr	r3, [r3, #0]
     a22:	617b      	str	r3, [r7, #20]
        struct can_standard_message_filter_element filter;

        /* Scan filter table for empty slot */
        for (i = 0; i < CONF_CAN0_RX_STANDARD_ID_FILTER_NUM; i++) {
     a24:	2300      	movs	r3, #0
     a26:	61fb      	str	r3, [r7, #28]
     a28:	e008      	b.n	a3c <can_filter_add+0xb4>
            if (*p++ == 0)
     a2a:	697b      	ldr	r3, [r7, #20]
     a2c:	1d1a      	adds	r2, r3, #4
     a2e:	617a      	str	r2, [r7, #20]
     a30:	681b      	ldr	r3, [r3, #0]
     a32:	2b00      	cmp	r3, #0
     a34:	d006      	beq.n	a44 <can_filter_add+0xbc>
        for (i = 0; i < CONF_CAN0_RX_STANDARD_ID_FILTER_NUM; i++) {
     a36:	69fb      	ldr	r3, [r7, #28]
     a38:	3301      	adds	r3, #1
     a3a:	61fb      	str	r3, [r7, #28]
     a3c:	69fb      	ldr	r3, [r7, #28]
     a3e:	2b04      	cmp	r3, #4
     a40:	ddf3      	ble.n	a2a <can_filter_add+0xa2>
     a42:	e000      	b.n	a46 <can_filter_add+0xbe>
                break;
     a44:	46c0      	nop			; (mov r8, r8)
        }

        if (i == CONF_CAN0_RX_STANDARD_ID_FILTER_NUM)
     a46:	69fb      	ldr	r3, [r7, #28]
     a48:	2b05      	cmp	r3, #5
     a4a:	d102      	bne.n	a52 <can_filter_add+0xca>
            return -1;
     a4c:	2301      	movs	r3, #1
     a4e:	425b      	negs	r3, r3
     a50:	e028      	b.n	aa4 <can_filter_add+0x11c>
        
        can_get_standard_message_filter_element_default(&filter);
     a52:	2308      	movs	r3, #8
     a54:	18fb      	adds	r3, r7, r3
     a56:	0018      	movs	r0, r3
     a58:	4b19      	ldr	r3, [pc, #100]	; (ac0 <can_filter_add+0x138>)
     a5a:	4798      	blx	r3
        filter.S0.bit.SFID1 = x->filter;
     a5c:	687b      	ldr	r3, [r7, #4]
     a5e:	681b      	ldr	r3, [r3, #0]
     a60:	b29b      	uxth	r3, r3
     a62:	055b      	lsls	r3, r3, #21
     a64:	0d5b      	lsrs	r3, r3, #21
     a66:	b29a      	uxth	r2, r3
     a68:	68bb      	ldr	r3, [r7, #8]
     a6a:	0552      	lsls	r2, r2, #21
     a6c:	0d52      	lsrs	r2, r2, #21
     a6e:	0412      	lsls	r2, r2, #16
     a70:	4914      	ldr	r1, [pc, #80]	; (ac4 <can_filter_add+0x13c>)
     a72:	400b      	ands	r3, r1
     a74:	4313      	orrs	r3, r2
     a76:	60bb      	str	r3, [r7, #8]
        filter.S0.bit.SFID2 = x->mask;
     a78:	687b      	ldr	r3, [r7, #4]
     a7a:	685b      	ldr	r3, [r3, #4]
     a7c:	b29b      	uxth	r3, r3
     a7e:	055b      	lsls	r3, r3, #21
     a80:	0d5b      	lsrs	r3, r3, #21
     a82:	b29a      	uxth	r2, r3
     a84:	68bb      	ldr	r3, [r7, #8]
     a86:	0552      	lsls	r2, r2, #21
     a88:	0d52      	lsrs	r2, r2, #21
     a8a:	0adb      	lsrs	r3, r3, #11
     a8c:	02db      	lsls	r3, r3, #11
     a8e:	4313      	orrs	r3, r2
     a90:	60bb      	str	r3, [r7, #8]
        can_set_rx_standard_filter(pCAN, &filter, i); 
     a92:	4b08      	ldr	r3, [pc, #32]	; (ab4 <can_filter_add+0x12c>)
     a94:	681b      	ldr	r3, [r3, #0]
     a96:	69fa      	ldr	r2, [r7, #28]
     a98:	2108      	movs	r1, #8
     a9a:	1879      	adds	r1, r7, r1
     a9c:	0018      	movs	r0, r3
     a9e:	4b0a      	ldr	r3, [pc, #40]	; (ac8 <can_filter_add+0x140>)
     aa0:	4798      	blx	r3
    }
    return i;
     aa2:	69fb      	ldr	r3, [r7, #28]
}
     aa4:	0018      	movs	r0, r3
     aa6:	46bd      	mov	sp, r7
     aa8:	b008      	add	sp, #32
     aaa:	bd80      	pop	{r7, pc}
     aac:	20003308 	.word	0x20003308
     ab0:	00000965 	.word	0x00000965
     ab4:	2000000c 	.word	0x2000000c
     ab8:	00000775 	.word	0x00000775
     abc:	2000330c 	.word	0x2000330c
     ac0:	00000949 	.word	0x00000949
     ac4:	f800ffff 	.word	0xf800ffff
     ac8:	00000719 	.word	0x00000719

00000acc <can_filter_switch>:

/* Turn a filter on or off. 
 * Don't do anything if index out of range or filter unused.
 */
int can_filter_switch(uint8_t on, uint8_t index, uint8_t ext)
{
     acc:	b590      	push	{r4, r7, lr}
     ace:	b085      	sub	sp, #20
     ad0:	af00      	add	r7, sp, #0
     ad2:	0004      	movs	r4, r0
     ad4:	0008      	movs	r0, r1
     ad6:	0011      	movs	r1, r2
     ad8:	1dfb      	adds	r3, r7, #7
     ada:	1c22      	adds	r2, r4, #0
     adc:	701a      	strb	r2, [r3, #0]
     ade:	1dbb      	adds	r3, r7, #6
     ae0:	1c02      	adds	r2, r0, #0
     ae2:	701a      	strb	r2, [r3, #0]
     ae4:	1d7b      	adds	r3, r7, #5
     ae6:	1c0a      	adds	r2, r1, #0
     ae8:	701a      	strb	r2, [r3, #0]
    if (ext) {
     aea:	1d7b      	adds	r3, r7, #5
     aec:	781b      	ldrb	r3, [r3, #0]
     aee:	2b00      	cmp	r3, #0
     af0:	d03a      	beq.n	b68 <can_filter_switch+0x9c>
        struct can_extended_message_filter_element *filter = pHwFiltersX;
     af2:	4b3f      	ldr	r3, [pc, #252]	; (bf0 <can_filter_switch+0x124>)
     af4:	681b      	ldr	r3, [r3, #0]
     af6:	60fb      	str	r3, [r7, #12]

        if (index >= CONF_CAN0_RX_STANDARD_ID_FILTER_NUM) 
     af8:	1dbb      	adds	r3, r7, #6
     afa:	781b      	ldrb	r3, [r3, #0]
     afc:	2b04      	cmp	r3, #4
     afe:	d901      	bls.n	b04 <can_filter_switch+0x38>
            return 1;
     b00:	2301      	movs	r3, #1
     b02:	e070      	b.n	be6 <can_filter_switch+0x11a>

        if (filter[index].F0.reg == 0)    /* Don't touch a NULL filter */
     b04:	1dbb      	adds	r3, r7, #6
     b06:	781b      	ldrb	r3, [r3, #0]
     b08:	00db      	lsls	r3, r3, #3
     b0a:	68fa      	ldr	r2, [r7, #12]
     b0c:	18d3      	adds	r3, r2, r3
     b0e:	681b      	ldr	r3, [r3, #0]
     b10:	2b00      	cmp	r3, #0
     b12:	d101      	bne.n	b18 <can_filter_switch+0x4c>
            return (1);
     b14:	2301      	movs	r3, #1
     b16:	e066      	b.n	be6 <can_filter_switch+0x11a>

        if (on) {
     b18:	1dfb      	adds	r3, r7, #7
     b1a:	781b      	ldrb	r3, [r3, #0]
     b1c:	2b00      	cmp	r3, #0
     b1e:	d019      	beq.n	b54 <can_filter_switch+0x88>
            /* Handle special case, filter 0, is the 'reject' filter */
            if (index == 0)
     b20:	1dbb      	adds	r3, r7, #6
     b22:	781b      	ldrb	r3, [r3, #0]
     b24:	2b00      	cmp	r3, #0
     b26:	d108      	bne.n	b3a <can_filter_switch+0x6e>
                filter[0].F0.bit.EFEC = 0x3;  /* Reject */
     b28:	68fb      	ldr	r3, [r7, #12]
     b2a:	681a      	ldr	r2, [r3, #0]
     b2c:	00d2      	lsls	r2, r2, #3
     b2e:	08d2      	lsrs	r2, r2, #3
     b30:	21c0      	movs	r1, #192	; 0xc0
     b32:	05c9      	lsls	r1, r1, #23
     b34:	430a      	orrs	r2, r1
     b36:	601a      	str	r2, [r3, #0]
     b38:	e054      	b.n	be4 <can_filter_switch+0x118>
            else
                filter[index].F0.bit.EFEC = 0x1;  /* Store in FIFO 0 */
     b3a:	1dbb      	adds	r3, r7, #6
     b3c:	781b      	ldrb	r3, [r3, #0]
     b3e:	00db      	lsls	r3, r3, #3
     b40:	68fa      	ldr	r2, [r7, #12]
     b42:	18d3      	adds	r3, r2, r3
     b44:	681a      	ldr	r2, [r3, #0]
     b46:	00d2      	lsls	r2, r2, #3
     b48:	08d2      	lsrs	r2, r2, #3
     b4a:	2180      	movs	r1, #128	; 0x80
     b4c:	0589      	lsls	r1, r1, #22
     b4e:	430a      	orrs	r2, r1
     b50:	601a      	str	r2, [r3, #0]
     b52:	e047      	b.n	be4 <can_filter_switch+0x118>
        }
        else {
            filter[index].F0.bit.EFEC = 0x0;  /* Disable */
     b54:	1dbb      	adds	r3, r7, #6
     b56:	781b      	ldrb	r3, [r3, #0]
     b58:	00db      	lsls	r3, r3, #3
     b5a:	68fa      	ldr	r2, [r7, #12]
     b5c:	18d3      	adds	r3, r2, r3
     b5e:	681a      	ldr	r2, [r3, #0]
     b60:	00d2      	lsls	r2, r2, #3
     b62:	08d2      	lsrs	r2, r2, #3
     b64:	601a      	str	r2, [r3, #0]
     b66:	e03d      	b.n	be4 <can_filter_switch+0x118>
        }
    }
    else {
        struct can_standard_message_filter_element *filter = pHwFilters;
     b68:	4b22      	ldr	r3, [pc, #136]	; (bf4 <can_filter_switch+0x128>)
     b6a:	681b      	ldr	r3, [r3, #0]
     b6c:	60bb      	str	r3, [r7, #8]

        if (index >= CONF_CAN0_RX_STANDARD_ID_FILTER_NUM) 
     b6e:	1dbb      	adds	r3, r7, #6
     b70:	781b      	ldrb	r3, [r3, #0]
     b72:	2b04      	cmp	r3, #4
     b74:	d901      	bls.n	b7a <can_filter_switch+0xae>
            return 1;
     b76:	2301      	movs	r3, #1
     b78:	e035      	b.n	be6 <can_filter_switch+0x11a>

        if (filter[index].S0.reg == 0)    /* Don't touch a NULL filter */
     b7a:	1dbb      	adds	r3, r7, #6
     b7c:	781b      	ldrb	r3, [r3, #0]
     b7e:	009b      	lsls	r3, r3, #2
     b80:	68ba      	ldr	r2, [r7, #8]
     b82:	18d3      	adds	r3, r2, r3
     b84:	681b      	ldr	r3, [r3, #0]
     b86:	2b00      	cmp	r3, #0
     b88:	d101      	bne.n	b8e <can_filter_switch+0xc2>
            return (1);
     b8a:	2301      	movs	r3, #1
     b8c:	e02b      	b.n	be6 <can_filter_switch+0x11a>

        if (on) {
     b8e:	1dfb      	adds	r3, r7, #7
     b90:	781b      	ldrb	r3, [r3, #0]
     b92:	2b00      	cmp	r3, #0
     b94:	d01d      	beq.n	bd2 <can_filter_switch+0x106>
            /* Handle special case, filter 0, is the 'reject' filter */
            if (index == 0)
     b96:	1dbb      	adds	r3, r7, #6
     b98:	781b      	ldrb	r3, [r3, #0]
     b9a:	2b00      	cmp	r3, #0
     b9c:	d10c      	bne.n	bb8 <can_filter_switch+0xec>
                filter[index].S0.bit.SFEC = 0x3;  /* Reject */
     b9e:	1dbb      	adds	r3, r7, #6
     ba0:	781b      	ldrb	r3, [r3, #0]
     ba2:	009b      	lsls	r3, r3, #2
     ba4:	68ba      	ldr	r2, [r7, #8]
     ba6:	18d3      	adds	r3, r2, r3
     ba8:	681a      	ldr	r2, [r3, #0]
     baa:	4913      	ldr	r1, [pc, #76]	; (bf8 <can_filter_switch+0x12c>)
     bac:	400a      	ands	r2, r1
     bae:	21c0      	movs	r1, #192	; 0xc0
     bb0:	0549      	lsls	r1, r1, #21
     bb2:	430a      	orrs	r2, r1
     bb4:	601a      	str	r2, [r3, #0]
     bb6:	e015      	b.n	be4 <can_filter_switch+0x118>
            else
                filter[index].S0.bit.SFEC = 0x1;  /* Store in FIFO 0 */
     bb8:	1dbb      	adds	r3, r7, #6
     bba:	781b      	ldrb	r3, [r3, #0]
     bbc:	009b      	lsls	r3, r3, #2
     bbe:	68ba      	ldr	r2, [r7, #8]
     bc0:	18d3      	adds	r3, r2, r3
     bc2:	681a      	ldr	r2, [r3, #0]
     bc4:	490c      	ldr	r1, [pc, #48]	; (bf8 <can_filter_switch+0x12c>)
     bc6:	400a      	ands	r2, r1
     bc8:	2180      	movs	r1, #128	; 0x80
     bca:	0509      	lsls	r1, r1, #20
     bcc:	430a      	orrs	r2, r1
     bce:	601a      	str	r2, [r3, #0]
     bd0:	e008      	b.n	be4 <can_filter_switch+0x118>
        }
        else 
            filter[index].S0.bit.SFEC = 0x0;  /* Disable */
     bd2:	1dbb      	adds	r3, r7, #6
     bd4:	781b      	ldrb	r3, [r3, #0]
     bd6:	009b      	lsls	r3, r3, #2
     bd8:	68ba      	ldr	r2, [r7, #8]
     bda:	18d3      	adds	r3, r2, r3
     bdc:	681a      	ldr	r2, [r3, #0]
     bde:	4906      	ldr	r1, [pc, #24]	; (bf8 <can_filter_switch+0x12c>)
     be0:	400a      	ands	r2, r1
     be2:	601a      	str	r2, [r3, #0]
    }
    return (0);
     be4:	2300      	movs	r3, #0
}
     be6:	0018      	movs	r0, r3
     be8:	46bd      	mov	sp, r7
     bea:	b005      	add	sp, #20
     bec:	bd90      	pop	{r4, r7, pc}
     bee:	46c0      	nop			; (mov r8, r8)
     bf0:	20003308 	.word	0x20003308
     bf4:	2000330c 	.word	0x2000330c
     bf8:	c7ffffff 	.word	0xc7ffffff

00000bfc <can_filters_init>:

void can_filters_init(void)
{
     bfc:	b580      	push	{r7, lr}
     bfe:	b086      	sub	sp, #24
     c00:	af00      	add	r7, sp, #0
    struct can_standard_message_filter_element filter;
    struct can_extended_message_filter_element xfilter;

    /* Save the base addresses of the filter tables */
    pHwFiltersX = (struct can_extended_message_filter_element *) 
        (pCAN->hw->XIDFC.bit.FLESA | MEM_BASE);
     c02:	4b3c      	ldr	r3, [pc, #240]	; (cf4 <can_filters_init+0xf8>)
     c04:	681b      	ldr	r3, [r3, #0]
     c06:	681b      	ldr	r3, [r3, #0]
     c08:	2288      	movs	r2, #136	; 0x88
     c0a:	589b      	ldr	r3, [r3, r2]
     c0c:	b29b      	uxth	r3, r3
     c0e:	001a      	movs	r2, r3
     c10:	2380      	movs	r3, #128	; 0x80
     c12:	059b      	lsls	r3, r3, #22
     c14:	4313      	orrs	r3, r2
    pHwFiltersX = (struct can_extended_message_filter_element *) 
     c16:	001a      	movs	r2, r3
     c18:	4b37      	ldr	r3, [pc, #220]	; (cf8 <can_filters_init+0xfc>)
     c1a:	601a      	str	r2, [r3, #0]
    pHwFilters  = (struct can_standard_message_filter_element *) 
        (pCAN->hw->SIDFC.bit.FLSSA | MEM_BASE);
     c1c:	4b35      	ldr	r3, [pc, #212]	; (cf4 <can_filters_init+0xf8>)
     c1e:	681b      	ldr	r3, [r3, #0]
     c20:	681b      	ldr	r3, [r3, #0]
     c22:	2284      	movs	r2, #132	; 0x84
     c24:	589b      	ldr	r3, [r3, r2]
     c26:	b29b      	uxth	r3, r3
     c28:	001a      	movs	r2, r3
     c2a:	2380      	movs	r3, #128	; 0x80
     c2c:	059b      	lsls	r3, r3, #22
     c2e:	4313      	orrs	r3, r2
    pHwFilters  = (struct can_standard_message_filter_element *) 
     c30:	001a      	movs	r2, r3
     c32:	4b32      	ldr	r3, [pc, #200]	; (cfc <can_filters_init+0x100>)
     c34:	601a      	str	r2, [r3, #0]

    /* Clear all the standard filters */
    p = (uint32_t *) pHwFilters;
     c36:	4b31      	ldr	r3, [pc, #196]	; (cfc <can_filters_init+0x100>)
     c38:	681b      	ldr	r3, [r3, #0]
     c3a:	613b      	str	r3, [r7, #16]
    for (i = 0; i < CONF_CAN0_RX_STANDARD_ID_FILTER_NUM; i++) 
     c3c:	2300      	movs	r3, #0
     c3e:	617b      	str	r3, [r7, #20]
     c40:	e007      	b.n	c52 <can_filters_init+0x56>
        *p++ = 0x0;
     c42:	693b      	ldr	r3, [r7, #16]
     c44:	1d1a      	adds	r2, r3, #4
     c46:	613a      	str	r2, [r7, #16]
     c48:	2200      	movs	r2, #0
     c4a:	601a      	str	r2, [r3, #0]
    for (i = 0; i < CONF_CAN0_RX_STANDARD_ID_FILTER_NUM; i++) 
     c4c:	697b      	ldr	r3, [r7, #20]
     c4e:	3301      	adds	r3, #1
     c50:	617b      	str	r3, [r7, #20]
     c52:	697b      	ldr	r3, [r7, #20]
     c54:	2b04      	cmp	r3, #4
     c56:	ddf4      	ble.n	c42 <can_filters_init+0x46>

    p = (uint32_t *) pHwFiltersX;
     c58:	4b27      	ldr	r3, [pc, #156]	; (cf8 <can_filters_init+0xfc>)
     c5a:	681b      	ldr	r3, [r3, #0]
     c5c:	613b      	str	r3, [r7, #16]
    /* Clear all the extended filters */
    for (i = 0; i < CONF_CAN0_RX_EXTENDED_ID_FILTER_NUM; i++) {
     c5e:	2300      	movs	r3, #0
     c60:	617b      	str	r3, [r7, #20]
     c62:	e00c      	b.n	c7e <can_filters_init+0x82>
        *p++ = 0x0;
     c64:	693b      	ldr	r3, [r7, #16]
     c66:	1d1a      	adds	r2, r3, #4
     c68:	613a      	str	r2, [r7, #16]
     c6a:	2200      	movs	r2, #0
     c6c:	601a      	str	r2, [r3, #0]
        *p++ = 0x0;
     c6e:	693b      	ldr	r3, [r7, #16]
     c70:	1d1a      	adds	r2, r3, #4
     c72:	613a      	str	r2, [r7, #16]
     c74:	2200      	movs	r2, #0
     c76:	601a      	str	r2, [r3, #0]
    for (i = 0; i < CONF_CAN0_RX_EXTENDED_ID_FILTER_NUM; i++) {
     c78:	697b      	ldr	r3, [r7, #20]
     c7a:	3301      	adds	r3, #1
     c7c:	617b      	str	r3, [r7, #20]
     c7e:	697b      	ldr	r3, [r7, #20]
     c80:	2b09      	cmp	r3, #9
     c82:	ddef      	ble.n	c64 <can_filters_init+0x68>
     *   ID: all bits on
     *   Mask: all bits off   (everything matches)
     *   Action: reject (0x3).  Initialized to 0 for "disable"
     */
    if (CONF_CAN0_RX_EXTENDED_ID_FILTER_NUM) {
        can_get_extended_message_filter_element_default(&xfilter);
     c84:	1d3b      	adds	r3, r7, #4
     c86:	0018      	movs	r0, r3
     c88:	4b1d      	ldr	r3, [pc, #116]	; (d00 <can_filters_init+0x104>)
     c8a:	4798      	blx	r3
        xfilter.F0.bit.EFID1 = 0x1ffffffful;
     c8c:	1d3b      	adds	r3, r7, #4
     c8e:	681a      	ldr	r2, [r3, #0]
     c90:	491c      	ldr	r1, [pc, #112]	; (d04 <can_filters_init+0x108>)
     c92:	430a      	orrs	r2, r1
     c94:	601a      	str	r2, [r3, #0]
        xfilter.F1.bit.EFID2 = 0;              /* Mask is 0 */
     c96:	1d3b      	adds	r3, r7, #4
     c98:	685a      	ldr	r2, [r3, #4]
     c9a:	0f52      	lsrs	r2, r2, #29
     c9c:	0752      	lsls	r2, r2, #29
     c9e:	605a      	str	r2, [r3, #4]
        xfilter.F0.bit.EFEC = 0;               /* Disable */
     ca0:	1d3b      	adds	r3, r7, #4
     ca2:	681a      	ldr	r2, [r3, #0]
     ca4:	00d2      	lsls	r2, r2, #3
     ca6:	08d2      	lsrs	r2, r2, #3
     ca8:	601a      	str	r2, [r3, #0]
        can_set_rx_extended_filter(pCAN, &xfilter, 0); 
     caa:	4b12      	ldr	r3, [pc, #72]	; (cf4 <can_filters_init+0xf8>)
     cac:	681b      	ldr	r3, [r3, #0]
     cae:	1d39      	adds	r1, r7, #4
     cb0:	2200      	movs	r2, #0
     cb2:	0018      	movs	r0, r3
     cb4:	4b14      	ldr	r3, [pc, #80]	; (d08 <can_filters_init+0x10c>)
     cb6:	4798      	blx	r3
    }

    if (CONF_CAN0_RX_STANDARD_ID_FILTER_NUM) {
        can_get_standard_message_filter_element_default(&filter);
     cb8:	230c      	movs	r3, #12
     cba:	18fb      	adds	r3, r7, r3
     cbc:	0018      	movs	r0, r3
     cbe:	4b13      	ldr	r3, [pc, #76]	; (d0c <can_filters_init+0x110>)
     cc0:	4798      	blx	r3
        filter.S0.bit.SFID1 = 0x7fful;
     cc2:	68fb      	ldr	r3, [r7, #12]
     cc4:	4a12      	ldr	r2, [pc, #72]	; (d10 <can_filters_init+0x114>)
     cc6:	4313      	orrs	r3, r2
     cc8:	60fb      	str	r3, [r7, #12]
        filter.S0.bit.SFID2 = 0;              /* Mask is 0 */
     cca:	68fb      	ldr	r3, [r7, #12]
     ccc:	0adb      	lsrs	r3, r3, #11
     cce:	02db      	lsls	r3, r3, #11
     cd0:	60fb      	str	r3, [r7, #12]
        filter.S0.bit.SFEC = 0;               /* Disable */
     cd2:	68fb      	ldr	r3, [r7, #12]
     cd4:	4a0f      	ldr	r2, [pc, #60]	; (d14 <can_filters_init+0x118>)
     cd6:	4013      	ands	r3, r2
     cd8:	60fb      	str	r3, [r7, #12]
        can_set_rx_standard_filter(pCAN, &filter, 0); 
     cda:	4b06      	ldr	r3, [pc, #24]	; (cf4 <can_filters_init+0xf8>)
     cdc:	681b      	ldr	r3, [r3, #0]
     cde:	220c      	movs	r2, #12
     ce0:	18b9      	adds	r1, r7, r2
     ce2:	2200      	movs	r2, #0
     ce4:	0018      	movs	r0, r3
     ce6:	4b0c      	ldr	r3, [pc, #48]	; (d18 <can_filters_init+0x11c>)
     ce8:	4798      	blx	r3
    }
}
     cea:	46c0      	nop			; (mov r8, r8)
     cec:	46bd      	mov	sp, r7
     cee:	b006      	add	sp, #24
     cf0:	bd80      	pop	{r7, pc}
     cf2:	46c0      	nop			; (mov r8, r8)
     cf4:	2000000c 	.word	0x2000000c
     cf8:	20003308 	.word	0x20003308
     cfc:	2000330c 	.word	0x2000330c
     d00:	00000965 	.word	0x00000965
     d04:	1fffffff 	.word	0x1fffffff
     d08:	00000775 	.word	0x00000775
     d0c:	00000949 	.word	0x00000949
     d10:	07ff0000 	.word	0x07ff0000
     d14:	c7ffffff 	.word	0xc7ffffff
     d18:	00000719 	.word	0x00000719

00000d1c <can_msg_get>:
/* Note: This function assumes that there is only one reader of CAN
 *       packets and that it is 'can_rx_task'.  In that case, we
 *       can use a FreeRTOS task variable instead of a semaphore.
 */
int can_msg_get(int timeout)
{
     d1c:	b580      	push	{r7, lr}
     d1e:	b084      	sub	sp, #16
     d20:	af00      	add	r7, sp, #0
     d22:	6078      	str	r0, [r7, #4]
    int index;
    uint32_t status;

retry:
    status = can_rx_get_fifo_status(pCAN, 0);
     d24:	4b10      	ldr	r3, [pc, #64]	; (d68 <can_msg_get+0x4c>)
     d26:	681b      	ldr	r3, [r3, #0]
     d28:	2100      	movs	r1, #0
     d2a:	0018      	movs	r0, r3
     d2c:	4b0f      	ldr	r3, [pc, #60]	; (d6c <can_msg_get+0x50>)
     d2e:	4798      	blx	r3
     d30:	0003      	movs	r3, r0
     d32:	60fb      	str	r3, [r7, #12]
    if ((status & 0x7f) == 0) {                /* Nothing in FIFO, wait... */
     d34:	68fb      	ldr	r3, [r7, #12]
     d36:	227f      	movs	r2, #127	; 0x7f
     d38:	4013      	ands	r3, r2
     d3a:	d10a      	bne.n	d52 <can_msg_get+0x36>
#if 1
        if (ulTaskNotifyTake(pdTRUE, timeout) == 0) {
     d3c:	687b      	ldr	r3, [r7, #4]
     d3e:	0019      	movs	r1, r3
     d40:	2001      	movs	r0, #1
     d42:	4b0b      	ldr	r3, [pc, #44]	; (d70 <can_msg_get+0x54>)
     d44:	4798      	blx	r3
     d46:	1e03      	subs	r3, r0, #0
     d48:	d100      	bne.n	d4c <can_msg_get+0x30>
#else
        if (xSemaphoreTake(canRxSemaphore, timeout) == pdPASS) {
#endif
            goto retry;    /* re-read status to confirm that this isn't an old semaphore */
     d4a:	e7eb      	b.n	d24 <can_msg_get+0x8>
        }
        else
            return (-1);         /* timeout */
     d4c:	2301      	movs	r3, #1
     d4e:	425b      	negs	r3, r3
     d50:	e006      	b.n	d60 <can_msg_get+0x44>
    }

    index = (status >> 8) & 0x3f;
     d52:	68fb      	ldr	r3, [r7, #12]
     d54:	0a1b      	lsrs	r3, r3, #8
     d56:	001a      	movs	r2, r3
     d58:	233f      	movs	r3, #63	; 0x3f
     d5a:	4013      	ands	r3, r2
     d5c:	60bb      	str	r3, [r7, #8]

    return (index);
     d5e:	68bb      	ldr	r3, [r7, #8]
}
     d60:	0018      	movs	r0, r3
     d62:	46bd      	mov	sp, r7
     d64:	b004      	add	sp, #16
     d66:	bd80      	pop	{r7, pc}
     d68:	2000000c 	.word	0x2000000c
     d6c:	000008c9 	.word	0x000008c9
     d70:	00004d9d 	.word	0x00004d9d

00000d74 <can_msg_free>:

/* For CAN0, FIFO 0, return FIFO buffer back to controller */
int can_msg_free(int index)
{
     d74:	b580      	push	{r7, lr}
     d76:	b082      	sub	sp, #8
     d78:	af00      	add	r7, sp, #0
     d7a:	6078      	str	r0, [r7, #4]
    can_rx_fifo_acknowledge(pCAN, 0, index);
     d7c:	4b05      	ldr	r3, [pc, #20]	; (d94 <can_msg_free+0x20>)
     d7e:	681b      	ldr	r3, [r3, #0]
     d80:	687a      	ldr	r2, [r7, #4]
     d82:	2100      	movs	r1, #0
     d84:	0018      	movs	r0, r3
     d86:	4b04      	ldr	r3, [pc, #16]	; (d98 <can_msg_free+0x24>)
     d88:	4798      	blx	r3
}
     d8a:	46c0      	nop			; (mov r8, r8)
     d8c:	0018      	movs	r0, r3
     d8e:	46bd      	mov	sp, r7
     d90:	b002      	add	sp, #8
     d92:	bd80      	pop	{r7, pc}
     d94:	2000000c 	.word	0x2000000c
     d98:	000008ff 	.word	0x000008ff

00000d9c <get_help>:
    {"xled", "\txled  <led number>\r\n",           CMD_XLED,
            "\t! Turn off LED (TBD)\r\n"},
};

char *get_help(uint8_t cmd)
{
     d9c:	b580      	push	{r7, lr}
     d9e:	b084      	sub	sp, #16
     da0:	af00      	add	r7, sp, #0
     da2:	0002      	movs	r2, r0
     da4:	1dfb      	adds	r3, r7, #7
     da6:	701a      	strb	r2, [r3, #0]
    uint8_t i = 0;
     da8:	230f      	movs	r3, #15
     daa:	18fb      	adds	r3, r7, r3
     dac:	2200      	movs	r2, #0
     dae:	701a      	strb	r2, [r3, #0]
    char *rval = NULL;
     db0:	2300      	movs	r3, #0
     db2:	60bb      	str	r3, [r7, #8]

    for (i = 0; i < NUM_COMMANDS; i++) {
     db4:	230f      	movs	r3, #15
     db6:	18fb      	adds	r3, r7, r3
     db8:	2200      	movs	r2, #0
     dba:	701a      	strb	r2, [r3, #0]
     dbc:	e01d      	b.n	dfa <get_help+0x5e>
       if (cmd == cli[i].cmd) {
     dbe:	1dfb      	adds	r3, r7, #7
     dc0:	781b      	ldrb	r3, [r3, #0]
     dc2:	b29a      	uxth	r2, r3
     dc4:	230f      	movs	r3, #15
     dc6:	18fb      	adds	r3, r7, r3
     dc8:	781b      	ldrb	r3, [r3, #0]
     dca:	4911      	ldr	r1, [pc, #68]	; (e10 <get_help+0x74>)
     dcc:	011b      	lsls	r3, r3, #4
     dce:	18cb      	adds	r3, r1, r3
     dd0:	3308      	adds	r3, #8
     dd2:	881b      	ldrh	r3, [r3, #0]
     dd4:	429a      	cmp	r2, r3
     dd6:	d109      	bne.n	dec <get_help+0x50>
           rval = cli[i].help;
     dd8:	230f      	movs	r3, #15
     dda:	18fb      	adds	r3, r7, r3
     ddc:	781b      	ldrb	r3, [r3, #0]
     dde:	4a0c      	ldr	r2, [pc, #48]	; (e10 <get_help+0x74>)
     de0:	011b      	lsls	r3, r3, #4
     de2:	18d3      	adds	r3, r2, r3
     de4:	3304      	adds	r3, #4
     de6:	681b      	ldr	r3, [r3, #0]
     de8:	60bb      	str	r3, [r7, #8]
           break;
     dea:	e00b      	b.n	e04 <get_help+0x68>
    for (i = 0; i < NUM_COMMANDS; i++) {
     dec:	230f      	movs	r3, #15
     dee:	18fb      	adds	r3, r7, r3
     df0:	781a      	ldrb	r2, [r3, #0]
     df2:	230f      	movs	r3, #15
     df4:	18fb      	adds	r3, r7, r3
     df6:	3201      	adds	r2, #1
     df8:	701a      	strb	r2, [r3, #0]
     dfa:	230f      	movs	r3, #15
     dfc:	18fb      	adds	r3, r7, r3
     dfe:	781b      	ldrb	r3, [r3, #0]
     e00:	2b0a      	cmp	r3, #10
     e02:	d9dc      	bls.n	dbe <get_help+0x22>
       }
    }
    return (rval);
     e04:	68bb      	ldr	r3, [r7, #8]
}
     e06:	0018      	movs	r0, r3
     e08:	46bd      	mov	sp, r7
     e0a:	b004      	add	sp, #16
     e0c:	bd80      	pop	{r7, pc}
     e0e:	46c0      	nop			; (mov r8, r8)
     e10:	000071d0 	.word	0x000071d0

00000e14 <get_help_verbose>:

char *get_help_verbose(uint8_t cmd)
{
     e14:	b580      	push	{r7, lr}
     e16:	b084      	sub	sp, #16
     e18:	af00      	add	r7, sp, #0
     e1a:	0002      	movs	r2, r0
     e1c:	1dfb      	adds	r3, r7, #7
     e1e:	701a      	strb	r2, [r3, #0]
    uint8_t i = 0;
     e20:	230f      	movs	r3, #15
     e22:	18fb      	adds	r3, r7, r3
     e24:	2200      	movs	r2, #0
     e26:	701a      	strb	r2, [r3, #0]
    char *rval = NULL;
     e28:	2300      	movs	r3, #0
     e2a:	60bb      	str	r3, [r7, #8]

    for (i = 0; i < NUM_COMMANDS; i++) {
     e2c:	230f      	movs	r3, #15
     e2e:	18fb      	adds	r3, r7, r3
     e30:	2200      	movs	r2, #0
     e32:	701a      	strb	r2, [r3, #0]
     e34:	e01d      	b.n	e72 <get_help_verbose+0x5e>
       if (cmd == cli[i].cmd) {
     e36:	1dfb      	adds	r3, r7, #7
     e38:	781b      	ldrb	r3, [r3, #0]
     e3a:	b29a      	uxth	r2, r3
     e3c:	230f      	movs	r3, #15
     e3e:	18fb      	adds	r3, r7, r3
     e40:	781b      	ldrb	r3, [r3, #0]
     e42:	4911      	ldr	r1, [pc, #68]	; (e88 <get_help_verbose+0x74>)
     e44:	011b      	lsls	r3, r3, #4
     e46:	18cb      	adds	r3, r1, r3
     e48:	3308      	adds	r3, #8
     e4a:	881b      	ldrh	r3, [r3, #0]
     e4c:	429a      	cmp	r2, r3
     e4e:	d109      	bne.n	e64 <get_help_verbose+0x50>
           rval = cli[i].verbose;
     e50:	230f      	movs	r3, #15
     e52:	18fb      	adds	r3, r7, r3
     e54:	781b      	ldrb	r3, [r3, #0]
     e56:	4a0c      	ldr	r2, [pc, #48]	; (e88 <get_help_verbose+0x74>)
     e58:	011b      	lsls	r3, r3, #4
     e5a:	18d3      	adds	r3, r2, r3
     e5c:	330c      	adds	r3, #12
     e5e:	681b      	ldr	r3, [r3, #0]
     e60:	60bb      	str	r3, [r7, #8]
           break;
     e62:	e00b      	b.n	e7c <get_help_verbose+0x68>
    for (i = 0; i < NUM_COMMANDS; i++) {
     e64:	230f      	movs	r3, #15
     e66:	18fb      	adds	r3, r7, r3
     e68:	781a      	ldrb	r2, [r3, #0]
     e6a:	230f      	movs	r3, #15
     e6c:	18fb      	adds	r3, r7, r3
     e6e:	3201      	adds	r2, #1
     e70:	701a      	strb	r2, [r3, #0]
     e72:	230f      	movs	r3, #15
     e74:	18fb      	adds	r3, r7, r3
     e76:	781b      	ldrb	r3, [r3, #0]
     e78:	2b0a      	cmp	r3, #10
     e7a:	d9dc      	bls.n	e36 <get_help_verbose+0x22>
       }
    }
    return (rval);
     e7c:	68bb      	ldr	r3, [r7, #8]
}
     e7e:	0018      	movs	r0, r3
     e80:	46bd      	mov	sp, r7
     e82:	b004      	add	sp, #16
     e84:	bd80      	pop	{r7, pc}
     e86:	46c0      	nop			; (mov r8, r8)
     e88:	000071d0 	.word	0x000071d0

00000e8c <check_digits>:
 * Make sure all the chars in a string are numeric digits.
 * If so, return 0
 *   otherwise return 1
 */
short check_digits(char *p)
{
     e8c:	b580      	push	{r7, lr}
     e8e:	b084      	sub	sp, #16
     e90:	af00      	add	r7, sp, #0
     e92:	6078      	str	r0, [r7, #4]
    short rval = 0;
     e94:	230e      	movs	r3, #14
     e96:	18fb      	adds	r3, r7, r3
     e98:	2200      	movs	r2, #0
     e9a:	801a      	strh	r2, [r3, #0]
    while (*p) {
     e9c:	e013      	b.n	ec6 <check_digits+0x3a>
        if (!isdigit(*p)) {
     e9e:	4b10      	ldr	r3, [pc, #64]	; (ee0 <check_digits+0x54>)
     ea0:	4798      	blx	r3
     ea2:	0002      	movs	r2, r0
     ea4:	687b      	ldr	r3, [r7, #4]
     ea6:	781b      	ldrb	r3, [r3, #0]
     ea8:	3301      	adds	r3, #1
     eaa:	18d3      	adds	r3, r2, r3
     eac:	781b      	ldrb	r3, [r3, #0]
     eae:	001a      	movs	r2, r3
     eb0:	2304      	movs	r3, #4
     eb2:	4013      	ands	r3, r2
     eb4:	d104      	bne.n	ec0 <check_digits+0x34>
            rval = 1;
     eb6:	230e      	movs	r3, #14
     eb8:	18fb      	adds	r3, r7, r3
     eba:	2201      	movs	r2, #1
     ebc:	801a      	strh	r2, [r3, #0]
            break;
     ebe:	e006      	b.n	ece <check_digits+0x42>
        }
        else
            p++;
     ec0:	687b      	ldr	r3, [r7, #4]
     ec2:	3301      	adds	r3, #1
     ec4:	607b      	str	r3, [r7, #4]
    while (*p) {
     ec6:	687b      	ldr	r3, [r7, #4]
     ec8:	781b      	ldrb	r3, [r3, #0]
     eca:	2b00      	cmp	r3, #0
     ecc:	d1e7      	bne.n	e9e <check_digits+0x12>
    }
    return (rval);
     ece:	230e      	movs	r3, #14
     ed0:	18fb      	adds	r3, r7, r3
     ed2:	2200      	movs	r2, #0
     ed4:	5e9b      	ldrsh	r3, [r3, r2]
}
     ed6:	0018      	movs	r0, r3
     ed8:	46bd      	mov	sp, r7
     eda:	b004      	add	sp, #16
     edc:	bd80      	pop	{r7, pc}
     ede:	46c0      	nop			; (mov r8, r8)
     ee0:	00006be5 	.word	0x00006be5

00000ee4 <get_num>:
 * Convert a decimal string to a number.
 * Value is returned in param.
 * Failed conversion returns 1
 */
int16_t get_num(char *token, uint16_t *param)
{
     ee4:	b580      	push	{r7, lr}
     ee6:	b082      	sub	sp, #8
     ee8:	af00      	add	r7, sp, #0
     eea:	6078      	str	r0, [r7, #4]
     eec:	6039      	str	r1, [r7, #0]
    if (check_digits(token) == 0) {
     eee:	687b      	ldr	r3, [r7, #4]
     ef0:	0018      	movs	r0, r3
     ef2:	4b09      	ldr	r3, [pc, #36]	; (f18 <get_num+0x34>)
     ef4:	4798      	blx	r3
     ef6:	1e03      	subs	r3, r0, #0
     ef8:	d109      	bne.n	f0e <get_num+0x2a>
        *param = atoi(token);
     efa:	687b      	ldr	r3, [r7, #4]
     efc:	0018      	movs	r0, r3
     efe:	4b07      	ldr	r3, [pc, #28]	; (f1c <get_num+0x38>)
     f00:	4798      	blx	r3
     f02:	0003      	movs	r3, r0
     f04:	b29a      	uxth	r2, r3
     f06:	683b      	ldr	r3, [r7, #0]
     f08:	801a      	strh	r2, [r3, #0]
        return 0;
     f0a:	2300      	movs	r3, #0
     f0c:	e000      	b.n	f10 <get_num+0x2c>
    }
    return 1;
     f0e:	2301      	movs	r3, #1
}
     f10:	0018      	movs	r0, r3
     f12:	46bd      	mov	sp, r7
     f14:	b002      	add	sp, #8
     f16:	bd80      	pop	{r7, pc}
     f18:	00000e8d 	.word	0x00000e8d
     f1c:	00006b89 	.word	0x00006b89

00000f20 <match_command>:
/*
 * Find token in table.
 * Return command code, or 0 if not found.
 */
uint8_t match_command(char *token)
{
     f20:	b580      	push	{r7, lr}
     f22:	b084      	sub	sp, #16
     f24:	af00      	add	r7, sp, #0
     f26:	6078      	str	r0, [r7, #4]
    uint8_t i = NUM_COMMANDS;
     f28:	230f      	movs	r3, #15
     f2a:	18fb      	adds	r3, r7, r3
     f2c:	220b      	movs	r2, #11
     f2e:	701a      	strb	r2, [r3, #0]
    for (i = 0; i < NUM_COMMANDS; i++)
     f30:	230f      	movs	r3, #15
     f32:	18fb      	adds	r3, r7, r3
     f34:	2200      	movs	r2, #0
     f36:	701a      	strb	r2, [r3, #0]
     f38:	e01d      	b.n	f76 <match_command+0x56>
       if (strcmp(token, cli[i].text) == 0)
     f3a:	230f      	movs	r3, #15
     f3c:	18fb      	adds	r3, r7, r3
     f3e:	781a      	ldrb	r2, [r3, #0]
     f40:	4b12      	ldr	r3, [pc, #72]	; (f8c <match_command+0x6c>)
     f42:	0112      	lsls	r2, r2, #4
     f44:	58d2      	ldr	r2, [r2, r3]
     f46:	687b      	ldr	r3, [r7, #4]
     f48:	0011      	movs	r1, r2
     f4a:	0018      	movs	r0, r3
     f4c:	4b10      	ldr	r3, [pc, #64]	; (f90 <match_command+0x70>)
     f4e:	4798      	blx	r3
     f50:	1e03      	subs	r3, r0, #0
     f52:	d109      	bne.n	f68 <match_command+0x48>
           return cli[i].cmd;
     f54:	230f      	movs	r3, #15
     f56:	18fb      	adds	r3, r7, r3
     f58:	781b      	ldrb	r3, [r3, #0]
     f5a:	4a0c      	ldr	r2, [pc, #48]	; (f8c <match_command+0x6c>)
     f5c:	011b      	lsls	r3, r3, #4
     f5e:	18d3      	adds	r3, r2, r3
     f60:	3308      	adds	r3, #8
     f62:	881b      	ldrh	r3, [r3, #0]
     f64:	b2db      	uxtb	r3, r3
     f66:	e00c      	b.n	f82 <match_command+0x62>
    for (i = 0; i < NUM_COMMANDS; i++)
     f68:	230f      	movs	r3, #15
     f6a:	18fb      	adds	r3, r7, r3
     f6c:	781a      	ldrb	r2, [r3, #0]
     f6e:	230f      	movs	r3, #15
     f70:	18fb      	adds	r3, r7, r3
     f72:	3201      	adds	r2, #1
     f74:	701a      	strb	r2, [r3, #0]
     f76:	230f      	movs	r3, #15
     f78:	18fb      	adds	r3, r7, r3
     f7a:	781b      	ldrb	r3, [r3, #0]
     f7c:	2b0a      	cmp	r3, #10
     f7e:	d9dc      	bls.n	f3a <match_command+0x1a>
    return (0);
     f80:	2300      	movs	r3, #0
}
     f82:	0018      	movs	r0, r3
     f84:	46bd      	mov	sp, r7
     f86:	b004      	add	sp, #16
     f88:	bd80      	pop	{r7, pc}
     f8a:	46c0      	nop			; (mov r8, r8)
     f8c:	000071d0 	.word	0x000071d0
     f90:	00006c47 	.word	0x00006c47

00000f94 <get_command>:
 * Scan buffer for command.
 * Return CMD value, or 0 if no command.
 * If command has a arg, return in *param.
 */
int16_t get_command(char *buf, uint16_t *param, uint16_t *param2)
{
     f94:	b590      	push	{r4, r7, lr}
     f96:	b089      	sub	sp, #36	; 0x24
     f98:	af00      	add	r7, sp, #0
     f9a:	60f8      	str	r0, [r7, #12]
     f9c:	60b9      	str	r1, [r7, #8]
     f9e:	607a      	str	r2, [r7, #4]
    char *token = buf;
     fa0:	68fb      	ldr	r3, [r7, #12]
     fa2:	61bb      	str	r3, [r7, #24]
    int16_t rval = 0;
     fa4:	2316      	movs	r3, #22
     fa6:	18fb      	adds	r3, r7, r3
     fa8:	2200      	movs	r2, #0
     faa:	801a      	strh	r2, [r3, #0]
    uint8_t cmd;

    /* Find beginning of command... (skip leading spaces) */
    token = strtok(buf, ws2);
     fac:	4b3d      	ldr	r3, [pc, #244]	; (10a4 <get_command+0x110>)
     fae:	681a      	ldr	r2, [r3, #0]
     fb0:	68fb      	ldr	r3, [r7, #12]
     fb2:	0011      	movs	r1, r2
     fb4:	0018      	movs	r0, r3
     fb6:	4b3c      	ldr	r3, [pc, #240]	; (10a8 <get_command+0x114>)
     fb8:	4798      	blx	r3
     fba:	0003      	movs	r3, r0
     fbc:	61bb      	str	r3, [r7, #24]
    cmd = match_command(token);
     fbe:	231f      	movs	r3, #31
     fc0:	18fc      	adds	r4, r7, r3
     fc2:	69bb      	ldr	r3, [r7, #24]
     fc4:	0018      	movs	r0, r3
     fc6:	4b39      	ldr	r3, [pc, #228]	; (10ac <get_command+0x118>)
     fc8:	4798      	blx	r3
     fca:	0003      	movs	r3, r0
     fcc:	7023      	strb	r3, [r4, #0]

    /* Early exit if argless command  */
    if (cmd == 0 ||                   
     fce:	231f      	movs	r3, #31
     fd0:	18fb      	adds	r3, r7, r3
     fd2:	781b      	ldrb	r3, [r3, #0]
     fd4:	2b00      	cmp	r3, #0
     fd6:	d01d      	beq.n	1014 <get_command+0x80>
     fd8:	231f      	movs	r3, #31
     fda:	18fb      	adds	r3, r7, r3
     fdc:	781b      	ldrb	r3, [r3, #0]
     fde:	2b04      	cmp	r3, #4
     fe0:	d018      	beq.n	1014 <get_command+0x80>
        cmd == CMD_CAN     || 
     fe2:	231f      	movs	r3, #31
     fe4:	18fb      	adds	r3, r7, r3
     fe6:	781b      	ldrb	r3, [r3, #0]
     fe8:	2b08      	cmp	r3, #8
     fea:	d013      	beq.n	1014 <get_command+0x80>
        cmd == CMD_XCAN    || 
     fec:	231f      	movs	r3, #31
     fee:	18fb      	adds	r3, r7, r3
     ff0:	781b      	ldrb	r3, [r3, #0]
     ff2:	2b09      	cmp	r3, #9
     ff4:	d00e      	beq.n	1014 <get_command+0x80>
        cmd == CMD_READER  || 
     ff6:	231f      	movs	r3, #31
     ff8:	18fb      	adds	r3, r7, r3
     ffa:	781b      	ldrb	r3, [r3, #0]
     ffc:	2b0a      	cmp	r3, #10
     ffe:	d009      	beq.n	1014 <get_command+0x80>
        cmd == CMD_XREADER || 
    1000:	231f      	movs	r3, #31
    1002:	18fb      	adds	r3, r7, r3
    1004:	781b      	ldrb	r3, [r3, #0]
    1006:	2b0b      	cmp	r3, #11
    1008:	d004      	beq.n	1014 <get_command+0x80>
        cmd == CMD_SEND    || 
    100a:	231f      	movs	r3, #31
    100c:	18fb      	adds	r3, r7, r3
    100e:	781b      	ldrb	r3, [r3, #0]
    1010:	2b06      	cmp	r3, #6
    1012:	d104      	bne.n	101e <get_command+0x8a>
        cmd == CMD_PING)
        return (cmd);
    1014:	231f      	movs	r3, #31
    1016:	18fb      	adds	r3, r7, r3
    1018:	781b      	ldrb	r3, [r3, #0]
    101a:	b21b      	sxth	r3, r3
    101c:	e03e      	b.n	109c <get_command+0x108>

    switch (cmd) {              /* Switch on command */
    101e:	231f      	movs	r3, #31
    1020:	18fb      	adds	r3, r7, r3
    1022:	781b      	ldrb	r3, [r3, #0]
    1024:	2b07      	cmp	r3, #7
    1026:	d832      	bhi.n	108e <get_command+0xfa>
    1028:	009a      	lsls	r2, r3, #2
    102a:	4b21      	ldr	r3, [pc, #132]	; (10b0 <get_command+0x11c>)
    102c:	18d3      	adds	r3, r2, r3
    102e:	681b      	ldr	r3, [r3, #0]
    1030:	469f      	mov	pc, r3
        case CMD_BAUD:
        case CMD_LOOP:
        case CMD_LED:
        case CMD_XLED:

            token = strtok(NULL, ws2);
    1032:	4b1c      	ldr	r3, [pc, #112]	; (10a4 <get_command+0x110>)
    1034:	681b      	ldr	r3, [r3, #0]
    1036:	0019      	movs	r1, r3
    1038:	2000      	movs	r0, #0
    103a:	4b1b      	ldr	r3, [pc, #108]	; (10a8 <get_command+0x114>)
    103c:	4798      	blx	r3
    103e:	0003      	movs	r3, r0
    1040:	61bb      	str	r3, [r7, #24]
            rval = get_num(token, param);
    1042:	2316      	movs	r3, #22
    1044:	18fc      	adds	r4, r7, r3
    1046:	68ba      	ldr	r2, [r7, #8]
    1048:	69bb      	ldr	r3, [r7, #24]
    104a:	0011      	movs	r1, r2
    104c:	0018      	movs	r0, r3
    104e:	4b19      	ldr	r3, [pc, #100]	; (10b4 <get_command+0x120>)
    1050:	4798      	blx	r3
    1052:	0003      	movs	r3, r0
    1054:	8023      	strh	r3, [r4, #0]

            if (rval) 
    1056:	2316      	movs	r3, #22
    1058:	18fb      	adds	r3, r7, r3
    105a:	2200      	movs	r2, #0
    105c:	5e9b      	ldrsh	r3, [r3, r2]
    105e:	2b00      	cmp	r3, #0
    1060:	d017      	beq.n	1092 <get_command+0xfe>
                cmd = 0;
    1062:	231f      	movs	r3, #31
    1064:	18fb      	adds	r3, r7, r3
    1066:	2200      	movs	r2, #0
    1068:	701a      	strb	r2, [r3, #0]

            break;
    106a:	e012      	b.n	1092 <get_command+0xfe>

        case CMD_HELP:

            token = strtok(NULL, ws2);
    106c:	4b0d      	ldr	r3, [pc, #52]	; (10a4 <get_command+0x110>)
    106e:	681b      	ldr	r3, [r3, #0]
    1070:	0019      	movs	r1, r3
    1072:	2000      	movs	r0, #0
    1074:	4b0c      	ldr	r3, [pc, #48]	; (10a8 <get_command+0x114>)
    1076:	4798      	blx	r3
    1078:	0003      	movs	r3, r0
    107a:	61bb      	str	r3, [r7, #24]
            *param = match_command(token);
    107c:	69bb      	ldr	r3, [r7, #24]
    107e:	0018      	movs	r0, r3
    1080:	4b0a      	ldr	r3, [pc, #40]	; (10ac <get_command+0x118>)
    1082:	4798      	blx	r3
    1084:	0003      	movs	r3, r0
    1086:	b29a      	uxth	r2, r3
    1088:	68bb      	ldr	r3, [r7, #8]
    108a:	801a      	strh	r2, [r3, #0]
       
            break;
    108c:	e002      	b.n	1094 <get_command+0x100>
default:
break;
    108e:	46c0      	nop			; (mov r8, r8)
    1090:	e000      	b.n	1094 <get_command+0x100>
            break;
    1092:	46c0      	nop			; (mov r8, r8)
    }
    return (cmd);
    1094:	231f      	movs	r3, #31
    1096:	18fb      	adds	r3, r7, r3
    1098:	781b      	ldrb	r3, [r3, #0]
    109a:	b21b      	sxth	r3, r3
}
    109c:	0018      	movs	r0, r3
    109e:	46bd      	mov	sp, r7
    10a0:	b009      	add	sp, #36	; 0x24
    10a2:	bd90      	pop	{r4, r7, pc}
    10a4:	20000000 	.word	0x20000000
    10a8:	00006c79 	.word	0x00006c79
    10ac:	00000f21 	.word	0x00000f21
    10b0:	00007280 	.word	0x00007280
    10b4:	00000ee5 	.word	0x00000ee5

000010b8 <system_interrupt_enable>:
 *
 * \param[in] vector Interrupt vector to enable
 */
static inline void system_interrupt_enable(
		const enum system_interrupt_vector vector)
{
    10b8:	b580      	push	{r7, lr}
    10ba:	b082      	sub	sp, #8
    10bc:	af00      	add	r7, sp, #0
    10be:	0002      	movs	r2, r0
    10c0:	1dfb      	adds	r3, r7, #7
    10c2:	701a      	strb	r2, [r3, #0]
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
    10c4:	4b06      	ldr	r3, [pc, #24]	; (10e0 <system_interrupt_enable+0x28>)
    10c6:	1dfa      	adds	r2, r7, #7
    10c8:	7812      	ldrb	r2, [r2, #0]
    10ca:	0011      	movs	r1, r2
    10cc:	221f      	movs	r2, #31
    10ce:	400a      	ands	r2, r1
    10d0:	2101      	movs	r1, #1
    10d2:	4091      	lsls	r1, r2
    10d4:	000a      	movs	r2, r1
    10d6:	601a      	str	r2, [r3, #0]
}
    10d8:	46c0      	nop			; (mov r8, r8)
    10da:	46bd      	mov	sp, r7
    10dc:	b002      	add	sp, #8
    10de:	bd80      	pop	{r7, pc}
    10e0:	e000e100 	.word	0xe000e100

000010e4 <usart_is_syncing>:
 * \retval false  Peripheral is not busy syncing and can be read/written without
 *                stalling the bus
 */
static inline bool usart_is_syncing(
		const struct usart_module *const module)
{
    10e4:	b580      	push	{r7, lr}
    10e6:	b084      	sub	sp, #16
    10e8:	af00      	add	r7, sp, #0
    10ea:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);
    10ec:	687b      	ldr	r3, [r7, #4]
    10ee:	681b      	ldr	r3, [r3, #0]
    10f0:	60fb      	str	r3, [r7, #12]

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    10f2:	68fb      	ldr	r3, [r7, #12]
    10f4:	69db      	ldr	r3, [r3, #28]
    10f6:	1e5a      	subs	r2, r3, #1
    10f8:	4193      	sbcs	r3, r2
    10fa:	b2db      	uxtb	r3, r3
#else
	return (usart_hw->STATUS.reg & SERCOM_USART_STATUS_SYNCBUSY);
#endif
}
    10fc:	0018      	movs	r0, r3
    10fe:	46bd      	mov	sp, r7
    1100:	b004      	add	sp, #16
    1102:	bd80      	pop	{r7, pc}

00001104 <_usart_wait_for_sync>:
 * \internal
 * Waits until synchronization is complete
 */
static inline void _usart_wait_for_sync(
		const struct usart_module *const module)
{
    1104:	b580      	push	{r7, lr}
    1106:	b082      	sub	sp, #8
    1108:	af00      	add	r7, sp, #0
    110a:	6078      	str	r0, [r7, #4]
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    110c:	46c0      	nop			; (mov r8, r8)
    110e:	687b      	ldr	r3, [r7, #4]
    1110:	0018      	movs	r0, r3
    1112:	4b04      	ldr	r3, [pc, #16]	; (1124 <_usart_wait_for_sync+0x20>)
    1114:	4798      	blx	r3
    1116:	1e03      	subs	r3, r0, #0
    1118:	d1f9      	bne.n	110e <_usart_wait_for_sync+0xa>
		/* Wait until the synchronization is complete */
	}
}
    111a:	46c0      	nop			; (mov r8, r8)
    111c:	46bd      	mov	sp, r7
    111e:	b002      	add	sp, #8
    1120:	bd80      	pop	{r7, pc}
    1122:	46c0      	nop			; (mov r8, r8)
    1124:	000010e5 	.word	0x000010e5

00001128 <usart_get_config_defaults>:
 *
 * \param[in,out] config  Pointer to configuration struct
 */
static inline void usart_get_config_defaults(
		struct usart_config *const config)
{
    1128:	b580      	push	{r7, lr}
    112a:	b082      	sub	sp, #8
    112c:	af00      	add	r7, sp, #0
    112e:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Set default config in the config struct */
	config->data_order       = USART_DATAORDER_LSB;
    1130:	687b      	ldr	r3, [r7, #4]
    1132:	2280      	movs	r2, #128	; 0x80
    1134:	05d2      	lsls	r2, r2, #23
    1136:	601a      	str	r2, [r3, #0]
	config->transfer_mode    = USART_TRANSFER_ASYNCHRONOUSLY;
    1138:	687b      	ldr	r3, [r7, #4]
    113a:	2200      	movs	r2, #0
    113c:	605a      	str	r2, [r3, #4]
	config->parity           = USART_PARITY_NONE;
    113e:	687b      	ldr	r3, [r7, #4]
    1140:	22ff      	movs	r2, #255	; 0xff
    1142:	811a      	strh	r2, [r3, #8]
	config->stopbits         = USART_STOPBITS_1;
    1144:	687b      	ldr	r3, [r7, #4]
    1146:	2200      	movs	r2, #0
    1148:	729a      	strb	r2, [r3, #10]
	config->character_size   = USART_CHARACTER_SIZE_8BIT;
    114a:	687b      	ldr	r3, [r7, #4]
    114c:	2200      	movs	r2, #0
    114e:	72da      	strb	r2, [r3, #11]
	config->baudrate         = 9600;
    1150:	687b      	ldr	r3, [r7, #4]
    1152:	2296      	movs	r2, #150	; 0x96
    1154:	0192      	lsls	r2, r2, #6
    1156:	629a      	str	r2, [r3, #40]	; 0x28
	config->receiver_enable  = true;
    1158:	687b      	ldr	r3, [r7, #4]
    115a:	222c      	movs	r2, #44	; 0x2c
    115c:	2101      	movs	r1, #1
    115e:	5499      	strb	r1, [r3, r2]
	config->transmitter_enable = true;
    1160:	687b      	ldr	r3, [r7, #4]
    1162:	222d      	movs	r2, #45	; 0x2d
    1164:	2101      	movs	r1, #1
    1166:	5499      	strb	r1, [r3, r2]
	config->clock_polarity_inverted = false;
    1168:	687b      	ldr	r3, [r7, #4]
    116a:	222e      	movs	r2, #46	; 0x2e
    116c:	2100      	movs	r1, #0
    116e:	5499      	strb	r1, [r3, r2]
	config->use_external_clock = false;
    1170:	687b      	ldr	r3, [r7, #4]
    1172:	222f      	movs	r2, #47	; 0x2f
    1174:	2100      	movs	r1, #0
    1176:	5499      	strb	r1, [r3, r2]
	config->ext_clock_freq   = 0;
    1178:	687b      	ldr	r3, [r7, #4]
    117a:	2200      	movs	r2, #0
    117c:	631a      	str	r2, [r3, #48]	; 0x30
	config->mux_setting      = USART_RX_1_TX_2_XCK_3;
    117e:	687b      	ldr	r3, [r7, #4]
    1180:	2288      	movs	r2, #136	; 0x88
    1182:	0352      	lsls	r2, r2, #13
    1184:	60da      	str	r2, [r3, #12]
	config->run_in_standby   = false;
    1186:	687b      	ldr	r3, [r7, #4]
    1188:	2234      	movs	r2, #52	; 0x34
    118a:	2100      	movs	r1, #0
    118c:	5499      	strb	r1, [r3, r2]
	config->generator_source = GCLK_GENERATOR_0;
    118e:	687b      	ldr	r3, [r7, #4]
    1190:	2235      	movs	r2, #53	; 0x35
    1192:	2100      	movs	r1, #0
    1194:	5499      	strb	r1, [r3, r2]
	config->pinmux_pad0      = PINMUX_DEFAULT;
    1196:	687b      	ldr	r3, [r7, #4]
    1198:	2200      	movs	r2, #0
    119a:	639a      	str	r2, [r3, #56]	; 0x38
	config->pinmux_pad1      = PINMUX_DEFAULT;
    119c:	687b      	ldr	r3, [r7, #4]
    119e:	2200      	movs	r2, #0
    11a0:	63da      	str	r2, [r3, #60]	; 0x3c
	config->pinmux_pad2      = PINMUX_DEFAULT;
    11a2:	687b      	ldr	r3, [r7, #4]
    11a4:	2200      	movs	r2, #0
    11a6:	641a      	str	r2, [r3, #64]	; 0x40
	config->pinmux_pad3      = PINMUX_DEFAULT;
    11a8:	687b      	ldr	r3, [r7, #4]
    11aa:	2200      	movs	r2, #0
    11ac:	645a      	str	r2, [r3, #68]	; 0x44
#ifdef FEATURE_USART_OVER_SAMPLE
	config->sample_adjustment     = USART_SAMPLE_ADJUSTMENT_7_8_9;
    11ae:	687b      	ldr	r3, [r7, #4]
    11b0:	2200      	movs	r2, #0
    11b2:	615a      	str	r2, [r3, #20]
	config->sample_rate           = USART_SAMPLE_RATE_16X_ARITHMETIC;
    11b4:	687b      	ldr	r3, [r7, #4]
    11b6:	2200      	movs	r2, #0
    11b8:	821a      	strh	r2, [r3, #16]
#endif
#ifdef FEATURE_USART_LIN_SLAVE
	config->lin_slave_enable      = false;
    11ba:	687b      	ldr	r3, [r7, #4]
    11bc:	2200      	movs	r2, #0
    11be:	76da      	strb	r2, [r3, #27]
#endif

#ifdef FEATURE_USART_LIN_MASTER
	config->lin_node = LIN_INVALID_MODE;
    11c0:	687b      	ldr	r3, [r7, #4]
    11c2:	2200      	movs	r2, #0
    11c4:	61da      	str	r2, [r3, #28]
	config->lin_header_delay = LIN_MASTER_HEADER_DELAY_0;
    11c6:	687b      	ldr	r3, [r7, #4]
    11c8:	2200      	movs	r2, #0
    11ca:	841a      	strh	r2, [r3, #32]
	config->lin_break_length = LIN_MASTER_BREAK_LENGTH_13_BIT;
    11cc:	687b      	ldr	r3, [r7, #4]
    11ce:	2200      	movs	r2, #0
    11d0:	845a      	strh	r2, [r3, #34]	; 0x22
#endif

#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
	config->immediate_buffer_overflow_notification  = false;
    11d2:	687b      	ldr	r3, [r7, #4]
    11d4:	2200      	movs	r2, #0
    11d6:	761a      	strb	r2, [r3, #24]
#endif
#ifdef FEATURE_USART_START_FRAME_DECTION
	config->start_frame_detection_enable            = false;
    11d8:	687b      	ldr	r3, [r7, #4]
    11da:	2224      	movs	r2, #36	; 0x24
    11dc:	2100      	movs	r1, #0
    11de:	5499      	strb	r1, [r3, r2]
#endif
#ifdef FEATURE_USART_IRDA
	config->encoding_format_enable                  = false;
    11e0:	687b      	ldr	r3, [r7, #4]
    11e2:	2200      	movs	r2, #0
    11e4:	765a      	strb	r2, [r3, #25]
	config->receive_pulse_length                    = 19;
    11e6:	687b      	ldr	r3, [r7, #4]
    11e8:	2213      	movs	r2, #19
    11ea:	769a      	strb	r2, [r3, #26]
	config->iso7816_config.inhibit_nack             = ISO7816_INHIBIT_NACK_DISABLE;
	config->iso7816_config.successive_recv_nack     = ISO7816_SUCCESSIVE_RECV_NACK_DISABLE;
	config->iso7816_config.max_iterations           = 7;
#endif
#ifdef FEATURE_USART_COLLISION_DECTION
	config->collision_detection_enable              = false;
    11ec:	687b      	ldr	r3, [r7, #4]
    11ee:	2226      	movs	r2, #38	; 0x26
    11f0:	2100      	movs	r1, #0
    11f2:	5499      	strb	r1, [r3, r2]
#endif
#ifdef FEATURE_USART_RS485
	config->rs485_guard_time = RS485_GUARD_TIME_0_BIT;
    11f4:	687b      	ldr	r3, [r7, #4]
    11f6:	2225      	movs	r2, #37	; 0x25
    11f8:	2100      	movs	r1, #0
    11fa:	5499      	strb	r1, [r3, r2]
#endif
}
    11fc:	46c0      	nop			; (mov r8, r8)
    11fe:	46bd      	mov	sp, r7
    1200:	b002      	add	sp, #8
    1202:	bd80      	pop	{r7, pc}

00001204 <usart_enable>:
 *
 * \param[in]  module  Pointer to USART software instance struct
 */
static inline void usart_enable(
		const struct usart_module *const module)
{
    1204:	b580      	push	{r7, lr}
    1206:	b084      	sub	sp, #16
    1208:	af00      	add	r7, sp, #0
    120a:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    120c:	687b      	ldr	r3, [r7, #4]
    120e:	681b      	ldr	r3, [r3, #0]
    1210:	60fb      	str	r3, [r7, #12]

#if USART_CALLBACK_MODE == true
	/* Enable Global interrupt for module */
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
    1212:	687b      	ldr	r3, [r7, #4]
    1214:	681b      	ldr	r3, [r3, #0]
    1216:	0018      	movs	r0, r3
    1218:	4b09      	ldr	r3, [pc, #36]	; (1240 <usart_enable+0x3c>)
    121a:	4798      	blx	r3
    121c:	0003      	movs	r3, r0
    121e:	0018      	movs	r0, r3
    1220:	4b08      	ldr	r3, [pc, #32]	; (1244 <usart_enable+0x40>)
    1222:	4798      	blx	r3
#endif

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);
    1224:	687b      	ldr	r3, [r7, #4]
    1226:	0018      	movs	r0, r3
    1228:	4b07      	ldr	r3, [pc, #28]	; (1248 <usart_enable+0x44>)
    122a:	4798      	blx	r3

	/* Enable USART module */
	usart_hw->CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    122c:	68fb      	ldr	r3, [r7, #12]
    122e:	681b      	ldr	r3, [r3, #0]
    1230:	2202      	movs	r2, #2
    1232:	431a      	orrs	r2, r3
    1234:	68fb      	ldr	r3, [r7, #12]
    1236:	601a      	str	r2, [r3, #0]
}
    1238:	46c0      	nop			; (mov r8, r8)
    123a:	46bd      	mov	sp, r7
    123c:	b004      	add	sp, #16
    123e:	bd80      	pop	{r7, pc}
    1240:	00001e95 	.word	0x00001e95
    1244:	000010b9 	.word	0x000010b9
    1248:	00001105 	.word	0x00001105

0000124c <usart_enable_callback>:
 * \param[in]  callback_type  Callback type given by an enum
 */
static inline void usart_enable_callback(
		struct usart_module *const module,
		enum usart_callback callback_type)
{
    124c:	b580      	push	{r7, lr}
    124e:	b082      	sub	sp, #8
    1250:	af00      	add	r7, sp, #0
    1252:	6078      	str	r0, [r7, #4]
    1254:	000a      	movs	r2, r1
    1256:	1cfb      	adds	r3, r7, #3
    1258:	701a      	strb	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(module);

	/* Enable callback */
	module->callback_enable_mask |= (1 << callback_type);
    125a:	687b      	ldr	r3, [r7, #4]
    125c:	2231      	movs	r2, #49	; 0x31
    125e:	5c9b      	ldrb	r3, [r3, r2]
    1260:	b25a      	sxtb	r2, r3
    1262:	1cfb      	adds	r3, r7, #3
    1264:	781b      	ldrb	r3, [r3, #0]
    1266:	2101      	movs	r1, #1
    1268:	4099      	lsls	r1, r3
    126a:	000b      	movs	r3, r1
    126c:	b25b      	sxtb	r3, r3
    126e:	4313      	orrs	r3, r2
    1270:	b25b      	sxtb	r3, r3
    1272:	b2d9      	uxtb	r1, r3
    1274:	687b      	ldr	r3, [r7, #4]
    1276:	2231      	movs	r2, #49	; 0x31
    1278:	5499      	strb	r1, [r3, r2]

}
    127a:	46c0      	nop			; (mov r8, r8)
    127c:	46bd      	mov	sp, r7
    127e:	b002      	add	sp, #8
    1280:	bd80      	pop	{r7, pc}
	...

00001284 <vUARTCommandConsoleStart>:
extern TaskHandle_t txTaskHandle;

/*-----------------------------------------------------------*/

void vUARTCommandConsoleStart( uint16_t usStackSize, unsigned portBASE_TYPE uxPriority )
{
    1284:	b590      	push	{r4, r7, lr}
    1286:	b085      	sub	sp, #20
    1288:	af02      	add	r7, sp, #8
    128a:	0002      	movs	r2, r0
    128c:	6039      	str	r1, [r7, #0]
    128e:	1dbb      	adds	r3, r7, #6
    1290:	801a      	strh	r2, [r3, #0]
#if 0  /* Jimmy */
	vRegisterSampleCLICommands();
#endif

    /* Create that task that handles the console itself. */
    xTaskCreate(prvUARTCommandConsoleTask, /* Task entry point. */
    1292:	1dbb      	adds	r3, r7, #6
    1294:	881a      	ldrh	r2, [r3, #0]
    1296:	4906      	ldr	r1, [pc, #24]	; (12b0 <vUARTCommandConsoleStart+0x2c>)
    1298:	4806      	ldr	r0, [pc, #24]	; (12b4 <vUARTCommandConsoleStart+0x30>)
    129a:	4b07      	ldr	r3, [pc, #28]	; (12b8 <vUARTCommandConsoleStart+0x34>)
    129c:	9301      	str	r3, [sp, #4]
    129e:	683b      	ldr	r3, [r7, #0]
    12a0:	9300      	str	r3, [sp, #0]
    12a2:	2300      	movs	r3, #0
    12a4:	4c05      	ldr	r4, [pc, #20]	; (12bc <vUARTCommandConsoleStart+0x38>)
    12a6:	47a0      	blx	r4
        usStackSize,                       /* Stack size */
        NULL,	                           /* Task parameter, unused. */
        uxPriority,	                   /* Task priority. */
        &ConsoleTaskHandle         /* Added by Jimmy */
    );
}
    12a8:	46c0      	nop			; (mov r8, r8)
    12aa:	46bd      	mov	sp, r7
    12ac:	b003      	add	sp, #12
    12ae:	bd90      	pop	{r4, r7, pc}
    12b0:	000072fc 	.word	0x000072fc
    12b4:	0000146d 	.word	0x0000146d
    12b8:	20003310 	.word	0x20003310
    12bc:	00003f81 	.word	0x00003f81

000012c0 <ulong_to_string>:
static struct usart_module xCDCUsart; /* Static so it doesn't take up too much stack. */

static char outbuf[20];

uint16_t ulong_to_string(uint32_t number, char *ascii)
{
    12c0:	b580      	push	{r7, lr}
    12c2:	b08a      	sub	sp, #40	; 0x28
    12c4:	af00      	add	r7, sp, #0
    12c6:	6078      	str	r0, [r7, #4]
    12c8:	6039      	str	r1, [r7, #0]
    uint32_t remainder = 0;
    12ca:	2300      	movs	r3, #0
    12cc:	61fb      	str	r3, [r7, #28]
    uint8_t i = 0;
    12ce:	2327      	movs	r3, #39	; 0x27
    12d0:	18fb      	adds	r3, r7, r3
    12d2:	2200      	movs	r2, #0
    12d4:	701a      	strb	r2, [r3, #0]
    char *asciiptr = ascii;
    12d6:	683b      	ldr	r3, [r7, #0]
    12d8:	623b      	str	r3, [r7, #32]
    char strptr[12];
    int16_t rval;

    if (number == 0) {
    12da:	687b      	ldr	r3, [r7, #4]
    12dc:	2b00      	cmp	r3, #0
    12de:	d132      	bne.n	1346 <ulong_to_string+0x86>
        *ascii++ = '0';
    12e0:	683b      	ldr	r3, [r7, #0]
    12e2:	1c5a      	adds	r2, r3, #1
    12e4:	603a      	str	r2, [r7, #0]
    12e6:	2230      	movs	r2, #48	; 0x30
    12e8:	701a      	strb	r2, [r3, #0]
        *ascii = '\0';
    12ea:	683b      	ldr	r3, [r7, #0]
    12ec:	2200      	movs	r2, #0
    12ee:	701a      	strb	r2, [r3, #0]
        return (1);    /* string length 1 */
    12f0:	2301      	movs	r3, #1
    12f2:	e04e      	b.n	1392 <ulong_to_string+0xd2>
    }

    while (number != 0) {
        remainder = number & 0x0000000f;                /* mod 16 */
    12f4:	687b      	ldr	r3, [r7, #4]
    12f6:	220f      	movs	r2, #15
    12f8:	4013      	ands	r3, r2
    12fa:	61fb      	str	r3, [r7, #28]
        if ( remainder <= 9 )
    12fc:	69fb      	ldr	r3, [r7, #28]
    12fe:	2b09      	cmp	r3, #9
    1300:	d80f      	bhi.n	1322 <ulong_to_string+0x62>
            strptr[i++] = (char)(remainder + 0x30);	// 0-9
    1302:	2327      	movs	r3, #39	; 0x27
    1304:	18fb      	adds	r3, r7, r3
    1306:	781b      	ldrb	r3, [r3, #0]
    1308:	2227      	movs	r2, #39	; 0x27
    130a:	18ba      	adds	r2, r7, r2
    130c:	1c59      	adds	r1, r3, #1
    130e:	7011      	strb	r1, [r2, #0]
    1310:	001a      	movs	r2, r3
    1312:	69fb      	ldr	r3, [r7, #28]
    1314:	b2db      	uxtb	r3, r3
    1316:	3330      	adds	r3, #48	; 0x30
    1318:	b2d9      	uxtb	r1, r3
    131a:	230c      	movs	r3, #12
    131c:	18fb      	adds	r3, r7, r3
    131e:	5499      	strb	r1, [r3, r2]
    1320:	e00e      	b.n	1340 <ulong_to_string+0x80>
        else
            strptr[i++] = (char)(remainder + 0x57);	// a-f
    1322:	2327      	movs	r3, #39	; 0x27
    1324:	18fb      	adds	r3, r7, r3
    1326:	781b      	ldrb	r3, [r3, #0]
    1328:	2227      	movs	r2, #39	; 0x27
    132a:	18ba      	adds	r2, r7, r2
    132c:	1c59      	adds	r1, r3, #1
    132e:	7011      	strb	r1, [r2, #0]
    1330:	001a      	movs	r2, r3
    1332:	69fb      	ldr	r3, [r7, #28]
    1334:	b2db      	uxtb	r3, r3
    1336:	3357      	adds	r3, #87	; 0x57
    1338:	b2d9      	uxtb	r1, r3
    133a:	230c      	movs	r3, #12
    133c:	18fb      	adds	r3, r7, r3
    133e:	5499      	strb	r1, [r3, r2]
        number >>= 4;                                   /* divide by 16 */
    1340:	687b      	ldr	r3, [r7, #4]
    1342:	091b      	lsrs	r3, r3, #4
    1344:	607b      	str	r3, [r7, #4]
    while (number != 0) {
    1346:	687b      	ldr	r3, [r7, #4]
    1348:	2b00      	cmp	r3, #0
    134a:	d1d3      	bne.n	12f4 <ulong_to_string+0x34>
    }

    rval = i;
    134c:	231a      	movs	r3, #26
    134e:	18fb      	adds	r3, r7, r3
    1350:	2227      	movs	r2, #39	; 0x27
    1352:	18ba      	adds	r2, r7, r2
    1354:	7812      	ldrb	r2, [r2, #0]
    1356:	801a      	strh	r2, [r3, #0]
    while (i > 0) {
    1358:	e010      	b.n	137c <ulong_to_string+0xbc>
        *asciiptr++ = strptr[--i];
    135a:	6a3b      	ldr	r3, [r7, #32]
    135c:	1c5a      	adds	r2, r3, #1
    135e:	623a      	str	r2, [r7, #32]
    1360:	2227      	movs	r2, #39	; 0x27
    1362:	18ba      	adds	r2, r7, r2
    1364:	2127      	movs	r1, #39	; 0x27
    1366:	1879      	adds	r1, r7, r1
    1368:	7809      	ldrb	r1, [r1, #0]
    136a:	3901      	subs	r1, #1
    136c:	7011      	strb	r1, [r2, #0]
    136e:	2227      	movs	r2, #39	; 0x27
    1370:	18ba      	adds	r2, r7, r2
    1372:	7812      	ldrb	r2, [r2, #0]
    1374:	210c      	movs	r1, #12
    1376:	1879      	adds	r1, r7, r1
    1378:	5c8a      	ldrb	r2, [r1, r2]
    137a:	701a      	strb	r2, [r3, #0]
    while (i > 0) {
    137c:	2327      	movs	r3, #39	; 0x27
    137e:	18fb      	adds	r3, r7, r3
    1380:	781b      	ldrb	r3, [r3, #0]
    1382:	2b00      	cmp	r3, #0
    1384:	d1e9      	bne.n	135a <ulong_to_string+0x9a>
    }
    *asciiptr = 0;	// terminate string
    1386:	6a3b      	ldr	r3, [r7, #32]
    1388:	2200      	movs	r2, #0
    138a:	701a      	strb	r2, [r3, #0]
    return (rval);
    138c:	231a      	movs	r3, #26
    138e:	18fb      	adds	r3, r7, r3
    1390:	881b      	ldrh	r3, [r3, #0]
}
    1392:	0018      	movs	r0, r3
    1394:	46bd      	mov	sp, r7
    1396:	b00a      	add	sp, #40	; 0x28
    1398:	bd80      	pop	{r7, pc}
	...

0000139c <debug_msg_init>:

void debug_msg_init(void)
{
    139c:	b580      	push	{r7, lr}
    139e:	af00      	add	r7, sp, #0
    prvConfigureUART(&xCDCUsart);
    13a0:	4b03      	ldr	r3, [pc, #12]	; (13b0 <debug_msg_init+0x14>)
    13a2:	0018      	movs	r0, r3
    13a4:	4b03      	ldr	r3, [pc, #12]	; (13b4 <debug_msg_init+0x18>)
    13a6:	4798      	blx	r3
}
    13a8:	46c0      	nop			; (mov r8, r8)
    13aa:	46bd      	mov	sp, r7
    13ac:	bd80      	pop	{r7, pc}
    13ae:	46c0      	nop			; (mov r8, r8)
    13b0:	200008b8 	.word	0x200008b8
    13b4:	00001671 	.word	0x00001671

000013b8 <debug_msg>:

void debug_msg(const char *string)
{
    13b8:	b580      	push	{r7, lr}
    13ba:	b082      	sub	sp, #8
    13bc:	af00      	add	r7, sp, #0
    13be:	6078      	str	r0, [r7, #4]
    prvSendBuffer(&xCDCUsart, string, strlen(string));
    13c0:	687b      	ldr	r3, [r7, #4]
    13c2:	0018      	movs	r0, r3
    13c4:	4b05      	ldr	r3, [pc, #20]	; (13dc <debug_msg+0x24>)
    13c6:	4798      	blx	r3
    13c8:	0002      	movs	r2, r0
    13ca:	6879      	ldr	r1, [r7, #4]
    13cc:	4b04      	ldr	r3, [pc, #16]	; (13e0 <debug_msg+0x28>)
    13ce:	0018      	movs	r0, r3
    13d0:	4b04      	ldr	r3, [pc, #16]	; (13e4 <debug_msg+0x2c>)
    13d2:	4798      	blx	r3
}
    13d4:	46c0      	nop			; (mov r8, r8)
    13d6:	46bd      	mov	sp, r7
    13d8:	b002      	add	sp, #8
    13da:	bd80      	pop	{r7, pc}
    13dc:	00006c6b 	.word	0x00006c6b
    13e0:	200008b8 	.word	0x200008b8
    13e4:	00001629 	.word	0x00001629

000013e8 <printhex>:
 * the number will have a leading '0x'.
 * If crlf is true, a carriage return line feed is appended.
 * outbuf must be at least 13 chars long.
 */
void printhex(uint32_t val, int crlf)
{
    13e8:	b580      	push	{r7, lr}
    13ea:	b084      	sub	sp, #16
    13ec:	af00      	add	r7, sp, #0
    13ee:	6078      	str	r0, [r7, #4]
    13f0:	6039      	str	r1, [r7, #0]
    int len;
    int i = 0;
    13f2:	2300      	movs	r3, #0
    13f4:	60bb      	str	r3, [r7, #8]
    if (val > 9) {
    13f6:	687b      	ldr	r3, [r7, #4]
    13f8:	2b09      	cmp	r3, #9
    13fa:	d908      	bls.n	140e <printhex+0x26>
       i += 2;
    13fc:	68bb      	ldr	r3, [r7, #8]
    13fe:	3302      	adds	r3, #2
    1400:	60bb      	str	r3, [r7, #8]
       outbuf[0] = '0';
    1402:	4b16      	ldr	r3, [pc, #88]	; (145c <printhex+0x74>)
    1404:	2230      	movs	r2, #48	; 0x30
    1406:	701a      	strb	r2, [r3, #0]
       outbuf[1] = 'x';
    1408:	4b14      	ldr	r3, [pc, #80]	; (145c <printhex+0x74>)
    140a:	2278      	movs	r2, #120	; 0x78
    140c:	705a      	strb	r2, [r3, #1]
    }
    len = ulong_to_string(val, &outbuf[i]);
    140e:	68ba      	ldr	r2, [r7, #8]
    1410:	4b12      	ldr	r3, [pc, #72]	; (145c <printhex+0x74>)
    1412:	18d2      	adds	r2, r2, r3
    1414:	687b      	ldr	r3, [r7, #4]
    1416:	0011      	movs	r1, r2
    1418:	0018      	movs	r0, r3
    141a:	4b11      	ldr	r3, [pc, #68]	; (1460 <printhex+0x78>)
    141c:	4798      	blx	r3
    141e:	0003      	movs	r3, r0
    1420:	60fb      	str	r3, [r7, #12]
    len += i;
    1422:	68fa      	ldr	r2, [r7, #12]
    1424:	68bb      	ldr	r3, [r7, #8]
    1426:	18d3      	adds	r3, r2, r3
    1428:	60fb      	str	r3, [r7, #12]
    if (crlf) {
    142a:	683b      	ldr	r3, [r7, #0]
    142c:	2b00      	cmp	r3, #0
    142e:	d00b      	beq.n	1448 <printhex+0x60>
        outbuf[len++] = '\r';
    1430:	68fb      	ldr	r3, [r7, #12]
    1432:	1c5a      	adds	r2, r3, #1
    1434:	60fa      	str	r2, [r7, #12]
    1436:	4a09      	ldr	r2, [pc, #36]	; (145c <printhex+0x74>)
    1438:	210d      	movs	r1, #13
    143a:	54d1      	strb	r1, [r2, r3]
        outbuf[len++] = '\n';
    143c:	68fb      	ldr	r3, [r7, #12]
    143e:	1c5a      	adds	r2, r3, #1
    1440:	60fa      	str	r2, [r7, #12]
    1442:	4a06      	ldr	r2, [pc, #24]	; (145c <printhex+0x74>)
    1444:	210a      	movs	r1, #10
    1446:	54d1      	strb	r1, [r2, r3]
    }
    prvSendBuffer(&xCDCUsart, outbuf, len);
    1448:	68fa      	ldr	r2, [r7, #12]
    144a:	4904      	ldr	r1, [pc, #16]	; (145c <printhex+0x74>)
    144c:	4b05      	ldr	r3, [pc, #20]	; (1464 <printhex+0x7c>)
    144e:	0018      	movs	r0, r3
    1450:	4b05      	ldr	r3, [pc, #20]	; (1468 <printhex+0x80>)
    1452:	4798      	blx	r3
}
    1454:	46c0      	nop			; (mov r8, r8)
    1456:	46bd      	mov	sp, r7
    1458:	b004      	add	sp, #16
    145a:	bd80      	pop	{r7, pc}
    145c:	200008ec 	.word	0x200008ec
    1460:	000012c1 	.word	0x000012c1
    1464:	200008b8 	.word	0x200008b8
    1468:	00001629 	.word	0x00001629

0000146c <prvUARTCommandConsoleTask>:

static void prvUARTCommandConsoleTask( void *pvParameters )
{
    146c:	b590      	push	{r4, r7, lr}
    146e:	b087      	sub	sp, #28
    1470:	af00      	add	r7, sp, #0
    1472:	6078      	str	r0, [r7, #4]
    char cRxedChar, *pcOutputString;
    uint8_t ucInputIndex = 0;
    1474:	2317      	movs	r3, #23
    1476:	18fb      	adds	r3, r7, r3
    1478:	2200      	movs	r2, #0
    147a:	701a      	strb	r2, [r3, #0]
    static char cInputString[cmdMAX_INPUT_SIZE], cLastInputString[cmdMAX_INPUT_SIZE];
    portBASE_TYPE xReturned;
    int rval = 1;
    147c:	2301      	movs	r3, #1
    147e:	613b      	str	r3, [r7, #16]
#endif

    ( void ) pvParameters;

/* Jimmy, superhack */
txTaskHandle = ConsoleTaskHandle;
    1480:	4b59      	ldr	r3, [pc, #356]	; (15e8 <prvUARTCommandConsoleTask+0x17c>)
    1482:	681a      	ldr	r2, [r3, #0]
    1484:	4b59      	ldr	r3, [pc, #356]	; (15ec <prvUARTCommandConsoleTask+0x180>)
    1486:	601a      	str	r2, [r3, #0]
#if 0
    pcOutputString = FreeRTOS_CLIGetOutputBuffer();
#endif

    /* Send the welcome message. */
    prvSendBuffer(&xCDCUsart, pcWelcomeMessage, strlen(pcWelcomeMessage));
    1488:	4c59      	ldr	r4, [pc, #356]	; (15f0 <prvUARTCommandConsoleTask+0x184>)
    148a:	4b59      	ldr	r3, [pc, #356]	; (15f0 <prvUARTCommandConsoleTask+0x184>)
    148c:	0018      	movs	r0, r3
    148e:	4b59      	ldr	r3, [pc, #356]	; (15f4 <prvUARTCommandConsoleTask+0x188>)
    1490:	4798      	blx	r3
    1492:	0002      	movs	r2, r0
    1494:	4b58      	ldr	r3, [pc, #352]	; (15f8 <prvUARTCommandConsoleTask+0x18c>)
    1496:	0021      	movs	r1, r4
    1498:	0018      	movs	r0, r3
    149a:	4b58      	ldr	r3, [pc, #352]	; (15fc <prvUARTCommandConsoleTask+0x190>)
    149c:	4798      	blx	r3

    for ( ;; ) {
        /* Wait for the next character to arrive.  A semaphore is used to
        ensure no CPU time is used until data has arrived. */

        usart_read_buffer_job(&xCDCUsart, (uint8_t *) &cRxedChar, 
    149e:	230f      	movs	r3, #15
    14a0:	18f9      	adds	r1, r7, r3
    14a2:	4b55      	ldr	r3, [pc, #340]	; (15f8 <prvUARTCommandConsoleTask+0x18c>)
    14a4:	2201      	movs	r2, #1
    14a6:	0018      	movs	r0, r3
    14a8:	4b55      	ldr	r3, [pc, #340]	; (1600 <prvUARTCommandConsoleTask+0x194>)
    14aa:	4798      	blx	r3
            sizeof(cRxedChar));

        if (xSemaphoreTake(xRxCompleteSemaphore, portMAX_DELAY) == pdPASS) {
    14ac:	4b55      	ldr	r3, [pc, #340]	; (1604 <prvUARTCommandConsoleTask+0x198>)
    14ae:	681a      	ldr	r2, [r3, #0]
    14b0:	2301      	movs	r3, #1
    14b2:	425b      	negs	r3, r3
    14b4:	0019      	movs	r1, r3
    14b6:	0010      	movs	r0, r2
    14b8:	4b53      	ldr	r3, [pc, #332]	; (1608 <prvUARTCommandConsoleTask+0x19c>)
    14ba:	4798      	blx	r3
    14bc:	0003      	movs	r3, r0
    14be:	2b01      	cmp	r3, #1
    14c0:	d1ed      	bne.n	149e <prvUARTCommandConsoleTask+0x32>
            /* Echo the character back. */

            prvSendBuffer( &xCDCUsart, &cRxedChar, sizeof( cRxedChar ) );
    14c2:	230f      	movs	r3, #15
    14c4:	18f9      	adds	r1, r7, r3
    14c6:	4b4c      	ldr	r3, [pc, #304]	; (15f8 <prvUARTCommandConsoleTask+0x18c>)
    14c8:	2201      	movs	r2, #1
    14ca:	0018      	movs	r0, r3
    14cc:	4b4b      	ldr	r3, [pc, #300]	; (15fc <prvUARTCommandConsoleTask+0x190>)
    14ce:	4798      	blx	r3

            /* Was it the end of the line? */
            if (cRxedChar == '\n' || cRxedChar == '\r') {
    14d0:	230f      	movs	r3, #15
    14d2:	18fb      	adds	r3, r7, r3
    14d4:	781b      	ldrb	r3, [r3, #0]
    14d6:	2b0a      	cmp	r3, #10
    14d8:	d004      	beq.n	14e4 <prvUARTCommandConsoleTask+0x78>
    14da:	230f      	movs	r3, #15
    14dc:	18fb      	adds	r3, r7, r3
    14de:	781b      	ldrb	r3, [r3, #0]
    14e0:	2b0d      	cmp	r3, #13
    14e2:	d13d      	bne.n	1560 <prvUARTCommandConsoleTask+0xf4>
                /* Just to space the output from the input. */
                prvSendBuffer(&xCDCUsart, pcNewLine, strlen(pcNewLine));
    14e4:	4c49      	ldr	r4, [pc, #292]	; (160c <prvUARTCommandConsoleTask+0x1a0>)
    14e6:	4b49      	ldr	r3, [pc, #292]	; (160c <prvUARTCommandConsoleTask+0x1a0>)
    14e8:	0018      	movs	r0, r3
    14ea:	4b42      	ldr	r3, [pc, #264]	; (15f4 <prvUARTCommandConsoleTask+0x188>)
    14ec:	4798      	blx	r3
    14ee:	0002      	movs	r2, r0
    14f0:	4b41      	ldr	r3, [pc, #260]	; (15f8 <prvUARTCommandConsoleTask+0x18c>)
    14f2:	0021      	movs	r1, r4
    14f4:	0018      	movs	r0, r3
    14f6:	4b41      	ldr	r3, [pc, #260]	; (15fc <prvUARTCommandConsoleTask+0x190>)
    14f8:	4798      	blx	r3

                /* See if the command is empty, indicating that the last 
                    command is to be executed again. */

                if (ucInputIndex == 0) {
    14fa:	2317      	movs	r3, #23
    14fc:	18fb      	adds	r3, r7, r3
    14fe:	781b      	ldrb	r3, [r3, #0]
    1500:	2b00      	cmp	r3, #0
    1502:	d108      	bne.n	1516 <prvUARTCommandConsoleTask+0xaa>
                   /* Copy the last command back into the input string. */
                   if (rval == 0)
    1504:	693b      	ldr	r3, [r7, #16]
    1506:	2b00      	cmp	r3, #0
    1508:	d105      	bne.n	1516 <prvUARTCommandConsoleTask+0xaa>
                       strcpy(cInputString, cLastInputString);
    150a:	4a41      	ldr	r2, [pc, #260]	; (1610 <prvUARTCommandConsoleTask+0x1a4>)
    150c:	4b41      	ldr	r3, [pc, #260]	; (1614 <prvUARTCommandConsoleTask+0x1a8>)
    150e:	0011      	movs	r1, r2
    1510:	0018      	movs	r0, r3
    1512:	4b41      	ldr	r3, [pc, #260]	; (1618 <prvUARTCommandConsoleTask+0x1ac>)
    1514:	4798      	blx	r3

                } while(xReturned != pdFALSE);
#else
                /* Jimmy's dispatcher */

                rval = dispatch_cmd(cInputString);
    1516:	4b3f      	ldr	r3, [pc, #252]	; (1614 <prvUARTCommandConsoleTask+0x1a8>)
    1518:	0018      	movs	r0, r3
    151a:	4b40      	ldr	r3, [pc, #256]	; (161c <prvUARTCommandConsoleTask+0x1b0>)
    151c:	4798      	blx	r3
    151e:	0003      	movs	r3, r0
    1520:	613b      	str	r3, [r7, #16]
                /* All the strings generated by the input command have been sent.
                    Clear the input string ready to receive the next command.  Remember
                    the command that was just processed first in case it is to be
                    processed again. */

                if (rval == 0)
    1522:	693b      	ldr	r3, [r7, #16]
    1524:	2b00      	cmp	r3, #0
    1526:	d105      	bne.n	1534 <prvUARTCommandConsoleTask+0xc8>
                    strcpy(cLastInputString, cInputString);
    1528:	4a3a      	ldr	r2, [pc, #232]	; (1614 <prvUARTCommandConsoleTask+0x1a8>)
    152a:	4b39      	ldr	r3, [pc, #228]	; (1610 <prvUARTCommandConsoleTask+0x1a4>)
    152c:	0011      	movs	r1, r2
    152e:	0018      	movs	r0, r3
    1530:	4b39      	ldr	r3, [pc, #228]	; (1618 <prvUARTCommandConsoleTask+0x1ac>)
    1532:	4798      	blx	r3
                ucInputIndex = 0;
    1534:	2317      	movs	r3, #23
    1536:	18fb      	adds	r3, r7, r3
    1538:	2200      	movs	r2, #0
    153a:	701a      	strb	r2, [r3, #0]
                memset(cInputString, 0x00, cmdMAX_INPUT_SIZE);
    153c:	4b35      	ldr	r3, [pc, #212]	; (1614 <prvUARTCommandConsoleTask+0x1a8>)
    153e:	2232      	movs	r2, #50	; 0x32
    1540:	2100      	movs	r1, #0
    1542:	0018      	movs	r0, r3
    1544:	4b36      	ldr	r3, [pc, #216]	; (1620 <prvUARTCommandConsoleTask+0x1b4>)
    1546:	4798      	blx	r3

                prvSendBuffer(&xCDCUsart, pcEndOfOutputMessage, 
    1548:	4c36      	ldr	r4, [pc, #216]	; (1624 <prvUARTCommandConsoleTask+0x1b8>)
    154a:	4b36      	ldr	r3, [pc, #216]	; (1624 <prvUARTCommandConsoleTask+0x1b8>)
    154c:	0018      	movs	r0, r3
    154e:	4b29      	ldr	r3, [pc, #164]	; (15f4 <prvUARTCommandConsoleTask+0x188>)
    1550:	4798      	blx	r3
    1552:	0002      	movs	r2, r0
    1554:	4b28      	ldr	r3, [pc, #160]	; (15f8 <prvUARTCommandConsoleTask+0x18c>)
    1556:	0021      	movs	r1, r4
    1558:	0018      	movs	r0, r3
    155a:	4b28      	ldr	r3, [pc, #160]	; (15fc <prvUARTCommandConsoleTask+0x190>)
    155c:	4798      	blx	r3
    155e:	e042      	b.n	15e6 <prvUARTCommandConsoleTask+0x17a>
                    strlen(pcEndOfOutputMessage));
             }
             else {
                 if (cRxedChar == '\r') {
    1560:	230f      	movs	r3, #15
    1562:	18fb      	adds	r3, r7, r3
    1564:	781b      	ldrb	r3, [r3, #0]
    1566:	2b0d      	cmp	r3, #13
    1568:	d099      	beq.n	149e <prvUARTCommandConsoleTask+0x32>
                     /* Ignore the character. */
                 }
                 else if ((cRxedChar == '\b') || 
    156a:	230f      	movs	r3, #15
    156c:	18fb      	adds	r3, r7, r3
    156e:	781b      	ldrb	r3, [r3, #0]
    1570:	2b08      	cmp	r3, #8
    1572:	d004      	beq.n	157e <prvUARTCommandConsoleTask+0x112>
                     (cRxedChar == cmdASCII_DEL)) {
    1574:	230f      	movs	r3, #15
    1576:	18fb      	adds	r3, r7, r3
    1578:	781b      	ldrb	r3, [r3, #0]
                 else if ((cRxedChar == '\b') || 
    157a:	2b7f      	cmp	r3, #127	; 0x7f
    157c:	d112      	bne.n	15a4 <prvUARTCommandConsoleTask+0x138>
                     /* Backspace was pressed.  Erase the last character in the
                         string - if any. */

                     if (ucInputIndex > 0) {
    157e:	2317      	movs	r3, #23
    1580:	18fb      	adds	r3, r7, r3
    1582:	781b      	ldrb	r3, [r3, #0]
    1584:	2b00      	cmp	r3, #0
    1586:	d02e      	beq.n	15e6 <prvUARTCommandConsoleTask+0x17a>
                         ucInputIndex--;
    1588:	2317      	movs	r3, #23
    158a:	18fb      	adds	r3, r7, r3
    158c:	781a      	ldrb	r2, [r3, #0]
    158e:	2317      	movs	r3, #23
    1590:	18fb      	adds	r3, r7, r3
    1592:	3a01      	subs	r2, #1
    1594:	701a      	strb	r2, [r3, #0]
                         cInputString[ucInputIndex] = '\0';
    1596:	2317      	movs	r3, #23
    1598:	18fb      	adds	r3, r7, r3
    159a:	781b      	ldrb	r3, [r3, #0]
    159c:	4a1d      	ldr	r2, [pc, #116]	; (1614 <prvUARTCommandConsoleTask+0x1a8>)
    159e:	2100      	movs	r1, #0
    15a0:	54d1      	strb	r1, [r2, r3]
                     if (ucInputIndex > 0) {
    15a2:	e020      	b.n	15e6 <prvUARTCommandConsoleTask+0x17a>
                 else {
                     /* A character was entered.  Add it to the string
                         entered so far.  When a \n is entered the complete
                         string will be passed to the command interpreter. */

                     if ((cRxedChar >= ' ') && (cRxedChar <= '~')) {
    15a4:	230f      	movs	r3, #15
    15a6:	18fb      	adds	r3, r7, r3
    15a8:	781b      	ldrb	r3, [r3, #0]
    15aa:	2b1f      	cmp	r3, #31
    15ac:	d800      	bhi.n	15b0 <prvUARTCommandConsoleTask+0x144>
    15ae:	e776      	b.n	149e <prvUARTCommandConsoleTask+0x32>
    15b0:	230f      	movs	r3, #15
    15b2:	18fb      	adds	r3, r7, r3
    15b4:	781b      	ldrb	r3, [r3, #0]
    15b6:	2b7e      	cmp	r3, #126	; 0x7e
    15b8:	d900      	bls.n	15bc <prvUARTCommandConsoleTask+0x150>
    15ba:	e770      	b.n	149e <prvUARTCommandConsoleTask+0x32>
                         if (ucInputIndex < cmdMAX_INPUT_SIZE) {
    15bc:	2317      	movs	r3, #23
    15be:	18fb      	adds	r3, r7, r3
    15c0:	781b      	ldrb	r3, [r3, #0]
    15c2:	2b31      	cmp	r3, #49	; 0x31
    15c4:	d900      	bls.n	15c8 <prvUARTCommandConsoleTask+0x15c>
    15c6:	e76a      	b.n	149e <prvUARTCommandConsoleTask+0x32>
                             cInputString[ucInputIndex] = cRxedChar;
    15c8:	2317      	movs	r3, #23
    15ca:	18fb      	adds	r3, r7, r3
    15cc:	781b      	ldrb	r3, [r3, #0]
    15ce:	220f      	movs	r2, #15
    15d0:	18ba      	adds	r2, r7, r2
    15d2:	7811      	ldrb	r1, [r2, #0]
    15d4:	4a0f      	ldr	r2, [pc, #60]	; (1614 <prvUARTCommandConsoleTask+0x1a8>)
    15d6:	54d1      	strb	r1, [r2, r3]
                             ucInputIndex++;
    15d8:	2317      	movs	r3, #23
    15da:	18fb      	adds	r3, r7, r3
    15dc:	781a      	ldrb	r2, [r3, #0]
    15de:	2317      	movs	r3, #23
    15e0:	18fb      	adds	r3, r7, r3
    15e2:	3201      	adds	r2, #1
    15e4:	701a      	strb	r2, [r3, #0]
        usart_read_buffer_job(&xCDCUsart, (uint8_t *) &cRxedChar, 
    15e6:	e75a      	b.n	149e <prvUARTCommandConsoleTask+0x32>
    15e8:	20003310 	.word	0x20003310
    15ec:	2000336c 	.word	0x2000336c
    15f0:	000072a0 	.word	0x000072a0
    15f4:	00006c6b 	.word	0x00006c6b
    15f8:	200008b8 	.word	0x200008b8
    15fc:	00001629 	.word	0x00001629
    1600:	00002809 	.word	0x00002809
    1604:	200008b4 	.word	0x200008b4
    1608:	00003969 	.word	0x00003969
    160c:	000072f8 	.word	0x000072f8
    1610:	20000934 	.word	0x20000934
    1614:	20000900 	.word	0x20000900
    1618:	00006c5b 	.word	0x00006c5b
    161c:	00005ed5 	.word	0x00005ed5
    1620:	00006c37 	.word	0x00006c37
    1624:	000072f4 	.word	0x000072f4

00001628 <prvSendBuffer>:
    }
}
/*-----------------------------------------------------------*/

static void prvSendBuffer( struct usart_module *pxCDCUsart, const char * pcBuffer, size_t xBufferLength )
{
    1628:	b580      	push	{r7, lr}
    162a:	b086      	sub	sp, #24
    162c:	af00      	add	r7, sp, #0
    162e:	60f8      	str	r0, [r7, #12]
    1630:	60b9      	str	r1, [r7, #8]
    1632:	607a      	str	r2, [r7, #4]
    const TickType_t xBlockMax100ms = 100UL / portTICK_PERIOD_MS;
    1634:	230a      	movs	r3, #10
    1636:	617b      	str	r3, [r7, #20]

    if (xBufferLength > 0) {
    1638:	687b      	ldr	r3, [r7, #4]
    163a:	2b00      	cmp	r3, #0
    163c:	d00d      	beq.n	165a <prvSendBuffer+0x32>
        usart_write_buffer_job( pxCDCUsart, ( uint8_t * ) pcBuffer, xBufferLength );
    163e:	687b      	ldr	r3, [r7, #4]
    1640:	b29a      	uxth	r2, r3
    1642:	68b9      	ldr	r1, [r7, #8]
    1644:	68fb      	ldr	r3, [r7, #12]
    1646:	0018      	movs	r0, r3
    1648:	4b06      	ldr	r3, [pc, #24]	; (1664 <prvSendBuffer+0x3c>)
    164a:	4798      	blx	r3

        /* Wait for the Tx to complete so the buffer can be reused without
            corrupting the data that is being sent. */

        xSemaphoreTake( xTxCompleteSemaphore, xBlockMax100ms );
    164c:	4b06      	ldr	r3, [pc, #24]	; (1668 <prvSendBuffer+0x40>)
    164e:	681b      	ldr	r3, [r3, #0]
    1650:	697a      	ldr	r2, [r7, #20]
    1652:	0011      	movs	r1, r2
    1654:	0018      	movs	r0, r3
    1656:	4b05      	ldr	r3, [pc, #20]	; (166c <prvSendBuffer+0x44>)
    1658:	4798      	blx	r3
    }
}
    165a:	46c0      	nop			; (mov r8, r8)
    165c:	46bd      	mov	sp, r7
    165e:	b006      	add	sp, #24
    1660:	bd80      	pop	{r7, pc}
    1662:	46c0      	nop			; (mov r8, r8)
    1664:	000027c1 	.word	0x000027c1
    1668:	200008b0 	.word	0x200008b0
    166c:	00003969 	.word	0x00003969

00001670 <prvConfigureUART>:
/*-----------------------------------------------------------*/

static void prvConfigureUART( struct usart_module *pxCDCUsart )
{
    1670:	b590      	push	{r4, r7, lr}
    1672:	b095      	sub	sp, #84	; 0x54
    1674:	af00      	add	r7, sp, #0
    1676:	6078      	str	r0, [r7, #4]
struct usart_config xUARTConfig;

	/* This semaphore is used to allow the task to wait for the Tx to complete
	without wasting any CPU time. */
	vSemaphoreCreateBinary( xTxCompleteSemaphore );
    1678:	2203      	movs	r2, #3
    167a:	2100      	movs	r1, #0
    167c:	2001      	movs	r0, #1
    167e:	4b42      	ldr	r3, [pc, #264]	; (1788 <prvConfigureUART+0x118>)
    1680:	4798      	blx	r3
    1682:	0002      	movs	r2, r0
    1684:	4b41      	ldr	r3, [pc, #260]	; (178c <prvConfigureUART+0x11c>)
    1686:	601a      	str	r2, [r3, #0]
    1688:	4b40      	ldr	r3, [pc, #256]	; (178c <prvConfigureUART+0x11c>)
    168a:	681b      	ldr	r3, [r3, #0]
    168c:	2b00      	cmp	r3, #0
    168e:	d006      	beq.n	169e <prvConfigureUART+0x2e>
    1690:	4b3e      	ldr	r3, [pc, #248]	; (178c <prvConfigureUART+0x11c>)
    1692:	6818      	ldr	r0, [r3, #0]
    1694:	2300      	movs	r3, #0
    1696:	2200      	movs	r2, #0
    1698:	2100      	movs	r1, #0
    169a:	4c3d      	ldr	r4, [pc, #244]	; (1790 <prvConfigureUART+0x120>)
    169c:	47a0      	blx	r4
	configASSERT( xTxCompleteSemaphore );
    169e:	4b3b      	ldr	r3, [pc, #236]	; (178c <prvConfigureUART+0x11c>)
    16a0:	681b      	ldr	r3, [r3, #0]
    16a2:	2b00      	cmp	r3, #0
    16a4:	d101      	bne.n	16aa <prvConfigureUART+0x3a>
    16a6:	b672      	cpsid	i
    16a8:	e7fe      	b.n	16a8 <prvConfigureUART+0x38>

	/* This semaphore is used to allow the task to block for an Rx to complete
	without wasting any CPU time. */
	vSemaphoreCreateBinary( xRxCompleteSemaphore );
    16aa:	2203      	movs	r2, #3
    16ac:	2100      	movs	r1, #0
    16ae:	2001      	movs	r0, #1
    16b0:	4b35      	ldr	r3, [pc, #212]	; (1788 <prvConfigureUART+0x118>)
    16b2:	4798      	blx	r3
    16b4:	0002      	movs	r2, r0
    16b6:	4b37      	ldr	r3, [pc, #220]	; (1794 <prvConfigureUART+0x124>)
    16b8:	601a      	str	r2, [r3, #0]
    16ba:	4b36      	ldr	r3, [pc, #216]	; (1794 <prvConfigureUART+0x124>)
    16bc:	681b      	ldr	r3, [r3, #0]
    16be:	2b00      	cmp	r3, #0
    16c0:	d006      	beq.n	16d0 <prvConfigureUART+0x60>
    16c2:	4b34      	ldr	r3, [pc, #208]	; (1794 <prvConfigureUART+0x124>)
    16c4:	6818      	ldr	r0, [r3, #0]
    16c6:	2300      	movs	r3, #0
    16c8:	2200      	movs	r2, #0
    16ca:	2100      	movs	r1, #0
    16cc:	4c30      	ldr	r4, [pc, #192]	; (1790 <prvConfigureUART+0x120>)
    16ce:	47a0      	blx	r4
	configASSERT( xRxCompleteSemaphore );
    16d0:	4b30      	ldr	r3, [pc, #192]	; (1794 <prvConfigureUART+0x124>)
    16d2:	681b      	ldr	r3, [r3, #0]
    16d4:	2b00      	cmp	r3, #0
    16d6:	d101      	bne.n	16dc <prvConfigureUART+0x6c>
    16d8:	b672      	cpsid	i
    16da:	e7fe      	b.n	16da <prvConfigureUART+0x6a>

	/* Take the semaphores so they start in the wanted state.  A block time is
	not necessary, and is therefore set to 0, as it is known that the semaphores
	exists - they have just been created. */
	xSemaphoreTake( xTxCompleteSemaphore, 0 );
    16dc:	4b2b      	ldr	r3, [pc, #172]	; (178c <prvConfigureUART+0x11c>)
    16de:	681b      	ldr	r3, [r3, #0]
    16e0:	2100      	movs	r1, #0
    16e2:	0018      	movs	r0, r3
    16e4:	4b2c      	ldr	r3, [pc, #176]	; (1798 <prvConfigureUART+0x128>)
    16e6:	4798      	blx	r3
	xSemaphoreTake( xRxCompleteSemaphore, 0 );
    16e8:	4b2a      	ldr	r3, [pc, #168]	; (1794 <prvConfigureUART+0x124>)
    16ea:	681b      	ldr	r3, [r3, #0]
    16ec:	2100      	movs	r1, #0
    16ee:	0018      	movs	r0, r3
    16f0:	4b29      	ldr	r3, [pc, #164]	; (1798 <prvConfigureUART+0x128>)
    16f2:	4798      	blx	r3

	/* Configure the hardware. */
	usart_get_config_defaults( &xUARTConfig );
    16f4:	2308      	movs	r3, #8
    16f6:	18fb      	adds	r3, r7, r3
    16f8:	0018      	movs	r0, r3
    16fa:	4b28      	ldr	r3, [pc, #160]	; (179c <prvConfigureUART+0x12c>)
    16fc:	4798      	blx	r3
	xUARTConfig.baudrate    = 115200;
    16fe:	2308      	movs	r3, #8
    1700:	18fb      	adds	r3, r7, r3
    1702:	22e1      	movs	r2, #225	; 0xe1
    1704:	0252      	lsls	r2, r2, #9
    1706:	629a      	str	r2, [r3, #40]	; 0x28
	xUARTConfig.mux_setting = EDBG_CDC_SERCOM_MUX_SETTING;
    1708:	2308      	movs	r3, #8
    170a:	18fb      	adds	r3, r7, r3
    170c:	22c4      	movs	r2, #196	; 0xc4
    170e:	0392      	lsls	r2, r2, #14
    1710:	60da      	str	r2, [r3, #12]
	xUARTConfig.pinmux_pad0 = EDBG_CDC_SERCOM_PINMUX_PAD0;
    1712:	2308      	movs	r3, #8
    1714:	18fb      	adds	r3, r7, r3
    1716:	2201      	movs	r2, #1
    1718:	4252      	negs	r2, r2
    171a:	639a      	str	r2, [r3, #56]	; 0x38
	xUARTConfig.pinmux_pad1 = EDBG_CDC_SERCOM_PINMUX_PAD1;
    171c:	2308      	movs	r3, #8
    171e:	18fb      	adds	r3, r7, r3
    1720:	2201      	movs	r2, #1
    1722:	4252      	negs	r2, r2
    1724:	63da      	str	r2, [r3, #60]	; 0x3c
	xUARTConfig.pinmux_pad2 = EDBG_CDC_SERCOM_PINMUX_PAD2;
    1726:	2308      	movs	r3, #8
    1728:	18fb      	adds	r3, r7, r3
    172a:	4a1d      	ldr	r2, [pc, #116]	; (17a0 <prvConfigureUART+0x130>)
    172c:	641a      	str	r2, [r3, #64]	; 0x40
	xUARTConfig.pinmux_pad3 = EDBG_CDC_SERCOM_PINMUX_PAD3;
    172e:	2308      	movs	r3, #8
    1730:	18fb      	adds	r3, r7, r3
    1732:	4a1c      	ldr	r2, [pc, #112]	; (17a4 <prvConfigureUART+0x134>)
    1734:	645a      	str	r2, [r3, #68]	; 0x44
	while(usart_init(pxCDCUsart, EDBG_CDC_MODULE, &xUARTConfig) != STATUS_OK) {
    1736:	46c0      	nop			; (mov r8, r8)
    1738:	2308      	movs	r3, #8
    173a:	18fa      	adds	r2, r7, r3
    173c:	491a      	ldr	r1, [pc, #104]	; (17a8 <prvConfigureUART+0x138>)
    173e:	687b      	ldr	r3, [r7, #4]
    1740:	0018      	movs	r0, r3
    1742:	4b1a      	ldr	r3, [pc, #104]	; (17ac <prvConfigureUART+0x13c>)
    1744:	4798      	blx	r3
    1746:	1e03      	subs	r3, r0, #0
    1748:	d1f6      	bne.n	1738 <prvConfigureUART+0xc8>
            /* Nothing to do here.  Should include a timeout really but this is
	    init code only. */
	}
	usart_enable( pxCDCUsart );
    174a:	687b      	ldr	r3, [r7, #4]
    174c:	0018      	movs	r0, r3
    174e:	4b18      	ldr	r3, [pc, #96]	; (17b0 <prvConfigureUART+0x140>)
    1750:	4798      	blx	r3

	/* Register the driver callbacks. */

	usart_register_callback( pxCDCUsart, prvUARTTxNotificationHandler, USART_CALLBACK_BUFFER_TRANSMITTED );
    1752:	4918      	ldr	r1, [pc, #96]	; (17b4 <prvConfigureUART+0x144>)
    1754:	687b      	ldr	r3, [r7, #4]
    1756:	2200      	movs	r2, #0
    1758:	0018      	movs	r0, r3
    175a:	4b17      	ldr	r3, [pc, #92]	; (17b8 <prvConfigureUART+0x148>)
    175c:	4798      	blx	r3
	usart_register_callback( pxCDCUsart, prvUARTRxNotificationHandler, USART_CALLBACK_BUFFER_RECEIVED );
    175e:	4917      	ldr	r1, [pc, #92]	; (17bc <prvConfigureUART+0x14c>)
    1760:	687b      	ldr	r3, [r7, #4]
    1762:	2201      	movs	r2, #1
    1764:	0018      	movs	r0, r3
    1766:	4b14      	ldr	r3, [pc, #80]	; (17b8 <prvConfigureUART+0x148>)
    1768:	4798      	blx	r3
	usart_enable_callback( pxCDCUsart, USART_CALLBACK_BUFFER_TRANSMITTED );
    176a:	687b      	ldr	r3, [r7, #4]
    176c:	2100      	movs	r1, #0
    176e:	0018      	movs	r0, r3
    1770:	4b13      	ldr	r3, [pc, #76]	; (17c0 <prvConfigureUART+0x150>)
    1772:	4798      	blx	r3
	usart_enable_callback( pxCDCUsart, USART_CALLBACK_BUFFER_RECEIVED );
    1774:	687b      	ldr	r3, [r7, #4]
    1776:	2101      	movs	r1, #1
    1778:	0018      	movs	r0, r3
    177a:	4b11      	ldr	r3, [pc, #68]	; (17c0 <prvConfigureUART+0x150>)
    177c:	4798      	blx	r3
}
    177e:	46c0      	nop			; (mov r8, r8)
    1780:	46bd      	mov	sp, r7
    1782:	b015      	add	sp, #84	; 0x54
    1784:	bd90      	pop	{r4, r7, pc}
    1786:	46c0      	nop			; (mov r8, r8)
    1788:	00003305 	.word	0x00003305
    178c:	200008b0 	.word	0x200008b0
    1790:	000033c9 	.word	0x000033c9
    1794:	200008b4 	.word	0x200008b4
    1798:	00003969 	.word	0x00003969
    179c:	00001129 	.word	0x00001129
    17a0:	002a0003 	.word	0x002a0003
    17a4:	002b0003 	.word	0x002b0003
    17a8:	42001400 	.word	0x42001400
    17ac:	000023b9 	.word	0x000023b9
    17b0:	00001205 	.word	0x00001205
    17b4:	00001805 	.word	0x00001805
    17b8:	00002779 	.word	0x00002779
    17bc:	000017c5 	.word	0x000017c5
    17c0:	0000124d 	.word	0x0000124d

000017c4 <prvUARTRxNotificationHandler>:
/*-----------------------------------------------------------*/

static void prvUARTRxNotificationHandler( const struct usart_module *const pxUSART )
{
    17c4:	b580      	push	{r7, lr}
    17c6:	b084      	sub	sp, #16
    17c8:	af00      	add	r7, sp, #0
    17ca:	6078      	str	r0, [r7, #4]
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
    17cc:	2300      	movs	r3, #0
    17ce:	60fb      	str	r3, [r7, #12]
    /* Give the semaphore  to unblock any tasks that might be waiting for an Rx
        to complete.  If a task is unblocked, and the unblocked task has a priority
        above the currently running task, then xHigherPriorityTaskWoken will be set
        to pdTRUE inside the xSemaphoreGiveFromISR() function. */

    xSemaphoreGiveFromISR(xRxCompleteSemaphore, &xHigherPriorityTaskWoken);
    17d0:	4b09      	ldr	r3, [pc, #36]	; (17f8 <prvUARTRxNotificationHandler+0x34>)
    17d2:	681b      	ldr	r3, [r3, #0]
    17d4:	220c      	movs	r2, #12
    17d6:	18ba      	adds	r2, r7, r2
    17d8:	0011      	movs	r1, r2
    17da:	0018      	movs	r0, r3
    17dc:	4b07      	ldr	r3, [pc, #28]	; (17fc <prvUARTRxNotificationHandler+0x38>)
    17de:	4798      	blx	r3

    /* portEND_SWITCHING_ISR() or portYIELD_FROM_ISR() can be used here. */

    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    17e0:	68fb      	ldr	r3, [r7, #12]
    17e2:	2b00      	cmp	r3, #0
    17e4:	d003      	beq.n	17ee <prvUARTRxNotificationHandler+0x2a>
    17e6:	4b06      	ldr	r3, [pc, #24]	; (1800 <prvUARTRxNotificationHandler+0x3c>)
    17e8:	2280      	movs	r2, #128	; 0x80
    17ea:	0552      	lsls	r2, r2, #21
    17ec:	601a      	str	r2, [r3, #0]
}
    17ee:	46c0      	nop			; (mov r8, r8)
    17f0:	46bd      	mov	sp, r7
    17f2:	b004      	add	sp, #16
    17f4:	bd80      	pop	{r7, pc}
    17f6:	46c0      	nop			; (mov r8, r8)
    17f8:	200008b4 	.word	0x200008b4
    17fc:	000036c9 	.word	0x000036c9
    1800:	e000ed04 	.word	0xe000ed04

00001804 <prvUARTTxNotificationHandler>:
/*-----------------------------------------------------------*/

static void prvUARTTxNotificationHandler( const struct usart_module *const pxUSART )
{
    1804:	b580      	push	{r7, lr}
    1806:	b084      	sub	sp, #16
    1808:	af00      	add	r7, sp, #0
    180a:	6078      	str	r0, [r7, #4]
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
    180c:	2300      	movs	r3, #0
    180e:	60fb      	str	r3, [r7, #12]
    /* Give the semaphore  to unblock any tasks that might be waiting for a Tx
	to complete.  If a task is unblocked, and the unblocked task has a priority
	above the currently running task, then xHigherPriorityTaskWoken will be set
	to pdTRUE inside the xSemaphoreGiveFromISR() function. */

    xSemaphoreGiveFromISR( xTxCompleteSemaphore, &xHigherPriorityTaskWoken );
    1810:	4b09      	ldr	r3, [pc, #36]	; (1838 <prvUARTTxNotificationHandler+0x34>)
    1812:	681b      	ldr	r3, [r3, #0]
    1814:	220c      	movs	r2, #12
    1816:	18ba      	adds	r2, r7, r2
    1818:	0011      	movs	r1, r2
    181a:	0018      	movs	r0, r3
    181c:	4b07      	ldr	r3, [pc, #28]	; (183c <prvUARTTxNotificationHandler+0x38>)
    181e:	4798      	blx	r3

    /* portEND_SWITCHING_ISR() or portYIELD_FROM_ISR() can be used here. */

    portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
    1820:	68fb      	ldr	r3, [r7, #12]
    1822:	2b00      	cmp	r3, #0
    1824:	d003      	beq.n	182e <prvUARTTxNotificationHandler+0x2a>
    1826:	4b06      	ldr	r3, [pc, #24]	; (1840 <prvUARTTxNotificationHandler+0x3c>)
    1828:	2280      	movs	r2, #128	; 0x80
    182a:	0552      	lsls	r2, r2, #21
    182c:	601a      	str	r2, [r3, #0]
}
    182e:	46c0      	nop			; (mov r8, r8)
    1830:	46bd      	mov	sp, r7
    1832:	b004      	add	sp, #16
    1834:	bd80      	pop	{r7, pc}
    1836:	46c0      	nop			; (mov r8, r8)
    1838:	200008b0 	.word	0x200008b0
    183c:	000036c9 	.word	0x000036c9
    1840:	e000ed04 	.word	0xe000ed04

00001844 <system_gclk_chan_get_config_defaults>:
{
    1844:	b580      	push	{r7, lr}
    1846:	b082      	sub	sp, #8
    1848:	af00      	add	r7, sp, #0
    184a:	6078      	str	r0, [r7, #4]
	config->source_generator = GCLK_GENERATOR_0;
    184c:	687b      	ldr	r3, [r7, #4]
    184e:	2200      	movs	r2, #0
    1850:	701a      	strb	r2, [r3, #0]
}
    1852:	46c0      	nop			; (mov r8, r8)
    1854:	46bd      	mov	sp, r7
    1856:	b002      	add	sp, #8
    1858:	bd80      	pop	{r7, pc}

0000185a <long_division>:
/**
 * \internal Calculate 64 bit division, ref can be found in
 * http://en.wikipedia.org/wiki/Division_algorithm#Long_division
 */
static uint64_t long_division(uint64_t n, uint64_t d)
{
    185a:	b5f0      	push	{r4, r5, r6, r7, lr}
    185c:	b08d      	sub	sp, #52	; 0x34
    185e:	af00      	add	r7, sp, #0
    1860:	60b8      	str	r0, [r7, #8]
    1862:	60f9      	str	r1, [r7, #12]
    1864:	603a      	str	r2, [r7, #0]
    1866:	607b      	str	r3, [r7, #4]
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
    1868:	2300      	movs	r3, #0
    186a:	2400      	movs	r4, #0
    186c:	623b      	str	r3, [r7, #32]
    186e:	627c      	str	r4, [r7, #36]	; 0x24
    1870:	2300      	movs	r3, #0
    1872:	2400      	movs	r4, #0
    1874:	61bb      	str	r3, [r7, #24]
    1876:	61fc      	str	r4, [r7, #28]
	for (i = 63; i >= 0; i--) {
    1878:	233f      	movs	r3, #63	; 0x3f
    187a:	62fb      	str	r3, [r7, #44]	; 0x2c
    187c:	e053      	b.n	1926 <long_division+0xcc>
		bit_shift = (uint64_t)1 << i;
    187e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1880:	3b20      	subs	r3, #32
    1882:	2b00      	cmp	r3, #0
    1884:	db04      	blt.n	1890 <long_division+0x36>
    1886:	2201      	movs	r2, #1
    1888:	409a      	lsls	r2, r3
    188a:	0013      	movs	r3, r2
    188c:	617b      	str	r3, [r7, #20]
    188e:	e00b      	b.n	18a8 <long_division+0x4e>
    1890:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1892:	2220      	movs	r2, #32
    1894:	1ad3      	subs	r3, r2, r3
    1896:	2201      	movs	r2, #1
    1898:	40da      	lsrs	r2, r3
    189a:	0013      	movs	r3, r2
    189c:	2100      	movs	r1, #0
    189e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    18a0:	4091      	lsls	r1, r2
    18a2:	000a      	movs	r2, r1
    18a4:	4313      	orrs	r3, r2
    18a6:	617b      	str	r3, [r7, #20]
    18a8:	2201      	movs	r2, #1
    18aa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    18ac:	409a      	lsls	r2, r3
    18ae:	0013      	movs	r3, r2
    18b0:	613b      	str	r3, [r7, #16]

		r = r << 1;
    18b2:	69bb      	ldr	r3, [r7, #24]
    18b4:	69fc      	ldr	r4, [r7, #28]
    18b6:	18db      	adds	r3, r3, r3
    18b8:	4164      	adcs	r4, r4
    18ba:	61bb      	str	r3, [r7, #24]
    18bc:	61fc      	str	r4, [r7, #28]

		if (n & bit_shift) {
    18be:	68bb      	ldr	r3, [r7, #8]
    18c0:	693a      	ldr	r2, [r7, #16]
    18c2:	401a      	ands	r2, r3
    18c4:	0015      	movs	r5, r2
    18c6:	68fb      	ldr	r3, [r7, #12]
    18c8:	697a      	ldr	r2, [r7, #20]
    18ca:	401a      	ands	r2, r3
    18cc:	0016      	movs	r6, r2
    18ce:	002b      	movs	r3, r5
    18d0:	4333      	orrs	r3, r6
    18d2:	d007      	beq.n	18e4 <long_division+0x8a>
			r |= 0x01;
    18d4:	69bb      	ldr	r3, [r7, #24]
    18d6:	2201      	movs	r2, #1
    18d8:	4313      	orrs	r3, r2
    18da:	61bb      	str	r3, [r7, #24]
    18dc:	69fb      	ldr	r3, [r7, #28]
    18de:	2200      	movs	r2, #0
    18e0:	4313      	orrs	r3, r2
    18e2:	61fb      	str	r3, [r7, #28]
		}

		if (r >= d) {
    18e4:	687a      	ldr	r2, [r7, #4]
    18e6:	69fb      	ldr	r3, [r7, #28]
    18e8:	429a      	cmp	r2, r3
    18ea:	d819      	bhi.n	1920 <long_division+0xc6>
    18ec:	687a      	ldr	r2, [r7, #4]
    18ee:	69fb      	ldr	r3, [r7, #28]
    18f0:	429a      	cmp	r2, r3
    18f2:	d103      	bne.n	18fc <long_division+0xa2>
    18f4:	683a      	ldr	r2, [r7, #0]
    18f6:	69bb      	ldr	r3, [r7, #24]
    18f8:	429a      	cmp	r2, r3
    18fa:	d811      	bhi.n	1920 <long_division+0xc6>
			r = r - d;
    18fc:	69b9      	ldr	r1, [r7, #24]
    18fe:	69fa      	ldr	r2, [r7, #28]
    1900:	683b      	ldr	r3, [r7, #0]
    1902:	687c      	ldr	r4, [r7, #4]
    1904:	1ac9      	subs	r1, r1, r3
    1906:	41a2      	sbcs	r2, r4
    1908:	000b      	movs	r3, r1
    190a:	0014      	movs	r4, r2
    190c:	61bb      	str	r3, [r7, #24]
    190e:	61fc      	str	r4, [r7, #28]
			q |= bit_shift;
    1910:	6a3a      	ldr	r2, [r7, #32]
    1912:	693b      	ldr	r3, [r7, #16]
    1914:	4313      	orrs	r3, r2
    1916:	623b      	str	r3, [r7, #32]
    1918:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    191a:	697b      	ldr	r3, [r7, #20]
    191c:	4313      	orrs	r3, r2
    191e:	627b      	str	r3, [r7, #36]	; 0x24
	for (i = 63; i >= 0; i--) {
    1920:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1922:	3b01      	subs	r3, #1
    1924:	62fb      	str	r3, [r7, #44]	; 0x2c
    1926:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1928:	2b00      	cmp	r3, #0
    192a:	daa8      	bge.n	187e <long_division+0x24>
		}
	}

	return q;
    192c:	6a3b      	ldr	r3, [r7, #32]
    192e:	6a7c      	ldr	r4, [r7, #36]	; 0x24
}
    1930:	0018      	movs	r0, r3
    1932:	0021      	movs	r1, r4
    1934:	46bd      	mov	sp, r7
    1936:	b00d      	add	sp, #52	; 0x34
    1938:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000193a <_sercom_get_sync_baud_val>:
 */
enum status_code _sercom_get_sync_baud_val(
		const uint32_t baudrate,
		const uint32_t external_clock,
		uint16_t *const baudvalue)
{
    193a:	b580      	push	{r7, lr}
    193c:	b086      	sub	sp, #24
    193e:	af00      	add	r7, sp, #0
    1940:	60f8      	str	r0, [r7, #12]
    1942:	60b9      	str	r1, [r7, #8]
    1944:	607a      	str	r2, [r7, #4]
	/* Baud value variable */
	uint16_t baud_calculated = 0;
    1946:	2316      	movs	r3, #22
    1948:	18fb      	adds	r3, r7, r3
    194a:	2200      	movs	r2, #0
    194c:	801a      	strh	r2, [r3, #0]
	uint32_t clock_value = external_clock;
    194e:	68bb      	ldr	r3, [r7, #8]
    1950:	613b      	str	r3, [r7, #16]


	/* Check if baudrate is outside of valid range */
	if (baudrate > (external_clock / 2)) {
    1952:	68bb      	ldr	r3, [r7, #8]
    1954:	085a      	lsrs	r2, r3, #1
    1956:	68fb      	ldr	r3, [r7, #12]
    1958:	429a      	cmp	r2, r3
    195a:	d201      	bcs.n	1960 <_sercom_get_sync_baud_val+0x26>
		/* Return with error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
    195c:	2340      	movs	r3, #64	; 0x40
    195e:	e026      	b.n	19ae <_sercom_get_sync_baud_val+0x74>
	}

	/* Calculate BAUD value from clock frequency and baudrate */
	clock_value = external_clock / 2;
    1960:	68bb      	ldr	r3, [r7, #8]
    1962:	085b      	lsrs	r3, r3, #1
    1964:	613b      	str	r3, [r7, #16]
	while (clock_value >= baudrate) {
    1966:	e00a      	b.n	197e <_sercom_get_sync_baud_val+0x44>
		clock_value = clock_value - baudrate;
    1968:	693a      	ldr	r2, [r7, #16]
    196a:	68fb      	ldr	r3, [r7, #12]
    196c:	1ad3      	subs	r3, r2, r3
    196e:	613b      	str	r3, [r7, #16]
		baud_calculated++;
    1970:	2316      	movs	r3, #22
    1972:	18fb      	adds	r3, r7, r3
    1974:	881a      	ldrh	r2, [r3, #0]
    1976:	2316      	movs	r3, #22
    1978:	18fb      	adds	r3, r7, r3
    197a:	3201      	adds	r2, #1
    197c:	801a      	strh	r2, [r3, #0]
	while (clock_value >= baudrate) {
    197e:	693a      	ldr	r2, [r7, #16]
    1980:	68fb      	ldr	r3, [r7, #12]
    1982:	429a      	cmp	r2, r3
    1984:	d2f0      	bcs.n	1968 <_sercom_get_sync_baud_val+0x2e>
	}
	baud_calculated = baud_calculated - 1;
    1986:	2316      	movs	r3, #22
    1988:	18fb      	adds	r3, r7, r3
    198a:	2216      	movs	r2, #22
    198c:	18ba      	adds	r2, r7, r2
    198e:	8812      	ldrh	r2, [r2, #0]
    1990:	3a01      	subs	r2, #1
    1992:	801a      	strh	r2, [r3, #0]

	/* Check if BAUD value is more than 255, which is maximum
	 * for synchronous mode */
	if (baud_calculated > 0xFF) {
    1994:	2316      	movs	r3, #22
    1996:	18fb      	adds	r3, r7, r3
    1998:	881b      	ldrh	r3, [r3, #0]
    199a:	2bff      	cmp	r3, #255	; 0xff
    199c:	d901      	bls.n	19a2 <_sercom_get_sync_baud_val+0x68>
		/* Return with an error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
    199e:	2340      	movs	r3, #64	; 0x40
    19a0:	e005      	b.n	19ae <_sercom_get_sync_baud_val+0x74>
	} else {
		*baudvalue = baud_calculated;
    19a2:	687b      	ldr	r3, [r7, #4]
    19a4:	2216      	movs	r2, #22
    19a6:	18ba      	adds	r2, r7, r2
    19a8:	8812      	ldrh	r2, [r2, #0]
    19aa:	801a      	strh	r2, [r3, #0]
		return STATUS_OK;
    19ac:	2300      	movs	r3, #0
	}
}
    19ae:	0018      	movs	r0, r3
    19b0:	46bd      	mov	sp, r7
    19b2:	b006      	add	sp, #24
    19b4:	bd80      	pop	{r7, pc}
	...

000019b8 <_sercom_get_async_baud_val>:
		const uint32_t baudrate,
		const uint32_t peripheral_clock,
		uint16_t *const baudval,
		enum sercom_asynchronous_operation_mode mode,
		enum sercom_asynchronous_sample_num sample_num)
{
    19b8:	b5f0      	push	{r4, r5, r6, r7, lr}
    19ba:	b0a1      	sub	sp, #132	; 0x84
    19bc:	af00      	add	r7, sp, #0
    19be:	64f8      	str	r0, [r7, #76]	; 0x4c
    19c0:	64b9      	str	r1, [r7, #72]	; 0x48
    19c2:	647a      	str	r2, [r7, #68]	; 0x44
    19c4:	2243      	movs	r2, #67	; 0x43
    19c6:	18ba      	adds	r2, r7, r2
    19c8:	7013      	strb	r3, [r2, #0]
	/* Temporary variables  */
	uint64_t ratio = 0;
    19ca:	2300      	movs	r3, #0
    19cc:	2400      	movs	r4, #0
    19ce:	673b      	str	r3, [r7, #112]	; 0x70
    19d0:	677c      	str	r4, [r7, #116]	; 0x74
	uint64_t scale = 0;
    19d2:	2300      	movs	r3, #0
    19d4:	2400      	movs	r4, #0
    19d6:	66bb      	str	r3, [r7, #104]	; 0x68
    19d8:	66fc      	str	r4, [r7, #108]	; 0x6c
	uint64_t baud_calculated = 0;
    19da:	2300      	movs	r3, #0
    19dc:	2400      	movs	r4, #0
    19de:	67bb      	str	r3, [r7, #120]	; 0x78
    19e0:	67fc      	str	r4, [r7, #124]	; 0x7c
	uint8_t baud_fp;
	uint32_t baud_int = 0;
    19e2:	2300      	movs	r3, #0
    19e4:	667b      	str	r3, [r7, #100]	; 0x64
	uint64_t temp1;

	/* Check if the baudrate is outside of valid range */
	if ((baudrate * sample_num) > peripheral_clock) {
    19e6:	2358      	movs	r3, #88	; 0x58
    19e8:	2240      	movs	r2, #64	; 0x40
    19ea:	4694      	mov	ip, r2
    19ec:	44bc      	add	ip, r7
    19ee:	4463      	add	r3, ip
    19f0:	781a      	ldrb	r2, [r3, #0]
    19f2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    19f4:	435a      	muls	r2, r3
    19f6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
    19f8:	429a      	cmp	r2, r3
    19fa:	d901      	bls.n	1a00 <_sercom_get_async_baud_val+0x48>
		/* Return with error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
    19fc:	2340      	movs	r3, #64	; 0x40
    19fe:	e0b3      	b.n	1b68 <_sercom_get_async_baud_val+0x1b0>
	}

	if(mode == SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC) {
    1a00:	2343      	movs	r3, #67	; 0x43
    1a02:	18fb      	adds	r3, r7, r3
    1a04:	781b      	ldrb	r3, [r3, #0]
    1a06:	2b00      	cmp	r3, #0
    1a08:	d13d      	bne.n	1a86 <_sercom_get_async_baud_val+0xce>
		/* Calculate the BAUD value */
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
    1a0a:	2358      	movs	r3, #88	; 0x58
    1a0c:	2240      	movs	r2, #64	; 0x40
    1a0e:	4694      	mov	ip, r2
    1a10:	44bc      	add	ip, r7
    1a12:	4463      	add	r3, ip
    1a14:	781b      	ldrb	r3, [r3, #0]
    1a16:	b2db      	uxtb	r3, r3
    1a18:	613b      	str	r3, [r7, #16]
    1a1a:	2300      	movs	r3, #0
    1a1c:	617b      	str	r3, [r7, #20]
    1a1e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    1a20:	60bb      	str	r3, [r7, #8]
    1a22:	2300      	movs	r3, #0
    1a24:	60fb      	str	r3, [r7, #12]
    1a26:	4c52      	ldr	r4, [pc, #328]	; (1b70 <_sercom_get_async_baud_val+0x1b8>)
    1a28:	68ba      	ldr	r2, [r7, #8]
    1a2a:	68fb      	ldr	r3, [r7, #12]
    1a2c:	6938      	ldr	r0, [r7, #16]
    1a2e:	6979      	ldr	r1, [r7, #20]
    1a30:	47a0      	blx	r4
    1a32:	0003      	movs	r3, r0
    1a34:	000c      	movs	r4, r1
    1a36:	001b      	movs	r3, r3
    1a38:	65fb      	str	r3, [r7, #92]	; 0x5c
    1a3a:	2300      	movs	r3, #0
    1a3c:	65bb      	str	r3, [r7, #88]	; 0x58
		ratio = long_division(temp1, peripheral_clock);
    1a3e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
    1a40:	603b      	str	r3, [r7, #0]
    1a42:	2300      	movs	r3, #0
    1a44:	607b      	str	r3, [r7, #4]
    1a46:	6db8      	ldr	r0, [r7, #88]	; 0x58
    1a48:	6df9      	ldr	r1, [r7, #92]	; 0x5c
    1a4a:	683a      	ldr	r2, [r7, #0]
    1a4c:	687b      	ldr	r3, [r7, #4]
    1a4e:	4c49      	ldr	r4, [pc, #292]	; (1b74 <_sercom_get_async_baud_val+0x1bc>)
    1a50:	47a0      	blx	r4
    1a52:	0003      	movs	r3, r0
    1a54:	000c      	movs	r4, r1
    1a56:	673b      	str	r3, [r7, #112]	; 0x70
    1a58:	677c      	str	r4, [r7, #116]	; 0x74
		scale = ((uint64_t)1 << SHIFT) - ratio;
    1a5a:	2100      	movs	r1, #0
    1a5c:	2201      	movs	r2, #1
    1a5e:	6f3b      	ldr	r3, [r7, #112]	; 0x70
    1a60:	6f7c      	ldr	r4, [r7, #116]	; 0x74
    1a62:	1ac9      	subs	r1, r1, r3
    1a64:	41a2      	sbcs	r2, r4
    1a66:	000b      	movs	r3, r1
    1a68:	0014      	movs	r4, r2
    1a6a:	66bb      	str	r3, [r7, #104]	; 0x68
    1a6c:	66fc      	str	r4, [r7, #108]	; 0x6c
		baud_calculated = (65536 * scale) >> SHIFT;
    1a6e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
    1a70:	0c1b      	lsrs	r3, r3, #16
    1a72:	6efa      	ldr	r2, [r7, #108]	; 0x6c
    1a74:	0416      	lsls	r6, r2, #16
    1a76:	431e      	orrs	r6, r3
    1a78:	6ebb      	ldr	r3, [r7, #104]	; 0x68
    1a7a:	041d      	lsls	r5, r3, #16
    1a7c:	0033      	movs	r3, r6
    1a7e:	67bb      	str	r3, [r7, #120]	; 0x78
    1a80:	2300      	movs	r3, #0
    1a82:	67fb      	str	r3, [r7, #124]	; 0x7c
    1a84:	e06a      	b.n	1b5c <_sercom_get_async_baud_val+0x1a4>
	} else if(mode == SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL) {
    1a86:	2343      	movs	r3, #67	; 0x43
    1a88:	18fb      	adds	r3, r7, r3
    1a8a:	781b      	ldrb	r3, [r3, #0]
    1a8c:	2b01      	cmp	r3, #1
    1a8e:	d165      	bne.n	1b5c <_sercom_get_async_baud_val+0x1a4>
		temp1 = ((uint64_t)baudrate * sample_num);
    1a90:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    1a92:	633b      	str	r3, [r7, #48]	; 0x30
    1a94:	2300      	movs	r3, #0
    1a96:	637b      	str	r3, [r7, #52]	; 0x34
    1a98:	2358      	movs	r3, #88	; 0x58
    1a9a:	2240      	movs	r2, #64	; 0x40
    1a9c:	4694      	mov	ip, r2
    1a9e:	44bc      	add	ip, r7
    1aa0:	4463      	add	r3, ip
    1aa2:	781b      	ldrb	r3, [r3, #0]
    1aa4:	b2db      	uxtb	r3, r3
    1aa6:	62bb      	str	r3, [r7, #40]	; 0x28
    1aa8:	2300      	movs	r3, #0
    1aaa:	62fb      	str	r3, [r7, #44]	; 0x2c
    1aac:	4c30      	ldr	r4, [pc, #192]	; (1b70 <_sercom_get_async_baud_val+0x1b8>)
    1aae:	6aba      	ldr	r2, [r7, #40]	; 0x28
    1ab0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1ab2:	6b38      	ldr	r0, [r7, #48]	; 0x30
    1ab4:	6b79      	ldr	r1, [r7, #52]	; 0x34
    1ab6:	47a0      	blx	r4
    1ab8:	0003      	movs	r3, r0
    1aba:	000c      	movs	r4, r1
    1abc:	65bb      	str	r3, [r7, #88]	; 0x58
    1abe:	65fc      	str	r4, [r7, #92]	; 0x5c
		baud_int = long_division( peripheral_clock, temp1);
    1ac0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
    1ac2:	623b      	str	r3, [r7, #32]
    1ac4:	2300      	movs	r3, #0
    1ac6:	627b      	str	r3, [r7, #36]	; 0x24
    1ac8:	6dbb      	ldr	r3, [r7, #88]	; 0x58
    1aca:	6dfc      	ldr	r4, [r7, #92]	; 0x5c
    1acc:	001a      	movs	r2, r3
    1ace:	0023      	movs	r3, r4
    1ad0:	6a38      	ldr	r0, [r7, #32]
    1ad2:	6a79      	ldr	r1, [r7, #36]	; 0x24
    1ad4:	4c27      	ldr	r4, [pc, #156]	; (1b74 <_sercom_get_async_baud_val+0x1bc>)
    1ad6:	47a0      	blx	r4
    1ad8:	0003      	movs	r3, r0
    1ada:	000c      	movs	r4, r1
    1adc:	667b      	str	r3, [r7, #100]	; 0x64
		if(baud_int > BAUD_INT_MAX) {
    1ade:	6e7a      	ldr	r2, [r7, #100]	; 0x64
    1ae0:	2380      	movs	r3, #128	; 0x80
    1ae2:	019b      	lsls	r3, r3, #6
    1ae4:	429a      	cmp	r2, r3
    1ae6:	d901      	bls.n	1aec <_sercom_get_async_baud_val+0x134>
				return STATUS_ERR_BAUDRATE_UNAVAILABLE;
    1ae8:	2340      	movs	r3, #64	; 0x40
    1aea:	e03d      	b.n	1b68 <_sercom_get_async_baud_val+0x1b0>
		}
		temp1 = long_division( 8 * (uint64_t)peripheral_clock, temp1);
    1aec:	6cbb      	ldr	r3, [r7, #72]	; 0x48
    1aee:	61bb      	str	r3, [r7, #24]
    1af0:	2300      	movs	r3, #0
    1af2:	61fb      	str	r3, [r7, #28]
    1af4:	69b9      	ldr	r1, [r7, #24]
    1af6:	69fa      	ldr	r2, [r7, #28]
    1af8:	000b      	movs	r3, r1
    1afa:	0f5b      	lsrs	r3, r3, #29
    1afc:	0010      	movs	r0, r2
    1afe:	00c0      	lsls	r0, r0, #3
    1b00:	63f8      	str	r0, [r7, #60]	; 0x3c
    1b02:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
    1b04:	4318      	orrs	r0, r3
    1b06:	63f8      	str	r0, [r7, #60]	; 0x3c
    1b08:	000b      	movs	r3, r1
    1b0a:	00db      	lsls	r3, r3, #3
    1b0c:	63bb      	str	r3, [r7, #56]	; 0x38
    1b0e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
    1b10:	6dfc      	ldr	r4, [r7, #92]	; 0x5c
    1b12:	001a      	movs	r2, r3
    1b14:	0023      	movs	r3, r4
    1b16:	6bb8      	ldr	r0, [r7, #56]	; 0x38
    1b18:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
    1b1a:	4c16      	ldr	r4, [pc, #88]	; (1b74 <_sercom_get_async_baud_val+0x1bc>)
    1b1c:	47a0      	blx	r4
    1b1e:	0003      	movs	r3, r0
    1b20:	000c      	movs	r4, r1
    1b22:	65bb      	str	r3, [r7, #88]	; 0x58
    1b24:	65fc      	str	r4, [r7, #92]	; 0x5c
		baud_fp = temp1 - 8 * baud_int;
    1b26:	6dbb      	ldr	r3, [r7, #88]	; 0x58
    1b28:	6dfc      	ldr	r4, [r7, #92]	; 0x5c
    1b2a:	b2d9      	uxtb	r1, r3
    1b2c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
    1b2e:	b2db      	uxtb	r3, r3
    1b30:	00db      	lsls	r3, r3, #3
    1b32:	b2da      	uxtb	r2, r3
    1b34:	2317      	movs	r3, #23
    1b36:	2040      	movs	r0, #64	; 0x40
    1b38:	4684      	mov	ip, r0
    1b3a:	44bc      	add	ip, r7
    1b3c:	4463      	add	r3, ip
    1b3e:	1a8a      	subs	r2, r1, r2
    1b40:	701a      	strb	r2, [r3, #0]
		baud_calculated = baud_int | (baud_fp << 13);
    1b42:	2317      	movs	r3, #23
    1b44:	2240      	movs	r2, #64	; 0x40
    1b46:	4694      	mov	ip, r2
    1b48:	44bc      	add	ip, r7
    1b4a:	4463      	add	r3, ip
    1b4c:	781b      	ldrb	r3, [r3, #0]
    1b4e:	035b      	lsls	r3, r3, #13
    1b50:	001a      	movs	r2, r3
    1b52:	6e7b      	ldr	r3, [r7, #100]	; 0x64
    1b54:	4313      	orrs	r3, r2
    1b56:	67bb      	str	r3, [r7, #120]	; 0x78
    1b58:	2300      	movs	r3, #0
    1b5a:	67fb      	str	r3, [r7, #124]	; 0x7c
	}

	*baudval = baud_calculated;
    1b5c:	6fbb      	ldr	r3, [r7, #120]	; 0x78
    1b5e:	6ffc      	ldr	r4, [r7, #124]	; 0x7c
    1b60:	b29a      	uxth	r2, r3
    1b62:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    1b64:	801a      	strh	r2, [r3, #0]
	return STATUS_OK;
    1b66:	2300      	movs	r3, #0
}
    1b68:	0018      	movs	r0, r3
    1b6a:	46bd      	mov	sp, r7
    1b6c:	b021      	add	sp, #132	; 0x84
    1b6e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1b70:	00006b35 	.word	0x00006b35
    1b74:	0000185b 	.word	0x0000185b

00001b78 <sercom_set_gclk_generator>:
 *                                         forced.
 */
enum status_code sercom_set_gclk_generator(
		const enum gclk_generator generator_source,
		const bool force_change)
{
    1b78:	b580      	push	{r7, lr}
    1b7a:	b084      	sub	sp, #16
    1b7c:	af00      	add	r7, sp, #0
    1b7e:	0002      	movs	r2, r0
    1b80:	1dfb      	adds	r3, r7, #7
    1b82:	701a      	strb	r2, [r3, #0]
    1b84:	1dbb      	adds	r3, r7, #6
    1b86:	1c0a      	adds	r2, r1, #0
    1b88:	701a      	strb	r2, [r3, #0]
	/* Check if valid option */
	if (!_sercom_config.generator_is_set || force_change) {
    1b8a:	4b1a      	ldr	r3, [pc, #104]	; (1bf4 <sercom_set_gclk_generator+0x7c>)
    1b8c:	781b      	ldrb	r3, [r3, #0]
    1b8e:	2201      	movs	r2, #1
    1b90:	4053      	eors	r3, r2
    1b92:	b2db      	uxtb	r3, r3
    1b94:	2b00      	cmp	r3, #0
    1b96:	d103      	bne.n	1ba0 <sercom_set_gclk_generator+0x28>
    1b98:	1dbb      	adds	r3, r7, #6
    1b9a:	781b      	ldrb	r3, [r3, #0]
    1b9c:	2b00      	cmp	r3, #0
    1b9e:	d01b      	beq.n	1bd8 <sercom_set_gclk_generator+0x60>
		/* Create and fill a GCLK configuration structure for the new config */
		struct system_gclk_chan_config gclk_chan_conf;
		system_gclk_chan_get_config_defaults(&gclk_chan_conf);
    1ba0:	230c      	movs	r3, #12
    1ba2:	18fb      	adds	r3, r7, r3
    1ba4:	0018      	movs	r0, r3
    1ba6:	4b14      	ldr	r3, [pc, #80]	; (1bf8 <sercom_set_gclk_generator+0x80>)
    1ba8:	4798      	blx	r3
		gclk_chan_conf.source_generator = generator_source;
    1baa:	230c      	movs	r3, #12
    1bac:	18fb      	adds	r3, r7, r3
    1bae:	1dfa      	adds	r2, r7, #7
    1bb0:	7812      	ldrb	r2, [r2, #0]
    1bb2:	701a      	strb	r2, [r3, #0]
		system_gclk_chan_set_config(SERCOM_GCLK_ID, &gclk_chan_conf);
    1bb4:	230c      	movs	r3, #12
    1bb6:	18fb      	adds	r3, r7, r3
    1bb8:	0019      	movs	r1, r3
    1bba:	2012      	movs	r0, #18
    1bbc:	4b0f      	ldr	r3, [pc, #60]	; (1bfc <sercom_set_gclk_generator+0x84>)
    1bbe:	4798      	blx	r3
		system_gclk_chan_enable(SERCOM_GCLK_ID);
    1bc0:	2012      	movs	r0, #18
    1bc2:	4b0f      	ldr	r3, [pc, #60]	; (1c00 <sercom_set_gclk_generator+0x88>)
    1bc4:	4798      	blx	r3

		/* Save config */
		_sercom_config.generator_source = generator_source;
    1bc6:	4b0b      	ldr	r3, [pc, #44]	; (1bf4 <sercom_set_gclk_generator+0x7c>)
    1bc8:	1dfa      	adds	r2, r7, #7
    1bca:	7812      	ldrb	r2, [r2, #0]
    1bcc:	705a      	strb	r2, [r3, #1]
		_sercom_config.generator_is_set = true;
    1bce:	4b09      	ldr	r3, [pc, #36]	; (1bf4 <sercom_set_gclk_generator+0x7c>)
    1bd0:	2201      	movs	r2, #1
    1bd2:	701a      	strb	r2, [r3, #0]

		return STATUS_OK;
    1bd4:	2300      	movs	r3, #0
    1bd6:	e008      	b.n	1bea <sercom_set_gclk_generator+0x72>
	} else if (generator_source == _sercom_config.generator_source) {
    1bd8:	4b06      	ldr	r3, [pc, #24]	; (1bf4 <sercom_set_gclk_generator+0x7c>)
    1bda:	785b      	ldrb	r3, [r3, #1]
    1bdc:	1dfa      	adds	r2, r7, #7
    1bde:	7812      	ldrb	r2, [r2, #0]
    1be0:	429a      	cmp	r2, r3
    1be2:	d101      	bne.n	1be8 <sercom_set_gclk_generator+0x70>
		/* Return status OK if same config */
		return STATUS_OK;
    1be4:	2300      	movs	r3, #0
    1be6:	e000      	b.n	1bea <sercom_set_gclk_generator+0x72>
	}

	/* Return invalid config to already initialized GCLK */
	return STATUS_ERR_ALREADY_INITIALIZED;
    1be8:	231d      	movs	r3, #29
}
    1bea:	0018      	movs	r0, r3
    1bec:	46bd      	mov	sp, r7
    1bee:	b004      	add	sp, #16
    1bf0:	bd80      	pop	{r7, pc}
    1bf2:	46c0      	nop			; (mov r8, r8)
    1bf4:	20000968 	.word	0x20000968
    1bf8:	00001845 	.word	0x00001845
    1bfc:	00006659 	.word	0x00006659
    1c00:	00006699 	.word	0x00006699

00001c04 <_sercom_get_default_pad>:
 *
 */
uint32_t _sercom_get_default_pad(
		Sercom *const sercom_module,
		const uint8_t pad)
{
    1c04:	b580      	push	{r7, lr}
    1c06:	b082      	sub	sp, #8
    1c08:	af00      	add	r7, sp, #0
    1c0a:	6078      	str	r0, [r7, #4]
    1c0c:	000a      	movs	r2, r1
    1c0e:	1cfb      	adds	r3, r7, #3
    1c10:	701a      	strb	r2, [r3, #0]
	switch ((uintptr_t)sercom_module) {
    1c12:	687b      	ldr	r3, [r7, #4]
    1c14:	4a4d      	ldr	r2, [pc, #308]	; (1d4c <_sercom_get_default_pad+0x148>)
    1c16:	4293      	cmp	r3, r2
    1c18:	d03f      	beq.n	1c9a <_sercom_get_default_pad+0x96>
    1c1a:	4a4c      	ldr	r2, [pc, #304]	; (1d4c <_sercom_get_default_pad+0x148>)
    1c1c:	4293      	cmp	r3, r2
    1c1e:	d806      	bhi.n	1c2e <_sercom_get_default_pad+0x2a>
    1c20:	4a4b      	ldr	r2, [pc, #300]	; (1d50 <_sercom_get_default_pad+0x14c>)
    1c22:	4293      	cmp	r3, r2
    1c24:	d00f      	beq.n	1c46 <_sercom_get_default_pad+0x42>
    1c26:	4a4b      	ldr	r2, [pc, #300]	; (1d54 <_sercom_get_default_pad+0x150>)
    1c28:	4293      	cmp	r3, r2
    1c2a:	d021      	beq.n	1c70 <_sercom_get_default_pad+0x6c>
    1c2c:	e089      	b.n	1d42 <_sercom_get_default_pad+0x13e>
    1c2e:	4a4a      	ldr	r2, [pc, #296]	; (1d58 <_sercom_get_default_pad+0x154>)
    1c30:	4293      	cmp	r3, r2
    1c32:	d100      	bne.n	1c36 <_sercom_get_default_pad+0x32>
    1c34:	e05b      	b.n	1cee <_sercom_get_default_pad+0xea>
    1c36:	4a49      	ldr	r2, [pc, #292]	; (1d5c <_sercom_get_default_pad+0x158>)
    1c38:	4293      	cmp	r3, r2
    1c3a:	d100      	bne.n	1c3e <_sercom_get_default_pad+0x3a>
    1c3c:	e06c      	b.n	1d18 <_sercom_get_default_pad+0x114>
    1c3e:	4a48      	ldr	r2, [pc, #288]	; (1d60 <_sercom_get_default_pad+0x15c>)
    1c40:	4293      	cmp	r3, r2
    1c42:	d03f      	beq.n	1cc4 <_sercom_get_default_pad+0xc0>
    1c44:	e07d      	b.n	1d42 <_sercom_get_default_pad+0x13e>
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    1c46:	1cfb      	adds	r3, r7, #3
    1c48:	781b      	ldrb	r3, [r3, #0]
    1c4a:	2b01      	cmp	r3, #1
    1c4c:	d00a      	beq.n	1c64 <_sercom_get_default_pad+0x60>
    1c4e:	dc02      	bgt.n	1c56 <_sercom_get_default_pad+0x52>
    1c50:	2b00      	cmp	r3, #0
    1c52:	d005      	beq.n	1c60 <_sercom_get_default_pad+0x5c>
    1c54:	e075      	b.n	1d42 <_sercom_get_default_pad+0x13e>
    1c56:	2b02      	cmp	r3, #2
    1c58:	d006      	beq.n	1c68 <_sercom_get_default_pad+0x64>
    1c5a:	2b03      	cmp	r3, #3
    1c5c:	d006      	beq.n	1c6c <_sercom_get_default_pad+0x68>
    1c5e:	e070      	b.n	1d42 <_sercom_get_default_pad+0x13e>
    1c60:	4b40      	ldr	r3, [pc, #256]	; (1d64 <_sercom_get_default_pad+0x160>)
    1c62:	e06f      	b.n	1d44 <_sercom_get_default_pad+0x140>
    1c64:	4b40      	ldr	r3, [pc, #256]	; (1d68 <_sercom_get_default_pad+0x164>)
    1c66:	e06d      	b.n	1d44 <_sercom_get_default_pad+0x140>
    1c68:	4b40      	ldr	r3, [pc, #256]	; (1d6c <_sercom_get_default_pad+0x168>)
    1c6a:	e06b      	b.n	1d44 <_sercom_get_default_pad+0x140>
    1c6c:	4b40      	ldr	r3, [pc, #256]	; (1d70 <_sercom_get_default_pad+0x16c>)
    1c6e:	e069      	b.n	1d44 <_sercom_get_default_pad+0x140>
    1c70:	1cfb      	adds	r3, r7, #3
    1c72:	781b      	ldrb	r3, [r3, #0]
    1c74:	2b01      	cmp	r3, #1
    1c76:	d00a      	beq.n	1c8e <_sercom_get_default_pad+0x8a>
    1c78:	dc02      	bgt.n	1c80 <_sercom_get_default_pad+0x7c>
    1c7a:	2b00      	cmp	r3, #0
    1c7c:	d005      	beq.n	1c8a <_sercom_get_default_pad+0x86>
    1c7e:	e060      	b.n	1d42 <_sercom_get_default_pad+0x13e>
    1c80:	2b02      	cmp	r3, #2
    1c82:	d006      	beq.n	1c92 <_sercom_get_default_pad+0x8e>
    1c84:	2b03      	cmp	r3, #3
    1c86:	d006      	beq.n	1c96 <_sercom_get_default_pad+0x92>
    1c88:	e05b      	b.n	1d42 <_sercom_get_default_pad+0x13e>
    1c8a:	4b3a      	ldr	r3, [pc, #232]	; (1d74 <_sercom_get_default_pad+0x170>)
    1c8c:	e05a      	b.n	1d44 <_sercom_get_default_pad+0x140>
    1c8e:	4b3a      	ldr	r3, [pc, #232]	; (1d78 <_sercom_get_default_pad+0x174>)
    1c90:	e058      	b.n	1d44 <_sercom_get_default_pad+0x140>
    1c92:	4b3a      	ldr	r3, [pc, #232]	; (1d7c <_sercom_get_default_pad+0x178>)
    1c94:	e056      	b.n	1d44 <_sercom_get_default_pad+0x140>
    1c96:	4b3a      	ldr	r3, [pc, #232]	; (1d80 <_sercom_get_default_pad+0x17c>)
    1c98:	e054      	b.n	1d44 <_sercom_get_default_pad+0x140>
    1c9a:	1cfb      	adds	r3, r7, #3
    1c9c:	781b      	ldrb	r3, [r3, #0]
    1c9e:	2b01      	cmp	r3, #1
    1ca0:	d00a      	beq.n	1cb8 <_sercom_get_default_pad+0xb4>
    1ca2:	dc02      	bgt.n	1caa <_sercom_get_default_pad+0xa6>
    1ca4:	2b00      	cmp	r3, #0
    1ca6:	d005      	beq.n	1cb4 <_sercom_get_default_pad+0xb0>
    1ca8:	e04b      	b.n	1d42 <_sercom_get_default_pad+0x13e>
    1caa:	2b02      	cmp	r3, #2
    1cac:	d006      	beq.n	1cbc <_sercom_get_default_pad+0xb8>
    1cae:	2b03      	cmp	r3, #3
    1cb0:	d006      	beq.n	1cc0 <_sercom_get_default_pad+0xbc>
    1cb2:	e046      	b.n	1d42 <_sercom_get_default_pad+0x13e>
    1cb4:	4b33      	ldr	r3, [pc, #204]	; (1d84 <_sercom_get_default_pad+0x180>)
    1cb6:	e045      	b.n	1d44 <_sercom_get_default_pad+0x140>
    1cb8:	4b33      	ldr	r3, [pc, #204]	; (1d88 <_sercom_get_default_pad+0x184>)
    1cba:	e043      	b.n	1d44 <_sercom_get_default_pad+0x140>
    1cbc:	4b33      	ldr	r3, [pc, #204]	; (1d8c <_sercom_get_default_pad+0x188>)
    1cbe:	e041      	b.n	1d44 <_sercom_get_default_pad+0x140>
    1cc0:	4b33      	ldr	r3, [pc, #204]	; (1d90 <_sercom_get_default_pad+0x18c>)
    1cc2:	e03f      	b.n	1d44 <_sercom_get_default_pad+0x140>
    1cc4:	1cfb      	adds	r3, r7, #3
    1cc6:	781b      	ldrb	r3, [r3, #0]
    1cc8:	2b01      	cmp	r3, #1
    1cca:	d00a      	beq.n	1ce2 <_sercom_get_default_pad+0xde>
    1ccc:	dc02      	bgt.n	1cd4 <_sercom_get_default_pad+0xd0>
    1cce:	2b00      	cmp	r3, #0
    1cd0:	d005      	beq.n	1cde <_sercom_get_default_pad+0xda>
    1cd2:	e036      	b.n	1d42 <_sercom_get_default_pad+0x13e>
    1cd4:	2b02      	cmp	r3, #2
    1cd6:	d006      	beq.n	1ce6 <_sercom_get_default_pad+0xe2>
    1cd8:	2b03      	cmp	r3, #3
    1cda:	d006      	beq.n	1cea <_sercom_get_default_pad+0xe6>
    1cdc:	e031      	b.n	1d42 <_sercom_get_default_pad+0x13e>
    1cde:	4b2d      	ldr	r3, [pc, #180]	; (1d94 <_sercom_get_default_pad+0x190>)
    1ce0:	e030      	b.n	1d44 <_sercom_get_default_pad+0x140>
    1ce2:	4b2d      	ldr	r3, [pc, #180]	; (1d98 <_sercom_get_default_pad+0x194>)
    1ce4:	e02e      	b.n	1d44 <_sercom_get_default_pad+0x140>
    1ce6:	4b2d      	ldr	r3, [pc, #180]	; (1d9c <_sercom_get_default_pad+0x198>)
    1ce8:	e02c      	b.n	1d44 <_sercom_get_default_pad+0x140>
    1cea:	4b2d      	ldr	r3, [pc, #180]	; (1da0 <_sercom_get_default_pad+0x19c>)
    1cec:	e02a      	b.n	1d44 <_sercom_get_default_pad+0x140>
    1cee:	1cfb      	adds	r3, r7, #3
    1cf0:	781b      	ldrb	r3, [r3, #0]
    1cf2:	2b01      	cmp	r3, #1
    1cf4:	d00a      	beq.n	1d0c <_sercom_get_default_pad+0x108>
    1cf6:	dc02      	bgt.n	1cfe <_sercom_get_default_pad+0xfa>
    1cf8:	2b00      	cmp	r3, #0
    1cfa:	d005      	beq.n	1d08 <_sercom_get_default_pad+0x104>
    1cfc:	e021      	b.n	1d42 <_sercom_get_default_pad+0x13e>
    1cfe:	2b02      	cmp	r3, #2
    1d00:	d006      	beq.n	1d10 <_sercom_get_default_pad+0x10c>
    1d02:	2b03      	cmp	r3, #3
    1d04:	d006      	beq.n	1d14 <_sercom_get_default_pad+0x110>
    1d06:	e01c      	b.n	1d42 <_sercom_get_default_pad+0x13e>
    1d08:	4b26      	ldr	r3, [pc, #152]	; (1da4 <_sercom_get_default_pad+0x1a0>)
    1d0a:	e01b      	b.n	1d44 <_sercom_get_default_pad+0x140>
    1d0c:	4b26      	ldr	r3, [pc, #152]	; (1da8 <_sercom_get_default_pad+0x1a4>)
    1d0e:	e019      	b.n	1d44 <_sercom_get_default_pad+0x140>
    1d10:	4b26      	ldr	r3, [pc, #152]	; (1dac <_sercom_get_default_pad+0x1a8>)
    1d12:	e017      	b.n	1d44 <_sercom_get_default_pad+0x140>
    1d14:	4b26      	ldr	r3, [pc, #152]	; (1db0 <_sercom_get_default_pad+0x1ac>)
    1d16:	e015      	b.n	1d44 <_sercom_get_default_pad+0x140>
    1d18:	1cfb      	adds	r3, r7, #3
    1d1a:	781b      	ldrb	r3, [r3, #0]
    1d1c:	2b01      	cmp	r3, #1
    1d1e:	d00a      	beq.n	1d36 <_sercom_get_default_pad+0x132>
    1d20:	dc02      	bgt.n	1d28 <_sercom_get_default_pad+0x124>
    1d22:	2b00      	cmp	r3, #0
    1d24:	d005      	beq.n	1d32 <_sercom_get_default_pad+0x12e>
    1d26:	e00c      	b.n	1d42 <_sercom_get_default_pad+0x13e>
    1d28:	2b02      	cmp	r3, #2
    1d2a:	d006      	beq.n	1d3a <_sercom_get_default_pad+0x136>
    1d2c:	2b03      	cmp	r3, #3
    1d2e:	d006      	beq.n	1d3e <_sercom_get_default_pad+0x13a>
    1d30:	e007      	b.n	1d42 <_sercom_get_default_pad+0x13e>
    1d32:	4b20      	ldr	r3, [pc, #128]	; (1db4 <_sercom_get_default_pad+0x1b0>)
    1d34:	e006      	b.n	1d44 <_sercom_get_default_pad+0x140>
    1d36:	4b20      	ldr	r3, [pc, #128]	; (1db8 <_sercom_get_default_pad+0x1b4>)
    1d38:	e004      	b.n	1d44 <_sercom_get_default_pad+0x140>
    1d3a:	4b20      	ldr	r3, [pc, #128]	; (1dbc <_sercom_get_default_pad+0x1b8>)
    1d3c:	e002      	b.n	1d44 <_sercom_get_default_pad+0x140>
    1d3e:	4b20      	ldr	r3, [pc, #128]	; (1dc0 <_sercom_get_default_pad+0x1bc>)
    1d40:	e000      	b.n	1d44 <_sercom_get_default_pad+0x140>
	}

	Assert(false);
	return 0;
    1d42:	2300      	movs	r3, #0
}
    1d44:	0018      	movs	r0, r3
    1d46:	46bd      	mov	sp, r7
    1d48:	b002      	add	sp, #8
    1d4a:	bd80      	pop	{r7, pc}
    1d4c:	42000c00 	.word	0x42000c00
    1d50:	42000400 	.word	0x42000400
    1d54:	42000800 	.word	0x42000800
    1d58:	42001400 	.word	0x42001400
    1d5c:	42001800 	.word	0x42001800
    1d60:	42001000 	.word	0x42001000
    1d64:	00040003 	.word	0x00040003
    1d68:	00050003 	.word	0x00050003
    1d6c:	00060003 	.word	0x00060003
    1d70:	00070003 	.word	0x00070003
    1d74:	00100002 	.word	0x00100002
    1d78:	00110002 	.word	0x00110002
    1d7c:	00120002 	.word	0x00120002
    1d80:	00130002 	.word	0x00130002
    1d84:	000c0002 	.word	0x000c0002
    1d88:	000d0002 	.word	0x000d0002
    1d8c:	000e0002 	.word	0x000e0002
    1d90:	000f0002 	.word	0x000f0002
    1d94:	00160002 	.word	0x00160002
    1d98:	00170002 	.word	0x00170002
    1d9c:	00180002 	.word	0x00180002
    1da0:	00190002 	.word	0x00190002
    1da4:	00280003 	.word	0x00280003
    1da8:	00290003 	.word	0x00290003
    1dac:	002a0003 	.word	0x002a0003
    1db0:	002b0003 	.word	0x002b0003
    1db4:	00220003 	.word	0x00220003
    1db8:	00230003 	.word	0x00230003
    1dbc:	00200003 	.word	0x00200003
    1dc0:	00210003 	.word	0x00210003

00001dc4 <_sercom_get_sercom_inst_index>:
 *
 * \return Index of given instance.
 */
uint8_t _sercom_get_sercom_inst_index(
		Sercom *const sercom_instance)
{
    1dc4:	b590      	push	{r4, r7, lr}
    1dc6:	b08b      	sub	sp, #44	; 0x2c
    1dc8:	af00      	add	r7, sp, #0
    1dca:	6078      	str	r0, [r7, #4]
	/* Save all available SERCOM instances for compare */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;
    1dcc:	230c      	movs	r3, #12
    1dce:	18fb      	adds	r3, r7, r3
    1dd0:	4a0f      	ldr	r2, [pc, #60]	; (1e10 <_sercom_get_sercom_inst_index+0x4c>)
    1dd2:	ca13      	ldmia	r2!, {r0, r1, r4}
    1dd4:	c313      	stmia	r3!, {r0, r1, r4}
    1dd6:	ca13      	ldmia	r2!, {r0, r1, r4}
    1dd8:	c313      	stmia	r3!, {r0, r1, r4}

	/* Find index for sercom instance */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    1dda:	2300      	movs	r3, #0
    1ddc:	627b      	str	r3, [r7, #36]	; 0x24
    1dde:	e00e      	b.n	1dfe <_sercom_get_sercom_inst_index+0x3a>
		if ((uintptr_t)sercom_instance == (uintptr_t)sercom_instances[i]) {
    1de0:	230c      	movs	r3, #12
    1de2:	18fb      	adds	r3, r7, r3
    1de4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    1de6:	0092      	lsls	r2, r2, #2
    1de8:	58d3      	ldr	r3, [r2, r3]
    1dea:	001a      	movs	r2, r3
    1dec:	687b      	ldr	r3, [r7, #4]
    1dee:	429a      	cmp	r2, r3
    1df0:	d102      	bne.n	1df8 <_sercom_get_sercom_inst_index+0x34>
			return i;
    1df2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    1df4:	b2db      	uxtb	r3, r3
    1df6:	e006      	b.n	1e06 <_sercom_get_sercom_inst_index+0x42>
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    1df8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    1dfa:	3301      	adds	r3, #1
    1dfc:	627b      	str	r3, [r7, #36]	; 0x24
    1dfe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    1e00:	2b05      	cmp	r3, #5
    1e02:	d9ed      	bls.n	1de0 <_sercom_get_sercom_inst_index+0x1c>
		}
	}

	/* Invalid data given */
	Assert(false);
	return 0;
    1e04:	2300      	movs	r3, #0
}
    1e06:	0018      	movs	r0, r3
    1e08:	46bd      	mov	sp, r7
    1e0a:	b00b      	add	sp, #44	; 0x2c
    1e0c:	bd90      	pop	{r4, r7, pc}
    1e0e:	46c0      	nop			; (mov r8, r8)
    1e10:	00007300 	.word	0x00007300

00001e14 <_sercom_default_handler>:
 *
 * \param[in] instance SERCOM instance used.
 */
static void _sercom_default_handler(
		const uint8_t instance)
{
    1e14:	b580      	push	{r7, lr}
    1e16:	b082      	sub	sp, #8
    1e18:	af00      	add	r7, sp, #0
    1e1a:	0002      	movs	r2, r0
    1e1c:	1dfb      	adds	r3, r7, #7
    1e1e:	701a      	strb	r2, [r3, #0]
	Assert(false);
}
    1e20:	46c0      	nop			; (mov r8, r8)
    1e22:	46bd      	mov	sp, r7
    1e24:	b002      	add	sp, #8
    1e26:	bd80      	pop	{r7, pc}

00001e28 <_sercom_set_handler>:
 * \param[in]  interrupt_handler  Pointer to instance callback handler.
 */
void _sercom_set_handler(
		const uint8_t instance,
		const sercom_handler_t interrupt_handler)
{
    1e28:	b580      	push	{r7, lr}
    1e2a:	b084      	sub	sp, #16
    1e2c:	af00      	add	r7, sp, #0
    1e2e:	0002      	movs	r2, r0
    1e30:	6039      	str	r1, [r7, #0]
    1e32:	1dfb      	adds	r3, r7, #7
    1e34:	701a      	strb	r2, [r3, #0]
	/* Initialize handlers with default handler and device instances with 0 */
	if (_handler_table_initialized == false) {
    1e36:	4b13      	ldr	r3, [pc, #76]	; (1e84 <_sercom_set_handler+0x5c>)
    1e38:	781b      	ldrb	r3, [r3, #0]
    1e3a:	2201      	movs	r2, #1
    1e3c:	4053      	eors	r3, r2
    1e3e:	b2db      	uxtb	r3, r3
    1e40:	2b00      	cmp	r3, #0
    1e42:	d015      	beq.n	1e70 <_sercom_set_handler+0x48>
		for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    1e44:	2300      	movs	r3, #0
    1e46:	60fb      	str	r3, [r7, #12]
    1e48:	e00c      	b.n	1e64 <_sercom_set_handler+0x3c>
			_sercom_interrupt_handlers[i] = &_sercom_default_handler;
    1e4a:	4b0f      	ldr	r3, [pc, #60]	; (1e88 <_sercom_set_handler+0x60>)
    1e4c:	68fa      	ldr	r2, [r7, #12]
    1e4e:	0092      	lsls	r2, r2, #2
    1e50:	490e      	ldr	r1, [pc, #56]	; (1e8c <_sercom_set_handler+0x64>)
    1e52:	50d1      	str	r1, [r2, r3]
			_sercom_instances[i] = NULL;
    1e54:	4b0e      	ldr	r3, [pc, #56]	; (1e90 <_sercom_set_handler+0x68>)
    1e56:	68fa      	ldr	r2, [r7, #12]
    1e58:	0092      	lsls	r2, r2, #2
    1e5a:	2100      	movs	r1, #0
    1e5c:	50d1      	str	r1, [r2, r3]
		for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    1e5e:	68fb      	ldr	r3, [r7, #12]
    1e60:	3301      	adds	r3, #1
    1e62:	60fb      	str	r3, [r7, #12]
    1e64:	68fb      	ldr	r3, [r7, #12]
    1e66:	2b05      	cmp	r3, #5
    1e68:	d9ef      	bls.n	1e4a <_sercom_set_handler+0x22>
		}

		_handler_table_initialized = true;
    1e6a:	4b06      	ldr	r3, [pc, #24]	; (1e84 <_sercom_set_handler+0x5c>)
    1e6c:	2201      	movs	r2, #1
    1e6e:	701a      	strb	r2, [r3, #0]
	}

	/* Save interrupt handler */
	_sercom_interrupt_handlers[instance] = interrupt_handler;
    1e70:	1dfb      	adds	r3, r7, #7
    1e72:	781a      	ldrb	r2, [r3, #0]
    1e74:	4b04      	ldr	r3, [pc, #16]	; (1e88 <_sercom_set_handler+0x60>)
    1e76:	0092      	lsls	r2, r2, #2
    1e78:	6839      	ldr	r1, [r7, #0]
    1e7a:	50d1      	str	r1, [r2, r3]
}
    1e7c:	46c0      	nop			; (mov r8, r8)
    1e7e:	46bd      	mov	sp, r7
    1e80:	b004      	add	sp, #16
    1e82:	bd80      	pop	{r7, pc}
    1e84:	2000096a 	.word	0x2000096a
    1e88:	2000096c 	.word	0x2000096c
    1e8c:	00001e15 	.word	0x00001e15
    1e90:	20003314 	.word	0x20003314

00001e94 <_sercom_get_interrupt_vector>:
 * \retval SYSTEM_INTERRUPT_MODULE_SERCOM6
 * \retval SYSTEM_INTERRUPT_MODULE_SERCOM7
 */
enum system_interrupt_vector _sercom_get_interrupt_vector(
		Sercom *const sercom_instance)
{
    1e94:	b590      	push	{r4, r7, lr}
    1e96:	b085      	sub	sp, #20
    1e98:	af00      	add	r7, sp, #0
    1e9a:	6078      	str	r0, [r7, #4]
	const uint8_t sercom_int_vectors[SERCOM_INST_NUM] =
    1e9c:	2308      	movs	r3, #8
    1e9e:	18fb      	adds	r3, r7, r3
    1ea0:	4a0b      	ldr	r2, [pc, #44]	; (1ed0 <_sercom_get_interrupt_vector+0x3c>)
    1ea2:	6811      	ldr	r1, [r2, #0]
    1ea4:	6019      	str	r1, [r3, #0]
    1ea6:	8892      	ldrh	r2, [r2, #4]
    1ea8:	809a      	strh	r2, [r3, #4]
		{
			MREPEAT(SERCOM_INST_NUM, _SERCOM_INTERRUPT_VECT_NUM, ~)
		};

	/* Retrieve the index of the SERCOM being requested */
	uint8_t instance_index = _sercom_get_sercom_inst_index(sercom_instance);
    1eaa:	230f      	movs	r3, #15
    1eac:	18fc      	adds	r4, r7, r3
    1eae:	687b      	ldr	r3, [r7, #4]
    1eb0:	0018      	movs	r0, r3
    1eb2:	4b08      	ldr	r3, [pc, #32]	; (1ed4 <_sercom_get_interrupt_vector+0x40>)
    1eb4:	4798      	blx	r3
    1eb6:	0003      	movs	r3, r0
    1eb8:	7023      	strb	r3, [r4, #0]

	/* Get the vector number from the lookup table for the requested SERCOM */
	return (enum system_interrupt_vector)sercom_int_vectors[instance_index];
    1eba:	230f      	movs	r3, #15
    1ebc:	18fb      	adds	r3, r7, r3
    1ebe:	781b      	ldrb	r3, [r3, #0]
    1ec0:	2208      	movs	r2, #8
    1ec2:	18ba      	adds	r2, r7, r2
    1ec4:	5cd3      	ldrb	r3, [r2, r3]
    1ec6:	b25b      	sxtb	r3, r3
}
    1ec8:	0018      	movs	r0, r3
    1eca:	46bd      	mov	sp, r7
    1ecc:	b005      	add	sp, #20
    1ece:	bd90      	pop	{r4, r7, pc}
    1ed0:	00007318 	.word	0x00007318
    1ed4:	00001dc5 	.word	0x00001dc5

00001ed8 <SERCOM0_Handler>:

/** Auto-generate a set of interrupt handlers for each SERCOM in the device */
MREPEAT(SERCOM_INST_NUM, _SERCOM_INTERRUPT_HANDLER, ~)
    1ed8:	b580      	push	{r7, lr}
    1eda:	af00      	add	r7, sp, #0
    1edc:	4b03      	ldr	r3, [pc, #12]	; (1eec <SERCOM0_Handler+0x14>)
    1ede:	681b      	ldr	r3, [r3, #0]
    1ee0:	2000      	movs	r0, #0
    1ee2:	4798      	blx	r3
    1ee4:	46c0      	nop			; (mov r8, r8)
    1ee6:	46bd      	mov	sp, r7
    1ee8:	bd80      	pop	{r7, pc}
    1eea:	46c0      	nop			; (mov r8, r8)
    1eec:	2000096c 	.word	0x2000096c

00001ef0 <SERCOM1_Handler>:
    1ef0:	b580      	push	{r7, lr}
    1ef2:	af00      	add	r7, sp, #0
    1ef4:	4b03      	ldr	r3, [pc, #12]	; (1f04 <SERCOM1_Handler+0x14>)
    1ef6:	685b      	ldr	r3, [r3, #4]
    1ef8:	2001      	movs	r0, #1
    1efa:	4798      	blx	r3
    1efc:	46c0      	nop			; (mov r8, r8)
    1efe:	46bd      	mov	sp, r7
    1f00:	bd80      	pop	{r7, pc}
    1f02:	46c0      	nop			; (mov r8, r8)
    1f04:	2000096c 	.word	0x2000096c

00001f08 <SERCOM2_Handler>:
    1f08:	b580      	push	{r7, lr}
    1f0a:	af00      	add	r7, sp, #0
    1f0c:	4b03      	ldr	r3, [pc, #12]	; (1f1c <SERCOM2_Handler+0x14>)
    1f0e:	689b      	ldr	r3, [r3, #8]
    1f10:	2002      	movs	r0, #2
    1f12:	4798      	blx	r3
    1f14:	46c0      	nop			; (mov r8, r8)
    1f16:	46bd      	mov	sp, r7
    1f18:	bd80      	pop	{r7, pc}
    1f1a:	46c0      	nop			; (mov r8, r8)
    1f1c:	2000096c 	.word	0x2000096c

00001f20 <SERCOM3_Handler>:
    1f20:	b580      	push	{r7, lr}
    1f22:	af00      	add	r7, sp, #0
    1f24:	4b03      	ldr	r3, [pc, #12]	; (1f34 <SERCOM3_Handler+0x14>)
    1f26:	68db      	ldr	r3, [r3, #12]
    1f28:	2003      	movs	r0, #3
    1f2a:	4798      	blx	r3
    1f2c:	46c0      	nop			; (mov r8, r8)
    1f2e:	46bd      	mov	sp, r7
    1f30:	bd80      	pop	{r7, pc}
    1f32:	46c0      	nop			; (mov r8, r8)
    1f34:	2000096c 	.word	0x2000096c

00001f38 <SERCOM4_Handler>:
    1f38:	b580      	push	{r7, lr}
    1f3a:	af00      	add	r7, sp, #0
    1f3c:	4b03      	ldr	r3, [pc, #12]	; (1f4c <SERCOM4_Handler+0x14>)
    1f3e:	691b      	ldr	r3, [r3, #16]
    1f40:	2004      	movs	r0, #4
    1f42:	4798      	blx	r3
    1f44:	46c0      	nop			; (mov r8, r8)
    1f46:	46bd      	mov	sp, r7
    1f48:	bd80      	pop	{r7, pc}
    1f4a:	46c0      	nop			; (mov r8, r8)
    1f4c:	2000096c 	.word	0x2000096c

00001f50 <SERCOM5_Handler>:
    1f50:	b580      	push	{r7, lr}
    1f52:	af00      	add	r7, sp, #0
    1f54:	4b03      	ldr	r3, [pc, #12]	; (1f64 <SERCOM5_Handler+0x14>)
    1f56:	695b      	ldr	r3, [r3, #20]
    1f58:	2005      	movs	r0, #5
    1f5a:	4798      	blx	r3
    1f5c:	46c0      	nop			; (mov r8, r8)
    1f5e:	46bd      	mov	sp, r7
    1f60:	bd80      	pop	{r7, pc}
    1f62:	46c0      	nop			; (mov r8, r8)
    1f64:	2000096c 	.word	0x2000096c

00001f68 <system_gclk_chan_get_config_defaults>:
{
    1f68:	b580      	push	{r7, lr}
    1f6a:	b082      	sub	sp, #8
    1f6c:	af00      	add	r7, sp, #0
    1f6e:	6078      	str	r0, [r7, #4]
	config->source_generator = GCLK_GENERATOR_0;
    1f70:	687b      	ldr	r3, [r7, #4]
    1f72:	2200      	movs	r2, #0
    1f74:	701a      	strb	r2, [r3, #0]
}
    1f76:	46c0      	nop			; (mov r8, r8)
    1f78:	46bd      	mov	sp, r7
    1f7a:	b002      	add	sp, #8
    1f7c:	bd80      	pop	{r7, pc}
	...

00001f80 <system_apb_clock_set_mask>:
 * \retval STATUS_OK               The clock mask was set successfully
 */
static inline enum status_code system_apb_clock_set_mask(
		const enum system_clock_apb_bus bus,
		const uint32_t mask)
{
    1f80:	b580      	push	{r7, lr}
    1f82:	b082      	sub	sp, #8
    1f84:	af00      	add	r7, sp, #0
    1f86:	0002      	movs	r2, r0
    1f88:	6039      	str	r1, [r7, #0]
    1f8a:	1dfb      	adds	r3, r7, #7
    1f8c:	701a      	strb	r2, [r3, #0]
	switch (bus) {
    1f8e:	1dfb      	adds	r3, r7, #7
    1f90:	781b      	ldrb	r3, [r3, #0]
    1f92:	2b01      	cmp	r3, #1
    1f94:	d00a      	beq.n	1fac <system_apb_clock_set_mask+0x2c>
    1f96:	2b02      	cmp	r3, #2
    1f98:	d00f      	beq.n	1fba <system_apb_clock_set_mask+0x3a>
    1f9a:	2b00      	cmp	r3, #0
    1f9c:	d114      	bne.n	1fc8 <system_apb_clock_set_mask+0x48>
		case SYSTEM_CLOCK_APB_APBA:
			MCLK->APBAMASK.reg |= mask;
    1f9e:	4b0e      	ldr	r3, [pc, #56]	; (1fd8 <system_apb_clock_set_mask+0x58>)
    1fa0:	4a0d      	ldr	r2, [pc, #52]	; (1fd8 <system_apb_clock_set_mask+0x58>)
    1fa2:	6951      	ldr	r1, [r2, #20]
    1fa4:	683a      	ldr	r2, [r7, #0]
    1fa6:	430a      	orrs	r2, r1
    1fa8:	615a      	str	r2, [r3, #20]
			break;
    1faa:	e00f      	b.n	1fcc <system_apb_clock_set_mask+0x4c>

		case SYSTEM_CLOCK_APB_APBB:
			MCLK->APBBMASK.reg |= mask;
    1fac:	4b0a      	ldr	r3, [pc, #40]	; (1fd8 <system_apb_clock_set_mask+0x58>)
    1fae:	4a0a      	ldr	r2, [pc, #40]	; (1fd8 <system_apb_clock_set_mask+0x58>)
    1fb0:	6991      	ldr	r1, [r2, #24]
    1fb2:	683a      	ldr	r2, [r7, #0]
    1fb4:	430a      	orrs	r2, r1
    1fb6:	619a      	str	r2, [r3, #24]
			break;
    1fb8:	e008      	b.n	1fcc <system_apb_clock_set_mask+0x4c>

		case SYSTEM_CLOCK_APB_APBC:
			MCLK->APBCMASK.reg |= mask;
    1fba:	4b07      	ldr	r3, [pc, #28]	; (1fd8 <system_apb_clock_set_mask+0x58>)
    1fbc:	4a06      	ldr	r2, [pc, #24]	; (1fd8 <system_apb_clock_set_mask+0x58>)
    1fbe:	69d1      	ldr	r1, [r2, #28]
    1fc0:	683a      	ldr	r2, [r7, #0]
    1fc2:	430a      	orrs	r2, r1
    1fc4:	61da      	str	r2, [r3, #28]
			break;
    1fc6:	e001      	b.n	1fcc <system_apb_clock_set_mask+0x4c>
		default:
			Assert(false);
			return STATUS_ERR_INVALID_ARG;
    1fc8:	2317      	movs	r3, #23
    1fca:	e000      	b.n	1fce <system_apb_clock_set_mask+0x4e>

	}

	return STATUS_OK;
    1fcc:	2300      	movs	r3, #0
}
    1fce:	0018      	movs	r0, r3
    1fd0:	46bd      	mov	sp, r7
    1fd2:	b002      	add	sp, #8
    1fd4:	bd80      	pop	{r7, pc}
    1fd6:	46c0      	nop			; (mov r8, r8)
    1fd8:	40000800 	.word	0x40000800

00001fdc <system_pinmux_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void system_pinmux_get_config_defaults(
		struct system_pinmux_config *const config)
{
    1fdc:	b580      	push	{r7, lr}
    1fde:	b082      	sub	sp, #8
    1fe0:	af00      	add	r7, sp, #0
    1fe2:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
    1fe4:	687b      	ldr	r3, [r7, #4]
    1fe6:	2280      	movs	r2, #128	; 0x80
    1fe8:	701a      	strb	r2, [r3, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    1fea:	687b      	ldr	r3, [r7, #4]
    1fec:	2200      	movs	r2, #0
    1fee:	705a      	strb	r2, [r3, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
    1ff0:	687b      	ldr	r3, [r7, #4]
    1ff2:	2201      	movs	r2, #1
    1ff4:	709a      	strb	r2, [r3, #2]
	config->powersave    = false;
    1ff6:	687b      	ldr	r3, [r7, #4]
    1ff8:	2200      	movs	r2, #0
    1ffa:	70da      	strb	r2, [r3, #3]
}
    1ffc:	46c0      	nop			; (mov r8, r8)
    1ffe:	46bd      	mov	sp, r7
    2000:	b002      	add	sp, #8
    2002:	bd80      	pop	{r7, pc}

00002004 <system_is_debugger_present>:
 * \retval true  Debugger is connected to the system
 * \retval false Debugger is not connected to the system
 *
 */
static inline bool system_is_debugger_present(void)
{
    2004:	b580      	push	{r7, lr}
    2006:	af00      	add	r7, sp, #0
	return DSU->STATUSB.reg & DSU_STATUSB_DBGPRES;
    2008:	4b05      	ldr	r3, [pc, #20]	; (2020 <system_is_debugger_present+0x1c>)
    200a:	789b      	ldrb	r3, [r3, #2]
    200c:	b2db      	uxtb	r3, r3
    200e:	001a      	movs	r2, r3
    2010:	2302      	movs	r3, #2
    2012:	4013      	ands	r3, r2
    2014:	1e5a      	subs	r2, r3, #1
    2016:	4193      	sbcs	r3, r2
    2018:	b2db      	uxtb	r3, r3
}
    201a:	0018      	movs	r0, r3
    201c:	46bd      	mov	sp, r7
    201e:	bd80      	pop	{r7, pc}
    2020:	41002000 	.word	0x41002000

00002024 <usart_is_syncing>:
{
    2024:	b580      	push	{r7, lr}
    2026:	b084      	sub	sp, #16
    2028:	af00      	add	r7, sp, #0
    202a:	6078      	str	r0, [r7, #4]
	SercomUsart *const usart_hw = &(module->hw->USART);
    202c:	687b      	ldr	r3, [r7, #4]
    202e:	681b      	ldr	r3, [r3, #0]
    2030:	60fb      	str	r3, [r7, #12]
	return (usart_hw->SYNCBUSY.reg);
    2032:	68fb      	ldr	r3, [r7, #12]
    2034:	69db      	ldr	r3, [r3, #28]
    2036:	1e5a      	subs	r2, r3, #1
    2038:	4193      	sbcs	r3, r2
    203a:	b2db      	uxtb	r3, r3
}
    203c:	0018      	movs	r0, r3
    203e:	46bd      	mov	sp, r7
    2040:	b004      	add	sp, #16
    2042:	bd80      	pop	{r7, pc}

00002044 <_usart_wait_for_sync>:
{
    2044:	b580      	push	{r7, lr}
    2046:	b082      	sub	sp, #8
    2048:	af00      	add	r7, sp, #0
    204a:	6078      	str	r0, [r7, #4]
	while (usart_is_syncing(module)) {
    204c:	46c0      	nop			; (mov r8, r8)
    204e:	687b      	ldr	r3, [r7, #4]
    2050:	0018      	movs	r0, r3
    2052:	4b04      	ldr	r3, [pc, #16]	; (2064 <_usart_wait_for_sync+0x20>)
    2054:	4798      	blx	r3
    2056:	1e03      	subs	r3, r0, #0
    2058:	d1f9      	bne.n	204e <_usart_wait_for_sync+0xa>
}
    205a:	46c0      	nop			; (mov r8, r8)
    205c:	46bd      	mov	sp, r7
    205e:	b002      	add	sp, #8
    2060:	bd80      	pop	{r7, pc}
    2062:	46c0      	nop			; (mov r8, r8)
    2064:	00002025 	.word	0x00002025

00002068 <_usart_set_config>:
 * Set Configuration of the USART module
 */
static enum status_code _usart_set_config(
		struct usart_module *const module,
		const struct usart_config *const config)
{
    2068:	b5b0      	push	{r4, r5, r7, lr}
    206a:	b08c      	sub	sp, #48	; 0x30
    206c:	af02      	add	r7, sp, #8
    206e:	6078      	str	r0, [r7, #4]
    2070:	6039      	str	r1, [r7, #0]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    2072:	687b      	ldr	r3, [r7, #4]
    2074:	681b      	ldr	r3, [r3, #0]
    2076:	617b      	str	r3, [r7, #20]

	/* Index for generic clock */
	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    2078:	687b      	ldr	r3, [r7, #4]
    207a:	681b      	ldr	r3, [r3, #0]
    207c:	0018      	movs	r0, r3
    207e:	4bc7      	ldr	r3, [pc, #796]	; (239c <_usart_set_config+0x334>)
    2080:	4798      	blx	r3
    2082:	0003      	movs	r3, r0
    2084:	613b      	str	r3, [r7, #16]
	uint32_t gclk_index;

#if (SAML21) || (SAMR30) || (SAMR34) || (SAMR35) || (SAMC21)
	if (sercom_index == 5) {
    2086:	693b      	ldr	r3, [r7, #16]
    2088:	2b05      	cmp	r3, #5
    208a:	d102      	bne.n	2092 <_usart_set_config+0x2a>
		gclk_index   = SERCOM5_GCLK_ID_CORE;
    208c:	2319      	movs	r3, #25
    208e:	627b      	str	r3, [r7, #36]	; 0x24
    2090:	e002      	b.n	2098 <_usart_set_config+0x30>
	} else {
		gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
    2092:	693b      	ldr	r3, [r7, #16]
    2094:	3313      	adds	r3, #19
    2096:	627b      	str	r3, [r7, #36]	; 0x24
#else
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#endif

	/* Cache new register values to minimize the number of register writes */
	uint32_t ctrla = 0;
    2098:	2300      	movs	r3, #0
    209a:	623b      	str	r3, [r7, #32]
	uint32_t ctrlb = 0;
    209c:	2300      	movs	r3, #0
    209e:	61fb      	str	r3, [r7, #28]
#ifdef FEATURE_USART_ISO7816
	uint32_t ctrlc = 0;
#endif
	uint16_t baud  = 0;
    20a0:	230a      	movs	r3, #10
    20a2:	18fb      	adds	r3, r7, r3
    20a4:	2200      	movs	r2, #0
    20a6:	801a      	strh	r2, [r3, #0]
	uint32_t transfer_mode;

	enum sercom_asynchronous_operation_mode mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
    20a8:	231b      	movs	r3, #27
    20aa:	18fb      	adds	r3, r7, r3
    20ac:	2200      	movs	r2, #0
    20ae:	701a      	strb	r2, [r3, #0]
	enum sercom_asynchronous_sample_num sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
    20b0:	231a      	movs	r3, #26
    20b2:	18fb      	adds	r3, r7, r3
    20b4:	2210      	movs	r2, #16
    20b6:	701a      	strb	r2, [r3, #0]

#ifdef FEATURE_USART_OVER_SAMPLE
	switch (config->sample_rate) {
    20b8:	683b      	ldr	r3, [r7, #0]
    20ba:	8a1b      	ldrh	r3, [r3, #16]
    20bc:	2280      	movs	r2, #128	; 0x80
    20be:	01d2      	lsls	r2, r2, #7
    20c0:	4293      	cmp	r3, r2
    20c2:	d01c      	beq.n	20fe <_usart_set_config+0x96>
    20c4:	2280      	movs	r2, #128	; 0x80
    20c6:	01d2      	lsls	r2, r2, #7
    20c8:	4293      	cmp	r3, r2
    20ca:	dc06      	bgt.n	20da <_usart_set_config+0x72>
    20cc:	2b00      	cmp	r3, #0
    20ce:	d00d      	beq.n	20ec <_usart_set_config+0x84>
    20d0:	2280      	movs	r2, #128	; 0x80
    20d2:	0192      	lsls	r2, r2, #6
    20d4:	4293      	cmp	r3, r2
    20d6:	d024      	beq.n	2122 <_usart_set_config+0xba>
    20d8:	e035      	b.n	2146 <_usart_set_config+0xde>
    20da:	22c0      	movs	r2, #192	; 0xc0
    20dc:	01d2      	lsls	r2, r2, #7
    20de:	4293      	cmp	r3, r2
    20e0:	d028      	beq.n	2134 <_usart_set_config+0xcc>
    20e2:	2280      	movs	r2, #128	; 0x80
    20e4:	0212      	lsls	r2, r2, #8
    20e6:	4293      	cmp	r3, r2
    20e8:	d012      	beq.n	2110 <_usart_set_config+0xa8>
    20ea:	e02c      	b.n	2146 <_usart_set_config+0xde>
		case USART_SAMPLE_RATE_16X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
    20ec:	231b      	movs	r3, #27
    20ee:	18fb      	adds	r3, r7, r3
    20f0:	2200      	movs	r2, #0
    20f2:	701a      	strb	r2, [r3, #0]
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
    20f4:	231a      	movs	r3, #26
    20f6:	18fb      	adds	r3, r7, r3
    20f8:	2210      	movs	r2, #16
    20fa:	701a      	strb	r2, [r3, #0]
			break;
    20fc:	e023      	b.n	2146 <_usart_set_config+0xde>
		case USART_SAMPLE_RATE_8X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
    20fe:	231b      	movs	r3, #27
    2100:	18fb      	adds	r3, r7, r3
    2102:	2200      	movs	r2, #0
    2104:	701a      	strb	r2, [r3, #0]
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_8;
    2106:	231a      	movs	r3, #26
    2108:	18fb      	adds	r3, r7, r3
    210a:	2208      	movs	r2, #8
    210c:	701a      	strb	r2, [r3, #0]
			break;
    210e:	e01a      	b.n	2146 <_usart_set_config+0xde>
		case USART_SAMPLE_RATE_3X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
    2110:	231b      	movs	r3, #27
    2112:	18fb      	adds	r3, r7, r3
    2114:	2200      	movs	r2, #0
    2116:	701a      	strb	r2, [r3, #0]
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_3;
    2118:	231a      	movs	r3, #26
    211a:	18fb      	adds	r3, r7, r3
    211c:	2203      	movs	r2, #3
    211e:	701a      	strb	r2, [r3, #0]
			break;
    2120:	e011      	b.n	2146 <_usart_set_config+0xde>
		case USART_SAMPLE_RATE_16X_FRACTIONAL:
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
    2122:	231b      	movs	r3, #27
    2124:	18fb      	adds	r3, r7, r3
    2126:	2201      	movs	r2, #1
    2128:	701a      	strb	r2, [r3, #0]
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
    212a:	231a      	movs	r3, #26
    212c:	18fb      	adds	r3, r7, r3
    212e:	2210      	movs	r2, #16
    2130:	701a      	strb	r2, [r3, #0]
			break;
    2132:	e008      	b.n	2146 <_usart_set_config+0xde>
		case USART_SAMPLE_RATE_8X_FRACTIONAL:
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
    2134:	231b      	movs	r3, #27
    2136:	18fb      	adds	r3, r7, r3
    2138:	2201      	movs	r2, #1
    213a:	701a      	strb	r2, [r3, #0]
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_8;
    213c:	231a      	movs	r3, #26
    213e:	18fb      	adds	r3, r7, r3
    2140:	2208      	movs	r2, #8
    2142:	701a      	strb	r2, [r3, #0]
			break;
    2144:	46c0      	nop			; (mov r8, r8)
	}
#endif

	/* Set data order, internal muxing, and clock polarity */
	ctrla = (uint32_t)config->data_order |
    2146:	683b      	ldr	r3, [r7, #0]
    2148:	681a      	ldr	r2, [r3, #0]
		(uint32_t)config->mux_setting |
    214a:	683b      	ldr	r3, [r7, #0]
    214c:	68db      	ldr	r3, [r3, #12]
	ctrla = (uint32_t)config->data_order |
    214e:	431a      	orrs	r2, r3
	#ifdef FEATURE_USART_OVER_SAMPLE
		config->sample_adjustment |
    2150:	683b      	ldr	r3, [r7, #0]
    2152:	695b      	ldr	r3, [r3, #20]
		(uint32_t)config->mux_setting |
    2154:	4313      	orrs	r3, r2
		config->sample_rate |
    2156:	683a      	ldr	r2, [r7, #0]
    2158:	8a12      	ldrh	r2, [r2, #16]
		config->sample_adjustment |
    215a:	4313      	orrs	r3, r2
	#endif
	#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
		(config->immediate_buffer_overflow_notification << SERCOM_USART_CTRLA_IBON_Pos) |
    215c:	683a      	ldr	r2, [r7, #0]
    215e:	7e12      	ldrb	r2, [r2, #24]
    2160:	0212      	lsls	r2, r2, #8
		config->sample_rate |
    2162:	4313      	orrs	r3, r2
	#endif
		(config->clock_polarity_inverted << SERCOM_USART_CTRLA_CPOL_Pos);
    2164:	683a      	ldr	r2, [r7, #0]
    2166:	212e      	movs	r1, #46	; 0x2e
    2168:	5c52      	ldrb	r2, [r2, r1]
    216a:	0752      	lsls	r2, r2, #29
	ctrla = (uint32_t)config->data_order |
    216c:	4313      	orrs	r3, r2
    216e:	623b      	str	r3, [r7, #32]

	enum status_code status_code = STATUS_OK;
    2170:	2319      	movs	r3, #25
    2172:	18fb      	adds	r3, r7, r3
    2174:	2200      	movs	r2, #0
    2176:	701a      	strb	r2, [r3, #0]

	transfer_mode = (uint32_t)config->transfer_mode;
    2178:	683b      	ldr	r3, [r7, #0]
    217a:	685b      	ldr	r3, [r3, #4]
    217c:	60fb      	str	r3, [r7, #12]
#ifdef FEATURE_USART_ISO7816
	if(config->iso7816_config.enabled) {
		baud = config->baudrate;
	} else {
#endif
	switch (transfer_mode)
    217e:	68fb      	ldr	r3, [r7, #12]
    2180:	2b00      	cmp	r3, #0
    2182:	d01e      	beq.n	21c2 <_usart_set_config+0x15a>
    2184:	2280      	movs	r2, #128	; 0x80
    2186:	0552      	lsls	r2, r2, #21
    2188:	4293      	cmp	r3, r2
    218a:	d14f      	bne.n	222c <_usart_set_config+0x1c4>
	{
		case USART_TRANSFER_SYNCHRONOUSLY:
			if (!config->use_external_clock) {
    218c:	683b      	ldr	r3, [r7, #0]
    218e:	222f      	movs	r2, #47	; 0x2f
    2190:	5c9b      	ldrb	r3, [r3, r2]
    2192:	2201      	movs	r2, #1
    2194:	4053      	eors	r3, r2
    2196:	b2db      	uxtb	r3, r3
    2198:	2b00      	cmp	r3, #0
    219a:	d046      	beq.n	222a <_usart_set_config+0x1c2>
				status_code = _sercom_get_sync_baud_val(config->baudrate,
    219c:	683b      	ldr	r3, [r7, #0]
    219e:	6a9d      	ldr	r5, [r3, #40]	; 0x28
    21a0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    21a2:	b2db      	uxtb	r3, r3
    21a4:	0018      	movs	r0, r3
    21a6:	4b7e      	ldr	r3, [pc, #504]	; (23a0 <_usart_set_config+0x338>)
    21a8:	4798      	blx	r3
    21aa:	0001      	movs	r1, r0
    21ac:	2319      	movs	r3, #25
    21ae:	18fc      	adds	r4, r7, r3
    21b0:	230a      	movs	r3, #10
    21b2:	18fb      	adds	r3, r7, r3
    21b4:	001a      	movs	r2, r3
    21b6:	0028      	movs	r0, r5
    21b8:	4b7a      	ldr	r3, [pc, #488]	; (23a4 <_usart_set_config+0x33c>)
    21ba:	4798      	blx	r3
    21bc:	0003      	movs	r3, r0
    21be:	7023      	strb	r3, [r4, #0]
						system_gclk_chan_get_hz(gclk_index), &baud);
			}

			break;
    21c0:	e033      	b.n	222a <_usart_set_config+0x1c2>

		case USART_TRANSFER_ASYNCHRONOUSLY:
			if (config->use_external_clock) {
    21c2:	683b      	ldr	r3, [r7, #0]
    21c4:	222f      	movs	r2, #47	; 0x2f
    21c6:	5c9b      	ldrb	r3, [r3, r2]
    21c8:	2b00      	cmp	r3, #0
    21ca:	d014      	beq.n	21f6 <_usart_set_config+0x18e>
				status_code =
						_sercom_get_async_baud_val(config->baudrate,
    21cc:	683b      	ldr	r3, [r7, #0]
    21ce:	6a98      	ldr	r0, [r3, #40]	; 0x28
    21d0:	683b      	ldr	r3, [r7, #0]
    21d2:	6b19      	ldr	r1, [r3, #48]	; 0x30
				status_code =
    21d4:	2319      	movs	r3, #25
    21d6:	18fc      	adds	r4, r7, r3
    21d8:	231b      	movs	r3, #27
    21da:	18fb      	adds	r3, r7, r3
    21dc:	781d      	ldrb	r5, [r3, #0]
    21de:	230a      	movs	r3, #10
    21e0:	18fa      	adds	r2, r7, r3
    21e2:	231a      	movs	r3, #26
    21e4:	18fb      	adds	r3, r7, r3
    21e6:	781b      	ldrb	r3, [r3, #0]
    21e8:	9300      	str	r3, [sp, #0]
    21ea:	002b      	movs	r3, r5
    21ec:	4d6e      	ldr	r5, [pc, #440]	; (23a8 <_usart_set_config+0x340>)
    21ee:	47a8      	blx	r5
    21f0:	0003      	movs	r3, r0
    21f2:	7023      	strb	r3, [r4, #0]
				status_code =
						_sercom_get_async_baud_val(config->baudrate,
							system_gclk_chan_get_hz(gclk_index), &baud, mode, sample_num);
			}

			break;
    21f4:	e01a      	b.n	222c <_usart_set_config+0x1c4>
						_sercom_get_async_baud_val(config->baudrate,
    21f6:	683b      	ldr	r3, [r7, #0]
    21f8:	6a9d      	ldr	r5, [r3, #40]	; 0x28
    21fa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    21fc:	b2db      	uxtb	r3, r3
    21fe:	0018      	movs	r0, r3
    2200:	4b67      	ldr	r3, [pc, #412]	; (23a0 <_usart_set_config+0x338>)
    2202:	4798      	blx	r3
				status_code =
    2204:	2319      	movs	r3, #25
    2206:	18fc      	adds	r4, r7, r3
    2208:	231b      	movs	r3, #27
    220a:	18fb      	adds	r3, r7, r3
    220c:	7819      	ldrb	r1, [r3, #0]
    220e:	230a      	movs	r3, #10
    2210:	18fa      	adds	r2, r7, r3
    2212:	231a      	movs	r3, #26
    2214:	18fb      	adds	r3, r7, r3
    2216:	781b      	ldrb	r3, [r3, #0]
    2218:	9300      	str	r3, [sp, #0]
    221a:	000b      	movs	r3, r1
    221c:	0001      	movs	r1, r0
    221e:	0028      	movs	r0, r5
    2220:	4d61      	ldr	r5, [pc, #388]	; (23a8 <_usart_set_config+0x340>)
    2222:	47a8      	blx	r5
    2224:	0003      	movs	r3, r0
    2226:	7023      	strb	r3, [r4, #0]
			break;
    2228:	e000      	b.n	222c <_usart_set_config+0x1c4>
			break;
    222a:	46c0      	nop			; (mov r8, r8)
	}

	/* Check if calculating the baudrate failed */
	if (status_code != STATUS_OK) {
    222c:	2319      	movs	r3, #25
    222e:	18fb      	adds	r3, r7, r3
    2230:	781b      	ldrb	r3, [r3, #0]
    2232:	2b00      	cmp	r3, #0
    2234:	d003      	beq.n	223e <_usart_set_config+0x1d6>
		/* Abort */
		return status_code;
    2236:	2319      	movs	r3, #25
    2238:	18fb      	adds	r3, r7, r3
    223a:	781b      	ldrb	r3, [r3, #0]
    223c:	e0a9      	b.n	2392 <_usart_set_config+0x32a>
#ifdef FEATURE_USART_ISO7816
	}
#endif

#ifdef FEATURE_USART_IRDA
	if(config->encoding_format_enable) {
    223e:	683b      	ldr	r3, [r7, #0]
    2240:	7e5b      	ldrb	r3, [r3, #25]
    2242:	2b00      	cmp	r3, #0
    2244:	d003      	beq.n	224e <_usart_set_config+0x1e6>
		usart_hw->RXPL.reg = config->receive_pulse_length;
    2246:	683b      	ldr	r3, [r7, #0]
    2248:	7e9a      	ldrb	r2, [r3, #26]
    224a:	697b      	ldr	r3, [r7, #20]
    224c:	739a      	strb	r2, [r3, #14]
	}
#endif

	/*Set baud val */
	usart_hw->BAUD.reg = baud;
    224e:	230a      	movs	r3, #10
    2250:	18fb      	adds	r3, r7, r3
    2252:	881a      	ldrh	r2, [r3, #0]
    2254:	697b      	ldr	r3, [r7, #20]
    2256:	819a      	strh	r2, [r3, #12]

	/* Set sample mode */
	ctrla |= transfer_mode;
    2258:	6a3a      	ldr	r2, [r7, #32]
    225a:	68fb      	ldr	r3, [r7, #12]
    225c:	4313      	orrs	r3, r2
    225e:	623b      	str	r3, [r7, #32]

	if (config->use_external_clock == false) {
    2260:	683b      	ldr	r3, [r7, #0]
    2262:	222f      	movs	r2, #47	; 0x2f
    2264:	5c9b      	ldrb	r3, [r3, r2]
    2266:	2201      	movs	r2, #1
    2268:	4053      	eors	r3, r2
    226a:	b2db      	uxtb	r3, r3
    226c:	2b00      	cmp	r3, #0
    226e:	d003      	beq.n	2278 <_usart_set_config+0x210>
		ctrla |= SERCOM_USART_CTRLA_MODE(0x1);
    2270:	6a3b      	ldr	r3, [r7, #32]
    2272:	2204      	movs	r2, #4
    2274:	4313      	orrs	r3, r2
    2276:	623b      	str	r3, [r7, #32]
	}

	/* Set stopbits and enable transceivers */
	ctrlb =  
		#ifdef FEATURE_USART_IRDA
			(config->encoding_format_enable << SERCOM_USART_CTRLB_ENC_Pos) |
    2278:	683b      	ldr	r3, [r7, #0]
    227a:	7e5b      	ldrb	r3, [r3, #25]
    227c:	029a      	lsls	r2, r3, #10
		#endif
		#ifdef FEATURE_USART_START_FRAME_DECTION
			(config->start_frame_detection_enable << SERCOM_USART_CTRLB_SFDE_Pos) |
    227e:	683b      	ldr	r3, [r7, #0]
    2280:	2124      	movs	r1, #36	; 0x24
    2282:	5c5b      	ldrb	r3, [r3, r1]
    2284:	025b      	lsls	r3, r3, #9
			(config->encoding_format_enable << SERCOM_USART_CTRLB_ENC_Pos) |
    2286:	431a      	orrs	r2, r3
		#endif
		#ifdef FEATURE_USART_COLLISION_DECTION
			(config->collision_detection_enable << SERCOM_USART_CTRLB_COLDEN_Pos) |
    2288:	683b      	ldr	r3, [r7, #0]
    228a:	2126      	movs	r1, #38	; 0x26
    228c:	5c5b      	ldrb	r3, [r3, r1]
    228e:	021b      	lsls	r3, r3, #8
			(config->start_frame_detection_enable << SERCOM_USART_CTRLB_SFDE_Pos) |
    2290:	431a      	orrs	r2, r3
		#endif
			(config->receiver_enable << SERCOM_USART_CTRLB_RXEN_Pos) |
    2292:	683b      	ldr	r3, [r7, #0]
    2294:	212c      	movs	r1, #44	; 0x2c
    2296:	5c5b      	ldrb	r3, [r3, r1]
    2298:	045b      	lsls	r3, r3, #17
			(config->collision_detection_enable << SERCOM_USART_CTRLB_COLDEN_Pos) |
    229a:	431a      	orrs	r2, r3
			(config->transmitter_enable << SERCOM_USART_CTRLB_TXEN_Pos);
    229c:	683b      	ldr	r3, [r7, #0]
    229e:	212d      	movs	r1, #45	; 0x2d
    22a0:	5c5b      	ldrb	r3, [r3, r1]
    22a2:	041b      	lsls	r3, r3, #16
			(config->receiver_enable << SERCOM_USART_CTRLB_RXEN_Pos) |
    22a4:	4313      	orrs	r3, r2
	ctrlb =  
    22a6:	61fb      	str	r3, [r7, #28]
				ctrlb |= USART_STOPBITS_1;
				break;		
		}
	} else {
#endif
	ctrlb |= (uint32_t)config->stopbits;
    22a8:	683b      	ldr	r3, [r7, #0]
    22aa:	7a9b      	ldrb	r3, [r3, #10]
    22ac:	001a      	movs	r2, r3
    22ae:	69fb      	ldr	r3, [r7, #28]
    22b0:	4313      	orrs	r3, r2
    22b2:	61fb      	str	r3, [r7, #28]
	ctrlb |= (uint32_t)config->character_size;
    22b4:	683b      	ldr	r3, [r7, #0]
    22b6:	7adb      	ldrb	r3, [r3, #11]
    22b8:	001a      	movs	r2, r3
    22ba:	69fb      	ldr	r3, [r7, #28]
    22bc:	4313      	orrs	r3, r2
    22be:	61fb      	str	r3, [r7, #28]
	/* Check parity mode bits */
	if (config->parity != USART_PARITY_NONE) {
    22c0:	683b      	ldr	r3, [r7, #0]
    22c2:	891b      	ldrh	r3, [r3, #8]
    22c4:	2bff      	cmp	r3, #255	; 0xff
    22c6:	d00b      	beq.n	22e0 <_usart_set_config+0x278>
		ctrla |= SERCOM_USART_CTRLA_FORM(1);
    22c8:	6a3b      	ldr	r3, [r7, #32]
    22ca:	2280      	movs	r2, #128	; 0x80
    22cc:	0452      	lsls	r2, r2, #17
    22ce:	4313      	orrs	r3, r2
    22d0:	623b      	str	r3, [r7, #32]
		ctrlb |= config->parity;
    22d2:	683b      	ldr	r3, [r7, #0]
    22d4:	891b      	ldrh	r3, [r3, #8]
    22d6:	001a      	movs	r2, r3
    22d8:	69fb      	ldr	r3, [r7, #28]
    22da:	4313      	orrs	r3, r2
    22dc:	61fb      	str	r3, [r7, #28]
    22de:	e008      	b.n	22f2 <_usart_set_config+0x28a>
	} else {
#ifdef FEATURE_USART_LIN_SLAVE
		if(config->lin_slave_enable) {
    22e0:	683b      	ldr	r3, [r7, #0]
    22e2:	7edb      	ldrb	r3, [r3, #27]
    22e4:	2b00      	cmp	r3, #0
    22e6:	d004      	beq.n	22f2 <_usart_set_config+0x28a>
			ctrla |= SERCOM_USART_CTRLA_FORM(0x4);
    22e8:	6a3b      	ldr	r3, [r7, #32]
    22ea:	2280      	movs	r2, #128	; 0x80
    22ec:	04d2      	lsls	r2, r2, #19
    22ee:	4313      	orrs	r3, r2
    22f0:	623b      	str	r3, [r7, #32]
#ifdef FEATURE_USART_ISO7816
	}
#endif

#ifdef FEATURE_USART_LIN_MASTER
	usart_hw->CTRLC.reg = ((usart_hw->CTRLC.reg) & SERCOM_USART_CTRLC_GTIME_Msk)
    22f2:	697b      	ldr	r3, [r7, #20]
    22f4:	689b      	ldr	r3, [r3, #8]
    22f6:	2207      	movs	r2, #7
    22f8:	4013      	ands	r3, r2
						| config->lin_header_delay
    22fa:	683a      	ldr	r2, [r7, #0]
    22fc:	8c12      	ldrh	r2, [r2, #32]
    22fe:	4313      	orrs	r3, r2
						| config->lin_break_length;
    2300:	683a      	ldr	r2, [r7, #0]
    2302:	8c52      	ldrh	r2, [r2, #34]	; 0x22
    2304:	431a      	orrs	r2, r3
	usart_hw->CTRLC.reg = ((usart_hw->CTRLC.reg) & SERCOM_USART_CTRLC_GTIME_Msk)
    2306:	697b      	ldr	r3, [r7, #20]
    2308:	609a      	str	r2, [r3, #8]

	if (config->lin_node != LIN_INVALID_MODE) {
    230a:	683b      	ldr	r3, [r7, #0]
    230c:	69db      	ldr	r3, [r3, #28]
    230e:	2b00      	cmp	r3, #0
    2310:	d008      	beq.n	2324 <_usart_set_config+0x2bc>
		ctrla &= ~(SERCOM_USART_CTRLA_FORM(0xf));
    2312:	6a3b      	ldr	r3, [r7, #32]
    2314:	4a25      	ldr	r2, [pc, #148]	; (23ac <_usart_set_config+0x344>)
    2316:	4013      	ands	r3, r2
    2318:	623b      	str	r3, [r7, #32]
		ctrla |= config->lin_node;
    231a:	683b      	ldr	r3, [r7, #0]
    231c:	69db      	ldr	r3, [r3, #28]
    231e:	6a3a      	ldr	r2, [r7, #32]
    2320:	4313      	orrs	r3, r2
    2322:	623b      	str	r3, [r7, #32]
	}
#endif

	/* Set whether module should run in standby. */
	if (config->run_in_standby || system_is_debugger_present()) {
    2324:	683b      	ldr	r3, [r7, #0]
    2326:	2234      	movs	r2, #52	; 0x34
    2328:	5c9b      	ldrb	r3, [r3, r2]
    232a:	2b00      	cmp	r3, #0
    232c:	d103      	bne.n	2336 <_usart_set_config+0x2ce>
    232e:	4b20      	ldr	r3, [pc, #128]	; (23b0 <_usart_set_config+0x348>)
    2330:	4798      	blx	r3
    2332:	1e03      	subs	r3, r0, #0
    2334:	d003      	beq.n	233e <_usart_set_config+0x2d6>
		ctrla |= SERCOM_USART_CTRLA_RUNSTDBY;
    2336:	6a3b      	ldr	r3, [r7, #32]
    2338:	2280      	movs	r2, #128	; 0x80
    233a:	4313      	orrs	r3, r2
    233c:	623b      	str	r3, [r7, #32]
	}

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);
    233e:	687b      	ldr	r3, [r7, #4]
    2340:	0018      	movs	r0, r3
    2342:	4b1c      	ldr	r3, [pc, #112]	; (23b4 <_usart_set_config+0x34c>)
    2344:	4798      	blx	r3

	/* Write configuration to CTRLB */
	usart_hw->CTRLB.reg = ctrlb;
    2346:	697b      	ldr	r3, [r7, #20]
    2348:	69fa      	ldr	r2, [r7, #28]
    234a:	605a      	str	r2, [r3, #4]

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);
    234c:	687b      	ldr	r3, [r7, #4]
    234e:	0018      	movs	r0, r3
    2350:	4b18      	ldr	r3, [pc, #96]	; (23b4 <_usart_set_config+0x34c>)
    2352:	4798      	blx	r3

	/* Write configuration to CTRLA */
	usart_hw->CTRLA.reg = ctrla;
    2354:	697b      	ldr	r3, [r7, #20]
    2356:	6a3a      	ldr	r2, [r7, #32]
    2358:	601a      	str	r2, [r3, #0]

#ifdef FEATURE_USART_RS485
	if ((usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_FORM_Msk) != \
    235a:	697b      	ldr	r3, [r7, #20]
    235c:	681a      	ldr	r2, [r3, #0]
    235e:	23f0      	movs	r3, #240	; 0xf0
    2360:	051b      	lsls	r3, r3, #20
    2362:	401a      	ands	r2, r3
    2364:	23e0      	movs	r3, #224	; 0xe0
    2366:	04db      	lsls	r3, r3, #19
    2368:	429a      	cmp	r2, r3
    236a:	d011      	beq.n	2390 <_usart_set_config+0x328>
		SERCOM_USART_CTRLA_FORM(0x07)) {
		usart_hw->CTRLC.reg &= ~(SERCOM_USART_CTRLC_GTIME(0x7));
    236c:	697b      	ldr	r3, [r7, #20]
    236e:	689b      	ldr	r3, [r3, #8]
    2370:	2207      	movs	r2, #7
    2372:	4393      	bics	r3, r2
    2374:	001a      	movs	r2, r3
    2376:	697b      	ldr	r3, [r7, #20]
    2378:	609a      	str	r2, [r3, #8]
		usart_hw->CTRLC.reg |= SERCOM_USART_CTRLC_GTIME(config->rs485_guard_time);
    237a:	697b      	ldr	r3, [r7, #20]
    237c:	689a      	ldr	r2, [r3, #8]
    237e:	683b      	ldr	r3, [r7, #0]
    2380:	2125      	movs	r1, #37	; 0x25
    2382:	5c5b      	ldrb	r3, [r3, r1]
    2384:	0019      	movs	r1, r3
    2386:	2307      	movs	r3, #7
    2388:	400b      	ands	r3, r1
    238a:	431a      	orrs	r2, r3
    238c:	697b      	ldr	r3, [r7, #20]
    238e:	609a      	str	r2, [r3, #8]
		_usart_wait_for_sync(module);
		usart_hw->CTRLC.reg = ctrlc;
	}
#endif

	return STATUS_OK;
    2390:	2300      	movs	r3, #0
}
    2392:	0018      	movs	r0, r3
    2394:	46bd      	mov	sp, r7
    2396:	b00a      	add	sp, #40	; 0x28
    2398:	bdb0      	pop	{r4, r5, r7, pc}
    239a:	46c0      	nop			; (mov r8, r8)
    239c:	00001dc5 	.word	0x00001dc5
    23a0:	00006749 	.word	0x00006749
    23a4:	0000193b 	.word	0x0000193b
    23a8:	000019b9 	.word	0x000019b9
    23ac:	f0ffffff 	.word	0xf0ffffff
    23b0:	00002005 	.word	0x00002005
    23b4:	00002045 	.word	0x00002045

000023b8 <usart_init>:
 */
enum status_code usart_init(
		struct usart_module *const module,
		Sercom *const hw,
		const struct usart_config *const config)
{
    23b8:	b590      	push	{r4, r7, lr}
    23ba:	b093      	sub	sp, #76	; 0x4c
    23bc:	af00      	add	r7, sp, #0
    23be:	60f8      	str	r0, [r7, #12]
    23c0:	60b9      	str	r1, [r7, #8]
    23c2:	607a      	str	r2, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(hw);
	Assert(config);

	enum status_code status_code = STATUS_OK;
    23c4:	2337      	movs	r3, #55	; 0x37
    23c6:	18fb      	adds	r3, r7, r3
    23c8:	2200      	movs	r2, #0
    23ca:	701a      	strb	r2, [r3, #0]

	/* Assign module pointer to software instance struct */
	module->hw = hw;
    23cc:	68fb      	ldr	r3, [r7, #12]
    23ce:	68ba      	ldr	r2, [r7, #8]
    23d0:	601a      	str	r2, [r3, #0]

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    23d2:	68fb      	ldr	r3, [r7, #12]
    23d4:	681b      	ldr	r3, [r3, #0]
    23d6:	633b      	str	r3, [r7, #48]	; 0x30

	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    23d8:	68fb      	ldr	r3, [r7, #12]
    23da:	681b      	ldr	r3, [r3, #0]
    23dc:	0018      	movs	r0, r3
    23de:	4b89      	ldr	r3, [pc, #548]	; (2604 <usart_init+0x24c>)
    23e0:	4798      	blx	r3
    23e2:	0003      	movs	r3, r0
    23e4:	62fb      	str	r3, [r7, #44]	; 0x2c
	} else {
		pm_index     = sercom_index + MCLK_APBCMASK_SERCOM0_Pos;
		gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
	}
#elif (SAMC21)
	pm_index	= sercom_index + MCLK_APBCMASK_SERCOM0_Pos;
    23e6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    23e8:	3301      	adds	r3, #1
    23ea:	62bb      	str	r3, [r7, #40]	; 0x28
	
	if (sercom_index == 5){
    23ec:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    23ee:	2b05      	cmp	r3, #5
    23f0:	d102      	bne.n	23f8 <usart_init+0x40>
		gclk_index	= SERCOM5_GCLK_ID_CORE;
    23f2:	2319      	movs	r3, #25
    23f4:	647b      	str	r3, [r7, #68]	; 0x44
    23f6:	e002      	b.n	23fe <usart_init+0x46>
    } else {
    	gclk_index	= sercom_index + SERCOM0_GCLK_ID_CORE;
    23f8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    23fa:	3313      	adds	r3, #19
    23fc:	647b      	str	r3, [r7, #68]	; 0x44
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#endif

	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_SWRST) {
    23fe:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    2400:	681b      	ldr	r3, [r3, #0]
    2402:	2201      	movs	r2, #1
    2404:	4013      	ands	r3, r2
    2406:	d001      	beq.n	240c <usart_init+0x54>
		/* The module is busy resetting itself */
		return STATUS_BUSY;
    2408:	2305      	movs	r3, #5
    240a:	e0f7      	b.n	25fc <usart_init+0x244>
	}

	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_ENABLE) {
    240c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    240e:	681b      	ldr	r3, [r3, #0]
    2410:	2202      	movs	r2, #2
    2412:	4013      	ands	r3, r2
    2414:	d001      	beq.n	241a <usart_init+0x62>
		/* Check the module is enabled */
		return STATUS_ERR_DENIED;
    2416:	231c      	movs	r3, #28
    2418:	e0f0      	b.n	25fc <usart_init+0x244>
		system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBD, 1 << pm_index);
	} else {
		system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, 1 << pm_index);	
	}
#else
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, 1 << pm_index);
    241a:	2201      	movs	r2, #1
    241c:	6abb      	ldr	r3, [r7, #40]	; 0x28
    241e:	409a      	lsls	r2, r3
    2420:	0013      	movs	r3, r2
    2422:	0019      	movs	r1, r3
    2424:	2002      	movs	r0, #2
    2426:	4b78      	ldr	r3, [pc, #480]	; (2608 <usart_init+0x250>)
    2428:	4798      	blx	r3
#endif

	/* Set up the GCLK for the module */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
    242a:	2324      	movs	r3, #36	; 0x24
    242c:	18fb      	adds	r3, r7, r3
    242e:	0018      	movs	r0, r3
    2430:	4b76      	ldr	r3, [pc, #472]	; (260c <usart_init+0x254>)
    2432:	4798      	blx	r3
	gclk_chan_conf.source_generator = config->generator_source;
    2434:	687b      	ldr	r3, [r7, #4]
    2436:	2235      	movs	r2, #53	; 0x35
    2438:	5c9a      	ldrb	r2, [r3, r2]
    243a:	2324      	movs	r3, #36	; 0x24
    243c:	18fb      	adds	r3, r7, r3
    243e:	701a      	strb	r2, [r3, #0]
	system_gclk_chan_set_config(gclk_index, &gclk_chan_conf);
    2440:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    2442:	b2db      	uxtb	r3, r3
    2444:	2224      	movs	r2, #36	; 0x24
    2446:	18ba      	adds	r2, r7, r2
    2448:	0011      	movs	r1, r2
    244a:	0018      	movs	r0, r3
    244c:	4b70      	ldr	r3, [pc, #448]	; (2610 <usart_init+0x258>)
    244e:	4798      	blx	r3
	system_gclk_chan_enable(gclk_index);
    2450:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    2452:	b2db      	uxtb	r3, r3
    2454:	0018      	movs	r0, r3
    2456:	4b6f      	ldr	r3, [pc, #444]	; (2614 <usart_init+0x25c>)
    2458:	4798      	blx	r3
	sercom_set_gclk_generator(config->generator_source, false);
    245a:	687b      	ldr	r3, [r7, #4]
    245c:	2235      	movs	r2, #53	; 0x35
    245e:	5c9b      	ldrb	r3, [r3, r2]
    2460:	2100      	movs	r1, #0
    2462:	0018      	movs	r0, r3
    2464:	4b6c      	ldr	r3, [pc, #432]	; (2618 <usart_init+0x260>)
    2466:	4798      	blx	r3

	/* Set character size */
	module->character_size = config->character_size;
    2468:	687b      	ldr	r3, [r7, #4]
    246a:	7ada      	ldrb	r2, [r3, #11]
    246c:	68fb      	ldr	r3, [r7, #12]
    246e:	715a      	strb	r2, [r3, #5]

	/* Set transmitter and receiver status */
	module->receiver_enabled = config->receiver_enable;
    2470:	687b      	ldr	r3, [r7, #4]
    2472:	222c      	movs	r2, #44	; 0x2c
    2474:	5c9a      	ldrb	r2, [r3, r2]
    2476:	68fb      	ldr	r3, [r7, #12]
    2478:	719a      	strb	r2, [r3, #6]
	module->transmitter_enabled = config->transmitter_enable;
    247a:	687b      	ldr	r3, [r7, #4]
    247c:	222d      	movs	r2, #45	; 0x2d
    247e:	5c9a      	ldrb	r2, [r3, r2]
    2480:	68fb      	ldr	r3, [r7, #12]
    2482:	71da      	strb	r2, [r3, #7]

#ifdef FEATURE_USART_LIN_SLAVE
	module->lin_slave_enabled = config->lin_slave_enable;
    2484:	687b      	ldr	r3, [r7, #4]
    2486:	7eda      	ldrb	r2, [r3, #27]
    2488:	68fb      	ldr	r3, [r7, #12]
    248a:	721a      	strb	r2, [r3, #8]
#endif
#ifdef FEATURE_USART_START_FRAME_DECTION
	module->start_frame_detection_enabled = config->start_frame_detection_enable;
    248c:	687b      	ldr	r3, [r7, #4]
    248e:	2224      	movs	r2, #36	; 0x24
    2490:	5c9a      	ldrb	r2, [r3, r2]
    2492:	68fb      	ldr	r3, [r7, #12]
    2494:	725a      	strb	r2, [r3, #9]
#endif
#ifdef FEATURE_USART_ISO7816
	module->iso7816_mode_enabled = config->iso7816_config.enabled;
#endif
	/* Set configuration according to the config struct */
	status_code = _usart_set_config(module, config);
    2496:	2337      	movs	r3, #55	; 0x37
    2498:	18fc      	adds	r4, r7, r3
    249a:	687a      	ldr	r2, [r7, #4]
    249c:	68fb      	ldr	r3, [r7, #12]
    249e:	0011      	movs	r1, r2
    24a0:	0018      	movs	r0, r3
    24a2:	4b5e      	ldr	r3, [pc, #376]	; (261c <usart_init+0x264>)
    24a4:	4798      	blx	r3
    24a6:	0003      	movs	r3, r0
    24a8:	7023      	strb	r3, [r4, #0]
	if(status_code != STATUS_OK) {
    24aa:	2337      	movs	r3, #55	; 0x37
    24ac:	18fb      	adds	r3, r7, r3
    24ae:	781b      	ldrb	r3, [r3, #0]
    24b0:	2b00      	cmp	r3, #0
    24b2:	d003      	beq.n	24bc <usart_init+0x104>
		return status_code;
    24b4:	2337      	movs	r3, #55	; 0x37
    24b6:	18fb      	adds	r3, r7, r3
    24b8:	781b      	ldrb	r3, [r3, #0]
    24ba:	e09f      	b.n	25fc <usart_init+0x244>
	}

	struct system_pinmux_config pin_conf;
	system_pinmux_get_config_defaults(&pin_conf);
    24bc:	2320      	movs	r3, #32
    24be:	18fb      	adds	r3, r7, r3
    24c0:	0018      	movs	r0, r3
    24c2:	4b57      	ldr	r3, [pc, #348]	; (2620 <usart_init+0x268>)
    24c4:	4798      	blx	r3
	pin_conf.direction = SYSTEM_PINMUX_PIN_DIR_INPUT;
    24c6:	2320      	movs	r3, #32
    24c8:	18fb      	adds	r3, r7, r3
    24ca:	2200      	movs	r2, #0
    24cc:	705a      	strb	r2, [r3, #1]
	pin_conf.input_pull = SYSTEM_PINMUX_PIN_PULL_NONE;
    24ce:	2320      	movs	r3, #32
    24d0:	18fb      	adds	r3, r7, r3
    24d2:	2200      	movs	r2, #0
    24d4:	709a      	strb	r2, [r3, #2]

	uint32_t pad_pinmuxes[] = {
			config->pinmux_pad0, config->pinmux_pad1,
    24d6:	687b      	ldr	r3, [r7, #4]
    24d8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
	uint32_t pad_pinmuxes[] = {
    24da:	2310      	movs	r3, #16
    24dc:	18fb      	adds	r3, r7, r3
    24de:	601a      	str	r2, [r3, #0]
			config->pinmux_pad0, config->pinmux_pad1,
    24e0:	687b      	ldr	r3, [r7, #4]
    24e2:	6bda      	ldr	r2, [r3, #60]	; 0x3c
	uint32_t pad_pinmuxes[] = {
    24e4:	2310      	movs	r3, #16
    24e6:	18fb      	adds	r3, r7, r3
    24e8:	605a      	str	r2, [r3, #4]
			config->pinmux_pad2, config->pinmux_pad3
    24ea:	687b      	ldr	r3, [r7, #4]
    24ec:	6c1a      	ldr	r2, [r3, #64]	; 0x40
	uint32_t pad_pinmuxes[] = {
    24ee:	2310      	movs	r3, #16
    24f0:	18fb      	adds	r3, r7, r3
    24f2:	609a      	str	r2, [r3, #8]
			config->pinmux_pad2, config->pinmux_pad3
    24f4:	687b      	ldr	r3, [r7, #4]
    24f6:	6c5a      	ldr	r2, [r3, #68]	; 0x44
	uint32_t pad_pinmuxes[] = {
    24f8:	2310      	movs	r3, #16
    24fa:	18fb      	adds	r3, r7, r3
    24fc:	60da      	str	r2, [r3, #12]
		};

	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
    24fe:	2343      	movs	r3, #67	; 0x43
    2500:	18fb      	adds	r3, r7, r3
    2502:	2200      	movs	r2, #0
    2504:	701a      	strb	r2, [r3, #0]
    2506:	e02c      	b.n	2562 <usart_init+0x1aa>
		uint32_t current_pinmux = pad_pinmuxes[pad];
    2508:	2343      	movs	r3, #67	; 0x43
    250a:	18fb      	adds	r3, r7, r3
    250c:	781a      	ldrb	r2, [r3, #0]
    250e:	2310      	movs	r3, #16
    2510:	18fb      	adds	r3, r7, r3
    2512:	0092      	lsls	r2, r2, #2
    2514:	58d3      	ldr	r3, [r2, r3]
    2516:	63fb      	str	r3, [r7, #60]	; 0x3c

		if (current_pinmux == PINMUX_DEFAULT) {
    2518:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    251a:	2b00      	cmp	r3, #0
    251c:	d109      	bne.n	2532 <usart_init+0x17a>
			current_pinmux = _sercom_get_default_pad(hw, pad);
    251e:	2343      	movs	r3, #67	; 0x43
    2520:	18fb      	adds	r3, r7, r3
    2522:	781a      	ldrb	r2, [r3, #0]
    2524:	68bb      	ldr	r3, [r7, #8]
    2526:	0011      	movs	r1, r2
    2528:	0018      	movs	r0, r3
    252a:	4b3e      	ldr	r3, [pc, #248]	; (2624 <usart_init+0x26c>)
    252c:	4798      	blx	r3
    252e:	0003      	movs	r3, r0
    2530:	63fb      	str	r3, [r7, #60]	; 0x3c
		}

		if (current_pinmux != PINMUX_UNUSED) {
    2532:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    2534:	3301      	adds	r3, #1
    2536:	d00d      	beq.n	2554 <usart_init+0x19c>
			pin_conf.mux_position = current_pinmux & 0xFFFF;
    2538:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    253a:	b2da      	uxtb	r2, r3
    253c:	2320      	movs	r3, #32
    253e:	18fb      	adds	r3, r7, r3
    2540:	701a      	strb	r2, [r3, #0]
			system_pinmux_pin_set_config(current_pinmux >> 16, &pin_conf);
    2542:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    2544:	0c1b      	lsrs	r3, r3, #16
    2546:	b2db      	uxtb	r3, r3
    2548:	2220      	movs	r2, #32
    254a:	18ba      	adds	r2, r7, r2
    254c:	0011      	movs	r1, r2
    254e:	0018      	movs	r0, r3
    2550:	4b35      	ldr	r3, [pc, #212]	; (2628 <usart_init+0x270>)
    2552:	4798      	blx	r3
	for (uint8_t pad = 0; pad < 4; pad++) {
    2554:	2343      	movs	r3, #67	; 0x43
    2556:	18fb      	adds	r3, r7, r3
    2558:	781a      	ldrb	r2, [r3, #0]
    255a:	2343      	movs	r3, #67	; 0x43
    255c:	18fb      	adds	r3, r7, r3
    255e:	3201      	adds	r2, #1
    2560:	701a      	strb	r2, [r3, #0]
    2562:	2343      	movs	r3, #67	; 0x43
    2564:	18fb      	adds	r3, r7, r3
    2566:	781b      	ldrb	r3, [r3, #0]
    2568:	2b03      	cmp	r3, #3
    256a:	d9cd      	bls.n	2508 <usart_init+0x150>
		}
	}

#if USART_CALLBACK_MODE == true
	/* Initialize parameters */
	for (uint32_t i = 0; i < USART_CALLBACK_N; i++) {
    256c:	2300      	movs	r3, #0
    256e:	63bb      	str	r3, [r7, #56]	; 0x38
    2570:	e00a      	b.n	2588 <usart_init+0x1d0>
		module->callback[i]            = NULL;
    2572:	68fa      	ldr	r2, [r7, #12]
    2574:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    2576:	3302      	adds	r3, #2
    2578:	009b      	lsls	r3, r3, #2
    257a:	18d3      	adds	r3, r2, r3
    257c:	3304      	adds	r3, #4
    257e:	2200      	movs	r2, #0
    2580:	601a      	str	r2, [r3, #0]
	for (uint32_t i = 0; i < USART_CALLBACK_N; i++) {
    2582:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    2584:	3301      	adds	r3, #1
    2586:	63bb      	str	r3, [r7, #56]	; 0x38
    2588:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    258a:	2b05      	cmp	r3, #5
    258c:	d9f1      	bls.n	2572 <usart_init+0x1ba>
	}

	module->tx_buffer_ptr              = NULL;
    258e:	68fb      	ldr	r3, [r7, #12]
    2590:	2200      	movs	r2, #0
    2592:	629a      	str	r2, [r3, #40]	; 0x28
	module->rx_buffer_ptr              = NULL;
    2594:	68fb      	ldr	r3, [r7, #12]
    2596:	2200      	movs	r2, #0
    2598:	625a      	str	r2, [r3, #36]	; 0x24
	module->remaining_tx_buffer_length = 0x0000;
    259a:	68fb      	ldr	r3, [r7, #12]
    259c:	2200      	movs	r2, #0
    259e:	85da      	strh	r2, [r3, #46]	; 0x2e
	module->remaining_rx_buffer_length = 0x0000;
    25a0:	68fb      	ldr	r3, [r7, #12]
    25a2:	2200      	movs	r2, #0
    25a4:	859a      	strh	r2, [r3, #44]	; 0x2c
	module->callback_reg_mask          = 0x00;
    25a6:	68fb      	ldr	r3, [r7, #12]
    25a8:	2230      	movs	r2, #48	; 0x30
    25aa:	2100      	movs	r1, #0
    25ac:	5499      	strb	r1, [r3, r2]
	module->callback_enable_mask       = 0x00;
    25ae:	68fb      	ldr	r3, [r7, #12]
    25b0:	2231      	movs	r2, #49	; 0x31
    25b2:	2100      	movs	r1, #0
    25b4:	5499      	strb	r1, [r3, r2]
	module->rx_status                  = STATUS_OK;
    25b6:	68fb      	ldr	r3, [r7, #12]
    25b8:	2232      	movs	r2, #50	; 0x32
    25ba:	2100      	movs	r1, #0
    25bc:	5499      	strb	r1, [r3, r2]
	module->tx_status                  = STATUS_OK;
    25be:	68fb      	ldr	r3, [r7, #12]
    25c0:	2233      	movs	r2, #51	; 0x33
    25c2:	2100      	movs	r1, #0
    25c4:	5499      	strb	r1, [r3, r2]

	/* Set interrupt handler and register USART software module struct in
	 * look-up table */
	uint8_t instance_index = _sercom_get_sercom_inst_index(module->hw);
    25c6:	68fb      	ldr	r3, [r7, #12]
    25c8:	681b      	ldr	r3, [r3, #0]
    25ca:	2227      	movs	r2, #39	; 0x27
    25cc:	18bc      	adds	r4, r7, r2
    25ce:	0018      	movs	r0, r3
    25d0:	4b0c      	ldr	r3, [pc, #48]	; (2604 <usart_init+0x24c>)
    25d2:	4798      	blx	r3
    25d4:	0003      	movs	r3, r0
    25d6:	7023      	strb	r3, [r4, #0]
	_sercom_set_handler(instance_index, _usart_interrupt_handler);
    25d8:	4a14      	ldr	r2, [pc, #80]	; (262c <usart_init+0x274>)
    25da:	2327      	movs	r3, #39	; 0x27
    25dc:	18fb      	adds	r3, r7, r3
    25de:	781b      	ldrb	r3, [r3, #0]
    25e0:	0011      	movs	r1, r2
    25e2:	0018      	movs	r0, r3
    25e4:	4b12      	ldr	r3, [pc, #72]	; (2630 <usart_init+0x278>)
    25e6:	4798      	blx	r3
	_sercom_instances[instance_index] = module;
    25e8:	2327      	movs	r3, #39	; 0x27
    25ea:	18fb      	adds	r3, r7, r3
    25ec:	781a      	ldrb	r2, [r3, #0]
    25ee:	4b11      	ldr	r3, [pc, #68]	; (2634 <usart_init+0x27c>)
    25f0:	0092      	lsls	r2, r2, #2
    25f2:	68f9      	ldr	r1, [r7, #12]
    25f4:	50d1      	str	r1, [r2, r3]
#endif

	return status_code;
    25f6:	2337      	movs	r3, #55	; 0x37
    25f8:	18fb      	adds	r3, r7, r3
    25fa:	781b      	ldrb	r3, [r3, #0]
}
    25fc:	0018      	movs	r0, r3
    25fe:	46bd      	mov	sp, r7
    2600:	b013      	add	sp, #76	; 0x4c
    2602:	bd90      	pop	{r4, r7, pc}
    2604:	00001dc5 	.word	0x00001dc5
    2608:	00001f81 	.word	0x00001f81
    260c:	00001f69 	.word	0x00001f69
    2610:	00006659 	.word	0x00006659
    2614:	00006699 	.word	0x00006699
    2618:	00001b79 	.word	0x00001b79
    261c:	00002069 	.word	0x00002069
    2620:	00001fdd 	.word	0x00001fdd
    2624:	00001c05 	.word	0x00001c05
    2628:	0000690d 	.word	0x0000690d
    262c:	00002851 	.word	0x00002851
    2630:	00001e29 	.word	0x00001e29
    2634:	20003314 	.word	0x20003314

00002638 <system_interrupt_enter_critical_section>:
{
    2638:	b580      	push	{r7, lr}
    263a:	af00      	add	r7, sp, #0
	cpu_irq_enter_critical();
    263c:	4b02      	ldr	r3, [pc, #8]	; (2648 <system_interrupt_enter_critical_section+0x10>)
    263e:	4798      	blx	r3
}
    2640:	46c0      	nop			; (mov r8, r8)
    2642:	46bd      	mov	sp, r7
    2644:	bd80      	pop	{r7, pc}
    2646:	46c0      	nop			; (mov r8, r8)
    2648:	000060d5 	.word	0x000060d5

0000264c <system_interrupt_leave_critical_section>:
{
    264c:	b580      	push	{r7, lr}
    264e:	af00      	add	r7, sp, #0
	cpu_irq_leave_critical();
    2650:	4b02      	ldr	r3, [pc, #8]	; (265c <system_interrupt_leave_critical_section+0x10>)
    2652:	4798      	blx	r3
}
    2654:	46c0      	nop			; (mov r8, r8)
    2656:	46bd      	mov	sp, r7
    2658:	bd80      	pop	{r7, pc}
    265a:	46c0      	nop			; (mov r8, r8)
    265c:	00006129 	.word	0x00006129

00002660 <usart_is_syncing>:
{
    2660:	b580      	push	{r7, lr}
    2662:	b084      	sub	sp, #16
    2664:	af00      	add	r7, sp, #0
    2666:	6078      	str	r0, [r7, #4]
	SercomUsart *const usart_hw = &(module->hw->USART);
    2668:	687b      	ldr	r3, [r7, #4]
    266a:	681b      	ldr	r3, [r3, #0]
    266c:	60fb      	str	r3, [r7, #12]
	return (usart_hw->SYNCBUSY.reg);
    266e:	68fb      	ldr	r3, [r7, #12]
    2670:	69db      	ldr	r3, [r3, #28]
    2672:	1e5a      	subs	r2, r3, #1
    2674:	4193      	sbcs	r3, r2
    2676:	b2db      	uxtb	r3, r3
}
    2678:	0018      	movs	r0, r3
    267a:	46bd      	mov	sp, r7
    267c:	b004      	add	sp, #16
    267e:	bd80      	pop	{r7, pc}

00002680 <_usart_wait_for_sync>:
{
    2680:	b580      	push	{r7, lr}
    2682:	b082      	sub	sp, #8
    2684:	af00      	add	r7, sp, #0
    2686:	6078      	str	r0, [r7, #4]
	while (usart_is_syncing(module)) {
    2688:	46c0      	nop			; (mov r8, r8)
    268a:	687b      	ldr	r3, [r7, #4]
    268c:	0018      	movs	r0, r3
    268e:	4b04      	ldr	r3, [pc, #16]	; (26a0 <_usart_wait_for_sync+0x20>)
    2690:	4798      	blx	r3
    2692:	1e03      	subs	r3, r0, #0
    2694:	d1f9      	bne.n	268a <_usart_wait_for_sync+0xa>
}
    2696:	46c0      	nop			; (mov r8, r8)
    2698:	46bd      	mov	sp, r7
    269a:	b002      	add	sp, #8
    269c:	bd80      	pop	{r7, pc}
    269e:	46c0      	nop			; (mov r8, r8)
    26a0:	00002661 	.word	0x00002661

000026a4 <_usart_write_buffer>:
 */
enum status_code _usart_write_buffer(
		struct usart_module *const module,
		uint8_t *tx_data,
		uint16_t length)
{
    26a4:	b580      	push	{r7, lr}
    26a6:	b086      	sub	sp, #24
    26a8:	af00      	add	r7, sp, #0
    26aa:	60f8      	str	r0, [r7, #12]
    26ac:	60b9      	str	r1, [r7, #8]
    26ae:	1dbb      	adds	r3, r7, #6
    26b0:	801a      	strh	r2, [r3, #0]
	Assert(module);
	Assert(module->hw);
	Assert(tx_data);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    26b2:	68fb      	ldr	r3, [r7, #12]
    26b4:	681b      	ldr	r3, [r3, #0]
    26b6:	617b      	str	r3, [r7, #20]

	system_interrupt_enter_critical_section();
    26b8:	4b0f      	ldr	r3, [pc, #60]	; (26f8 <_usart_write_buffer+0x54>)
    26ba:	4798      	blx	r3

	/* Check if the USART transmitter is busy */
	if (module->remaining_tx_buffer_length > 0) {
    26bc:	68fb      	ldr	r3, [r7, #12]
    26be:	8ddb      	ldrh	r3, [r3, #46]	; 0x2e
    26c0:	b29b      	uxth	r3, r3
    26c2:	2b00      	cmp	r3, #0
    26c4:	d003      	beq.n	26ce <_usart_write_buffer+0x2a>
		system_interrupt_leave_critical_section();
    26c6:	4b0d      	ldr	r3, [pc, #52]	; (26fc <_usart_write_buffer+0x58>)
    26c8:	4798      	blx	r3
		return STATUS_BUSY;
    26ca:	2305      	movs	r3, #5
    26cc:	e010      	b.n	26f0 <_usart_write_buffer+0x4c>
	}

	/* Write parameters to the device instance */
	module->remaining_tx_buffer_length = length;
    26ce:	68fb      	ldr	r3, [r7, #12]
    26d0:	1dba      	adds	r2, r7, #6
    26d2:	8812      	ldrh	r2, [r2, #0]
    26d4:	85da      	strh	r2, [r3, #46]	; 0x2e

	system_interrupt_leave_critical_section();
    26d6:	4b09      	ldr	r3, [pc, #36]	; (26fc <_usart_write_buffer+0x58>)
    26d8:	4798      	blx	r3

	module->tx_buffer_ptr              = tx_data;
    26da:	68fb      	ldr	r3, [r7, #12]
    26dc:	68ba      	ldr	r2, [r7, #8]
    26de:	629a      	str	r2, [r3, #40]	; 0x28
	module->tx_status                  = STATUS_BUSY;
    26e0:	68fb      	ldr	r3, [r7, #12]
    26e2:	2233      	movs	r2, #51	; 0x33
    26e4:	2105      	movs	r1, #5
    26e6:	5499      	strb	r1, [r3, r2]

	/* Enable the Data Register Empty Interrupt */
	usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_DRE;
    26e8:	697b      	ldr	r3, [r7, #20]
    26ea:	2201      	movs	r2, #1
    26ec:	759a      	strb	r2, [r3, #22]

	return STATUS_OK;
    26ee:	2300      	movs	r3, #0
}
    26f0:	0018      	movs	r0, r3
    26f2:	46bd      	mov	sp, r7
    26f4:	b006      	add	sp, #24
    26f6:	bd80      	pop	{r7, pc}
    26f8:	00002639 	.word	0x00002639
    26fc:	0000264d 	.word	0x0000264d

00002700 <_usart_read_buffer>:
 */
enum status_code _usart_read_buffer(
		struct usart_module *const module,
		uint8_t *rx_data,
		uint16_t length)
{
    2700:	b580      	push	{r7, lr}
    2702:	b086      	sub	sp, #24
    2704:	af00      	add	r7, sp, #0
    2706:	60f8      	str	r0, [r7, #12]
    2708:	60b9      	str	r1, [r7, #8]
    270a:	1dbb      	adds	r3, r7, #6
    270c:	801a      	strh	r2, [r3, #0]
	Assert(module);
	Assert(module->hw);
	Assert(rx_data);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    270e:	68fb      	ldr	r3, [r7, #12]
    2710:	681b      	ldr	r3, [r3, #0]
    2712:	617b      	str	r3, [r7, #20]

	system_interrupt_enter_critical_section();
    2714:	4b16      	ldr	r3, [pc, #88]	; (2770 <_usart_read_buffer+0x70>)
    2716:	4798      	blx	r3

	/* Check if the USART receiver is busy */
	if (module->remaining_rx_buffer_length > 0) {
    2718:	68fb      	ldr	r3, [r7, #12]
    271a:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
    271c:	b29b      	uxth	r3, r3
    271e:	2b00      	cmp	r3, #0
    2720:	d003      	beq.n	272a <_usart_read_buffer+0x2a>
		system_interrupt_leave_critical_section();
    2722:	4b14      	ldr	r3, [pc, #80]	; (2774 <_usart_read_buffer+0x74>)
    2724:	4798      	blx	r3
		return STATUS_BUSY;
    2726:	2305      	movs	r3, #5
    2728:	e01e      	b.n	2768 <_usart_read_buffer+0x68>
	}

	/* Set length for the buffer and the pointer, and let
	 * the interrupt handler do the rest */
	module->remaining_rx_buffer_length = length;
    272a:	68fb      	ldr	r3, [r7, #12]
    272c:	1dba      	adds	r2, r7, #6
    272e:	8812      	ldrh	r2, [r2, #0]
    2730:	859a      	strh	r2, [r3, #44]	; 0x2c

	system_interrupt_leave_critical_section();
    2732:	4b10      	ldr	r3, [pc, #64]	; (2774 <_usart_read_buffer+0x74>)
    2734:	4798      	blx	r3

	module->rx_buffer_ptr              = rx_data;
    2736:	68fb      	ldr	r3, [r7, #12]
    2738:	68ba      	ldr	r2, [r7, #8]
    273a:	625a      	str	r2, [r3, #36]	; 0x24
	module->rx_status                  = STATUS_BUSY;
    273c:	68fb      	ldr	r3, [r7, #12]
    273e:	2232      	movs	r2, #50	; 0x32
    2740:	2105      	movs	r1, #5
    2742:	5499      	strb	r1, [r3, r2]

	/* Enable the RX Complete Interrupt */
	usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_RXC;
    2744:	697b      	ldr	r3, [r7, #20]
    2746:	2204      	movs	r2, #4
    2748:	759a      	strb	r2, [r3, #22]

#ifdef FEATURE_USART_LIN_SLAVE
	/* Enable the break character is received Interrupt */
	if(module->lin_slave_enabled) {
    274a:	68fb      	ldr	r3, [r7, #12]
    274c:	7a1b      	ldrb	r3, [r3, #8]
    274e:	2b00      	cmp	r3, #0
    2750:	d002      	beq.n	2758 <_usart_read_buffer+0x58>
		usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_RXBRK;
    2752:	697b      	ldr	r3, [r7, #20]
    2754:	2220      	movs	r2, #32
    2756:	759a      	strb	r2, [r3, #22]
	}
#endif

#ifdef FEATURE_USART_START_FRAME_DECTION
	/* Enable a start condition is detected Interrupt */
	if(module->start_frame_detection_enabled) {
    2758:	68fb      	ldr	r3, [r7, #12]
    275a:	7a5b      	ldrb	r3, [r3, #9]
    275c:	2b00      	cmp	r3, #0
    275e:	d002      	beq.n	2766 <_usart_read_buffer+0x66>
		usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_RXS;
    2760:	697b      	ldr	r3, [r7, #20]
    2762:	2208      	movs	r2, #8
    2764:	759a      	strb	r2, [r3, #22]
	}
#endif

	return STATUS_OK;
    2766:	2300      	movs	r3, #0
}
    2768:	0018      	movs	r0, r3
    276a:	46bd      	mov	sp, r7
    276c:	b006      	add	sp, #24
    276e:	bd80      	pop	{r7, pc}
    2770:	00002639 	.word	0x00002639
    2774:	0000264d 	.word	0x0000264d

00002778 <usart_register_callback>:
 */
void usart_register_callback(
		struct usart_module *const module,
		usart_callback_t callback_func,
		enum usart_callback callback_type)
{
    2778:	b580      	push	{r7, lr}
    277a:	b084      	sub	sp, #16
    277c:	af00      	add	r7, sp, #0
    277e:	60f8      	str	r0, [r7, #12]
    2780:	60b9      	str	r1, [r7, #8]
    2782:	1dfb      	adds	r3, r7, #7
    2784:	701a      	strb	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(module);
	Assert(callback_func);

	/* Register callback function */
	module->callback[callback_type] = callback_func;
    2786:	1dfb      	adds	r3, r7, #7
    2788:	781b      	ldrb	r3, [r3, #0]
    278a:	68fa      	ldr	r2, [r7, #12]
    278c:	3302      	adds	r3, #2
    278e:	009b      	lsls	r3, r3, #2
    2790:	18d3      	adds	r3, r2, r3
    2792:	3304      	adds	r3, #4
    2794:	68ba      	ldr	r2, [r7, #8]
    2796:	601a      	str	r2, [r3, #0]

	/* Set the bit corresponding to the callback_type */
	module->callback_reg_mask |= (1 << callback_type);
    2798:	68fb      	ldr	r3, [r7, #12]
    279a:	2230      	movs	r2, #48	; 0x30
    279c:	5c9b      	ldrb	r3, [r3, r2]
    279e:	b25a      	sxtb	r2, r3
    27a0:	1dfb      	adds	r3, r7, #7
    27a2:	781b      	ldrb	r3, [r3, #0]
    27a4:	2101      	movs	r1, #1
    27a6:	4099      	lsls	r1, r3
    27a8:	000b      	movs	r3, r1
    27aa:	b25b      	sxtb	r3, r3
    27ac:	4313      	orrs	r3, r2
    27ae:	b25b      	sxtb	r3, r3
    27b0:	b2d9      	uxtb	r1, r3
    27b2:	68fb      	ldr	r3, [r7, #12]
    27b4:	2230      	movs	r2, #48	; 0x30
    27b6:	5499      	strb	r1, [r3, r2]
}
    27b8:	46c0      	nop			; (mov r8, r8)
    27ba:	46bd      	mov	sp, r7
    27bc:	b004      	add	sp, #16
    27be:	bd80      	pop	{r7, pc}

000027c0 <usart_write_buffer_job>:
 */
enum status_code usart_write_buffer_job(
		struct usart_module *const module,
		uint8_t *tx_data,
		uint16_t length)
{
    27c0:	b580      	push	{r7, lr}
    27c2:	b084      	sub	sp, #16
    27c4:	af00      	add	r7, sp, #0
    27c6:	60f8      	str	r0, [r7, #12]
    27c8:	60b9      	str	r1, [r7, #8]
    27ca:	1dbb      	adds	r3, r7, #6
    27cc:	801a      	strh	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(module);
	Assert(tx_data);

	if (length == 0) {
    27ce:	1dbb      	adds	r3, r7, #6
    27d0:	881b      	ldrh	r3, [r3, #0]
    27d2:	2b00      	cmp	r3, #0
    27d4:	d101      	bne.n	27da <usart_write_buffer_job+0x1a>
		return STATUS_ERR_INVALID_ARG;
    27d6:	2317      	movs	r3, #23
    27d8:	e010      	b.n	27fc <usart_write_buffer_job+0x3c>
	}

	/* Check that the transmitter is enabled */
	if (!(module->transmitter_enabled)) {
    27da:	68fb      	ldr	r3, [r7, #12]
    27dc:	79db      	ldrb	r3, [r3, #7]
    27de:	2201      	movs	r2, #1
    27e0:	4053      	eors	r3, r2
    27e2:	b2db      	uxtb	r3, r3
    27e4:	2b00      	cmp	r3, #0
    27e6:	d001      	beq.n	27ec <usart_write_buffer_job+0x2c>
		return STATUS_ERR_DENIED;
    27e8:	231c      	movs	r3, #28
    27ea:	e007      	b.n	27fc <usart_write_buffer_job+0x3c>
	}

	/* Issue internal asynchronous write */
	return _usart_write_buffer(module, tx_data, length);
    27ec:	1dbb      	adds	r3, r7, #6
    27ee:	881a      	ldrh	r2, [r3, #0]
    27f0:	68b9      	ldr	r1, [r7, #8]
    27f2:	68fb      	ldr	r3, [r7, #12]
    27f4:	0018      	movs	r0, r3
    27f6:	4b03      	ldr	r3, [pc, #12]	; (2804 <usart_write_buffer_job+0x44>)
    27f8:	4798      	blx	r3
    27fa:	0003      	movs	r3, r0
}
    27fc:	0018      	movs	r0, r3
    27fe:	46bd      	mov	sp, r7
    2800:	b004      	add	sp, #16
    2802:	bd80      	pop	{r7, pc}
    2804:	000026a5 	.word	0x000026a5

00002808 <usart_read_buffer_job>:
 */
enum status_code usart_read_buffer_job(
		struct usart_module *const module,
		uint8_t *rx_data,
		uint16_t length)
{
    2808:	b580      	push	{r7, lr}
    280a:	b084      	sub	sp, #16
    280c:	af00      	add	r7, sp, #0
    280e:	60f8      	str	r0, [r7, #12]
    2810:	60b9      	str	r1, [r7, #8]
    2812:	1dbb      	adds	r3, r7, #6
    2814:	801a      	strh	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(module);
	Assert(rx_data);

	if (length == 0) {
    2816:	1dbb      	adds	r3, r7, #6
    2818:	881b      	ldrh	r3, [r3, #0]
    281a:	2b00      	cmp	r3, #0
    281c:	d101      	bne.n	2822 <usart_read_buffer_job+0x1a>
		return STATUS_ERR_INVALID_ARG;
    281e:	2317      	movs	r3, #23
    2820:	e010      	b.n	2844 <usart_read_buffer_job+0x3c>
	}

	/* Check that the receiver is enabled */
	if (!(module->receiver_enabled)) {
    2822:	68fb      	ldr	r3, [r7, #12]
    2824:	799b      	ldrb	r3, [r3, #6]
    2826:	2201      	movs	r2, #1
    2828:	4053      	eors	r3, r2
    282a:	b2db      	uxtb	r3, r3
    282c:	2b00      	cmp	r3, #0
    282e:	d001      	beq.n	2834 <usart_read_buffer_job+0x2c>
		return STATUS_ERR_DENIED;
    2830:	231c      	movs	r3, #28
    2832:	e007      	b.n	2844 <usart_read_buffer_job+0x3c>
	}

	/* Issue internal asynchronous read */
	return _usart_read_buffer(module, rx_data, length);
    2834:	1dbb      	adds	r3, r7, #6
    2836:	881a      	ldrh	r2, [r3, #0]
    2838:	68b9      	ldr	r1, [r7, #8]
    283a:	68fb      	ldr	r3, [r7, #12]
    283c:	0018      	movs	r0, r3
    283e:	4b03      	ldr	r3, [pc, #12]	; (284c <usart_read_buffer_job+0x44>)
    2840:	4798      	blx	r3
    2842:	0003      	movs	r3, r0
}
    2844:	0018      	movs	r0, r3
    2846:	46bd      	mov	sp, r7
    2848:	b004      	add	sp, #16
    284a:	bd80      	pop	{r7, pc}
    284c:	00002701 	.word	0x00002701

00002850 <_usart_interrupt_handler>:
 * \param[in]  instance  ID of the SERCOM instance calling the interrupt
 *                       handler.
 */
void _usart_interrupt_handler(
		uint8_t instance)
{
    2850:	b580      	push	{r7, lr}
    2852:	b088      	sub	sp, #32
    2854:	af00      	add	r7, sp, #0
    2856:	0002      	movs	r2, r0
    2858:	1dfb      	adds	r3, r7, #7
    285a:	701a      	strb	r2, [r3, #0]
	uint8_t error_code;


	/* Get device instance from the look-up table */
	struct usart_module *module
		= (struct usart_module *)_sercom_instances[instance];
    285c:	1dfb      	adds	r3, r7, #7
    285e:	781a      	ldrb	r2, [r3, #0]
	struct usart_module *module
    2860:	4baa      	ldr	r3, [pc, #680]	; (2b0c <_usart_interrupt_handler+0x2bc>)
    2862:	0092      	lsls	r2, r2, #2
    2864:	58d3      	ldr	r3, [r2, r3]
    2866:	61bb      	str	r3, [r7, #24]

	/* Pointer to the hardware module instance */
	SercomUsart *const usart_hw
		= &(module->hw->USART);
    2868:	69bb      	ldr	r3, [r7, #24]
    286a:	681b      	ldr	r3, [r3, #0]
	SercomUsart *const usart_hw
    286c:	617b      	str	r3, [r7, #20]

	/* Wait for the synchronization to complete */
	_usart_wait_for_sync(module);
    286e:	69bb      	ldr	r3, [r7, #24]
    2870:	0018      	movs	r0, r3
    2872:	4ba7      	ldr	r3, [pc, #668]	; (2b10 <_usart_interrupt_handler+0x2c0>)
    2874:	4798      	blx	r3

	/* Read and mask interrupt flag register */
	interrupt_status = usart_hw->INTFLAG.reg;
    2876:	697b      	ldr	r3, [r7, #20]
    2878:	7e1b      	ldrb	r3, [r3, #24]
    287a:	b2da      	uxtb	r2, r3
    287c:	2312      	movs	r3, #18
    287e:	18fb      	adds	r3, r7, r3
    2880:	801a      	strh	r2, [r3, #0]
	interrupt_status &= usart_hw->INTENSET.reg;
    2882:	697b      	ldr	r3, [r7, #20]
    2884:	7d9b      	ldrb	r3, [r3, #22]
    2886:	b2db      	uxtb	r3, r3
    2888:	b29a      	uxth	r2, r3
    288a:	2312      	movs	r3, #18
    288c:	18fb      	adds	r3, r7, r3
    288e:	2112      	movs	r1, #18
    2890:	1879      	adds	r1, r7, r1
    2892:	8809      	ldrh	r1, [r1, #0]
    2894:	400a      	ands	r2, r1
    2896:	801a      	strh	r2, [r3, #0]
	callback_status = module->callback_reg_mask &
    2898:	69bb      	ldr	r3, [r7, #24]
    289a:	2230      	movs	r2, #48	; 0x30
    289c:	5c9b      	ldrb	r3, [r3, r2]
			module->callback_enable_mask;
    289e:	69ba      	ldr	r2, [r7, #24]
    28a0:	2131      	movs	r1, #49	; 0x31
    28a2:	5c52      	ldrb	r2, [r2, r1]
	callback_status = module->callback_reg_mask &
    28a4:	4013      	ands	r3, r2
    28a6:	b2da      	uxtb	r2, r3
    28a8:	2310      	movs	r3, #16
    28aa:	18fb      	adds	r3, r7, r3
    28ac:	801a      	strh	r2, [r3, #0]

	/* Check if a DATA READY interrupt has occurred,
	 * and if there is more to transfer */
	if (interrupt_status & SERCOM_USART_INTFLAG_DRE) {
    28ae:	2312      	movs	r3, #18
    28b0:	18fb      	adds	r3, r7, r3
    28b2:	881b      	ldrh	r3, [r3, #0]
    28b4:	2201      	movs	r2, #1
    28b6:	4013      	ands	r3, r2
    28b8:	d044      	beq.n	2944 <_usart_interrupt_handler+0xf4>
		if (module->remaining_tx_buffer_length) {
    28ba:	69bb      	ldr	r3, [r7, #24]
    28bc:	8ddb      	ldrh	r3, [r3, #46]	; 0x2e
    28be:	b29b      	uxth	r3, r3
    28c0:	2b00      	cmp	r3, #0
    28c2:	d03c      	beq.n	293e <_usart_interrupt_handler+0xee>
			/* Write value will be at least 8-bits long */
			uint16_t data_to_send = *(module->tx_buffer_ptr);
    28c4:	69bb      	ldr	r3, [r7, #24]
    28c6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    28c8:	781b      	ldrb	r3, [r3, #0]
    28ca:	b2da      	uxtb	r2, r3
    28cc:	231c      	movs	r3, #28
    28ce:	18fb      	adds	r3, r7, r3
    28d0:	801a      	strh	r2, [r3, #0]
			/* Increment 8-bit pointer */
			(module->tx_buffer_ptr)++;
    28d2:	69bb      	ldr	r3, [r7, #24]
    28d4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    28d6:	1c5a      	adds	r2, r3, #1
    28d8:	69bb      	ldr	r3, [r7, #24]
    28da:	629a      	str	r2, [r3, #40]	; 0x28

			if (module->character_size == USART_CHARACTER_SIZE_9BIT) {
    28dc:	69bb      	ldr	r3, [r7, #24]
    28de:	795b      	ldrb	r3, [r3, #5]
    28e0:	2b01      	cmp	r3, #1
    28e2:	d113      	bne.n	290c <_usart_interrupt_handler+0xbc>
				data_to_send |= (*(module->tx_buffer_ptr) << 8);
    28e4:	69bb      	ldr	r3, [r7, #24]
    28e6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    28e8:	781b      	ldrb	r3, [r3, #0]
    28ea:	b2db      	uxtb	r3, r3
    28ec:	021b      	lsls	r3, r3, #8
    28ee:	b21a      	sxth	r2, r3
    28f0:	231c      	movs	r3, #28
    28f2:	18fb      	adds	r3, r7, r3
    28f4:	2100      	movs	r1, #0
    28f6:	5e5b      	ldrsh	r3, [r3, r1]
    28f8:	4313      	orrs	r3, r2
    28fa:	b21a      	sxth	r2, r3
    28fc:	231c      	movs	r3, #28
    28fe:	18fb      	adds	r3, r7, r3
    2900:	801a      	strh	r2, [r3, #0]
				/* Increment 8-bit pointer */
				(module->tx_buffer_ptr)++;
    2902:	69bb      	ldr	r3, [r7, #24]
    2904:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2906:	1c5a      	adds	r2, r3, #1
    2908:	69bb      	ldr	r3, [r7, #24]
    290a:	629a      	str	r2, [r3, #40]	; 0x28
			}
			/* Write the data to send */
			usart_hw->DATA.reg = (data_to_send & SERCOM_USART_DATA_MASK);
    290c:	231c      	movs	r3, #28
    290e:	18fb      	adds	r3, r7, r3
    2910:	881b      	ldrh	r3, [r3, #0]
    2912:	05db      	lsls	r3, r3, #23
    2914:	0ddb      	lsrs	r3, r3, #23
    2916:	b29a      	uxth	r2, r3
    2918:	697b      	ldr	r3, [r7, #20]
    291a:	851a      	strh	r2, [r3, #40]	; 0x28

			if (--(module->remaining_tx_buffer_length) == 0) {
    291c:	69bb      	ldr	r3, [r7, #24]
    291e:	8ddb      	ldrh	r3, [r3, #46]	; 0x2e
    2920:	b29b      	uxth	r3, r3
    2922:	3b01      	subs	r3, #1
    2924:	b29b      	uxth	r3, r3
    2926:	69ba      	ldr	r2, [r7, #24]
    2928:	1c19      	adds	r1, r3, #0
    292a:	85d1      	strh	r1, [r2, #46]	; 0x2e
    292c:	2b00      	cmp	r3, #0
    292e:	d109      	bne.n	2944 <_usart_interrupt_handler+0xf4>
				/* Disable the Data Register Empty Interrupt */
				usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_DRE;
    2930:	697b      	ldr	r3, [r7, #20]
    2932:	2201      	movs	r2, #1
    2934:	751a      	strb	r2, [r3, #20]
				/* Enable Transmission Complete interrupt */
				usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_TXC;
    2936:	697b      	ldr	r3, [r7, #20]
    2938:	2202      	movs	r2, #2
    293a:	759a      	strb	r2, [r3, #22]
    293c:	e002      	b.n	2944 <_usart_interrupt_handler+0xf4>

			}
		} else {
			usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_DRE;
    293e:	697b      	ldr	r3, [r7, #20]
    2940:	2201      	movs	r2, #1
    2942:	751a      	strb	r2, [r3, #20]
		}
	}

	/* Check if the Transmission Complete interrupt has occurred and
	 * that the transmit buffer is empty */
	if (interrupt_status & SERCOM_USART_INTFLAG_TXC) {
    2944:	2312      	movs	r3, #18
    2946:	18fb      	adds	r3, r7, r3
    2948:	881b      	ldrh	r3, [r3, #0]
    294a:	2202      	movs	r2, #2
    294c:	4013      	ands	r3, r2
    294e:	d011      	beq.n	2974 <_usart_interrupt_handler+0x124>

		/* Disable TX Complete Interrupt, and set STATUS_OK */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_TXC;
    2950:	697b      	ldr	r3, [r7, #20]
    2952:	2202      	movs	r2, #2
    2954:	751a      	strb	r2, [r3, #20]
		module->tx_status = STATUS_OK;
    2956:	69bb      	ldr	r3, [r7, #24]
    2958:	2233      	movs	r2, #51	; 0x33
    295a:	2100      	movs	r1, #0
    295c:	5499      	strb	r1, [r3, r2]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_BUFFER_TRANSMITTED)) {
    295e:	2310      	movs	r3, #16
    2960:	18fb      	adds	r3, r7, r3
    2962:	881b      	ldrh	r3, [r3, #0]
    2964:	2201      	movs	r2, #1
    2966:	4013      	ands	r3, r2
    2968:	d004      	beq.n	2974 <_usart_interrupt_handler+0x124>
			(*(module->callback[USART_CALLBACK_BUFFER_TRANSMITTED]))(module);
    296a:	69bb      	ldr	r3, [r7, #24]
    296c:	68db      	ldr	r3, [r3, #12]
    296e:	69ba      	ldr	r2, [r7, #24]
    2970:	0010      	movs	r0, r2
    2972:	4798      	blx	r3
		}
	}

	/* Check if the Receive Complete interrupt has occurred, and that
	 * there's more data to receive */
	if (interrupt_status & SERCOM_USART_INTFLAG_RXC) {
    2974:	2312      	movs	r3, #18
    2976:	18fb      	adds	r3, r7, r3
    2978:	881b      	ldrh	r3, [r3, #0]
    297a:	2204      	movs	r2, #4
    297c:	4013      	ands	r3, r2
    297e:	d100      	bne.n	2982 <_usart_interrupt_handler+0x132>
    2980:	e0cb      	b.n	2b1a <_usart_interrupt_handler+0x2ca>

		if (module->remaining_rx_buffer_length) {
    2982:	69bb      	ldr	r3, [r7, #24]
    2984:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
    2986:	b29b      	uxth	r3, r3
    2988:	2b00      	cmp	r3, #0
    298a:	d100      	bne.n	298e <_usart_interrupt_handler+0x13e>
    298c:	e0c2      	b.n	2b14 <_usart_interrupt_handler+0x2c4>
			/* Read out the status code and mask away all but the 4 LSBs*/
			error_code = (uint8_t)(usart_hw->STATUS.reg & SERCOM_USART_STATUS_MASK);
    298e:	697b      	ldr	r3, [r7, #20]
    2990:	8b5b      	ldrh	r3, [r3, #26]
    2992:	b29b      	uxth	r3, r3
    2994:	b2da      	uxtb	r2, r3
    2996:	231f      	movs	r3, #31
    2998:	18fb      	adds	r3, r7, r3
    299a:	217f      	movs	r1, #127	; 0x7f
    299c:	400a      	ands	r2, r1
    299e:	701a      	strb	r2, [r3, #0]
#if !SAMD20
			/* CTS status should not be considered as an error */
			if(error_code & SERCOM_USART_STATUS_CTS) {
    29a0:	231f      	movs	r3, #31
    29a2:	18fb      	adds	r3, r7, r3
    29a4:	781b      	ldrb	r3, [r3, #0]
    29a6:	2208      	movs	r2, #8
    29a8:	4013      	ands	r3, r2
    29aa:	d007      	beq.n	29bc <_usart_interrupt_handler+0x16c>
				error_code &= ~SERCOM_USART_STATUS_CTS;
    29ac:	231f      	movs	r3, #31
    29ae:	18fb      	adds	r3, r7, r3
    29b0:	221f      	movs	r2, #31
    29b2:	18ba      	adds	r2, r7, r2
    29b4:	7812      	ldrb	r2, [r2, #0]
    29b6:	2108      	movs	r1, #8
    29b8:	438a      	bics	r2, r1
    29ba:	701a      	strb	r2, [r3, #0]
			}
#endif
#ifdef FEATURE_USART_LIN_MASTER
			/* TXE status should not be considered as an error */
			if(error_code & SERCOM_USART_STATUS_TXE) {
    29bc:	231f      	movs	r3, #31
    29be:	18fb      	adds	r3, r7, r3
    29c0:	781b      	ldrb	r3, [r3, #0]
    29c2:	2240      	movs	r2, #64	; 0x40
    29c4:	4013      	ands	r3, r2
    29c6:	d007      	beq.n	29d8 <_usart_interrupt_handler+0x188>
				error_code &= ~SERCOM_USART_STATUS_TXE;
    29c8:	231f      	movs	r3, #31
    29ca:	18fb      	adds	r3, r7, r3
    29cc:	221f      	movs	r2, #31
    29ce:	18ba      	adds	r2, r7, r2
    29d0:	7812      	ldrb	r2, [r2, #0]
    29d2:	2140      	movs	r1, #64	; 0x40
    29d4:	438a      	bics	r2, r1
    29d6:	701a      	strb	r2, [r3, #0]
			}
#endif
			/* Check if an error has occurred during the receiving */
			if (error_code) {
    29d8:	231f      	movs	r3, #31
    29da:	18fb      	adds	r3, r7, r3
    29dc:	781b      	ldrb	r3, [r3, #0]
    29de:	2b00      	cmp	r3, #0
    29e0:	d050      	beq.n	2a84 <_usart_interrupt_handler+0x234>
				/* Check which error occurred */
				if (error_code & SERCOM_USART_STATUS_FERR) {
    29e2:	231f      	movs	r3, #31
    29e4:	18fb      	adds	r3, r7, r3
    29e6:	781b      	ldrb	r3, [r3, #0]
    29e8:	2202      	movs	r2, #2
    29ea:	4013      	ands	r3, r2
    29ec:	d007      	beq.n	29fe <_usart_interrupt_handler+0x1ae>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_BAD_FORMAT;
    29ee:	69bb      	ldr	r3, [r7, #24]
    29f0:	2232      	movs	r2, #50	; 0x32
    29f2:	211a      	movs	r1, #26
    29f4:	5499      	strb	r1, [r3, r2]
					usart_hw->STATUS.reg = SERCOM_USART_STATUS_FERR;
    29f6:	697b      	ldr	r3, [r7, #20]
    29f8:	2202      	movs	r2, #2
    29fa:	835a      	strh	r2, [r3, #26]
    29fc:	e036      	b.n	2a6c <_usart_interrupt_handler+0x21c>
				} else if (error_code & SERCOM_USART_STATUS_BUFOVF) {
    29fe:	231f      	movs	r3, #31
    2a00:	18fb      	adds	r3, r7, r3
    2a02:	781b      	ldrb	r3, [r3, #0]
    2a04:	2204      	movs	r2, #4
    2a06:	4013      	ands	r3, r2
    2a08:	d007      	beq.n	2a1a <_usart_interrupt_handler+0x1ca>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_OVERFLOW;
    2a0a:	69bb      	ldr	r3, [r7, #24]
    2a0c:	2232      	movs	r2, #50	; 0x32
    2a0e:	211e      	movs	r1, #30
    2a10:	5499      	strb	r1, [r3, r2]
					usart_hw->STATUS.reg = SERCOM_USART_STATUS_BUFOVF;
    2a12:	697b      	ldr	r3, [r7, #20]
    2a14:	2204      	movs	r2, #4
    2a16:	835a      	strh	r2, [r3, #26]
    2a18:	e028      	b.n	2a6c <_usart_interrupt_handler+0x21c>
				} else if (error_code & SERCOM_USART_STATUS_PERR) {
    2a1a:	231f      	movs	r3, #31
    2a1c:	18fb      	adds	r3, r7, r3
    2a1e:	781b      	ldrb	r3, [r3, #0]
    2a20:	2201      	movs	r2, #1
    2a22:	4013      	ands	r3, r2
    2a24:	d007      	beq.n	2a36 <_usart_interrupt_handler+0x1e6>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_BAD_DATA;
    2a26:	69bb      	ldr	r3, [r7, #24]
    2a28:	2232      	movs	r2, #50	; 0x32
    2a2a:	2113      	movs	r1, #19
    2a2c:	5499      	strb	r1, [r3, r2]
					usart_hw->STATUS.reg = SERCOM_USART_STATUS_PERR;
    2a2e:	697b      	ldr	r3, [r7, #20]
    2a30:	2201      	movs	r2, #1
    2a32:	835a      	strh	r2, [r3, #26]
    2a34:	e01a      	b.n	2a6c <_usart_interrupt_handler+0x21c>
				}
#ifdef FEATURE_USART_LIN_SLAVE
				else if (error_code & SERCOM_USART_STATUS_ISF) {
    2a36:	231f      	movs	r3, #31
    2a38:	18fb      	adds	r3, r7, r3
    2a3a:	781b      	ldrb	r3, [r3, #0]
    2a3c:	2210      	movs	r2, #16
    2a3e:	4013      	ands	r3, r2
    2a40:	d007      	beq.n	2a52 <_usart_interrupt_handler+0x202>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_PROTOCOL;
    2a42:	69bb      	ldr	r3, [r7, #24]
    2a44:	2232      	movs	r2, #50	; 0x32
    2a46:	2142      	movs	r1, #66	; 0x42
    2a48:	5499      	strb	r1, [r3, r2]
					usart_hw->STATUS.reg = SERCOM_USART_STATUS_ISF;
    2a4a:	697b      	ldr	r3, [r7, #20]
    2a4c:	2210      	movs	r2, #16
    2a4e:	835a      	strh	r2, [r3, #26]
    2a50:	e00c      	b.n	2a6c <_usart_interrupt_handler+0x21c>
				}
#endif
#ifdef FEATURE_USART_COLLISION_DECTION
				else if (error_code & SERCOM_USART_STATUS_COLL) {
    2a52:	231f      	movs	r3, #31
    2a54:	18fb      	adds	r3, r7, r3
    2a56:	781b      	ldrb	r3, [r3, #0]
    2a58:	2220      	movs	r2, #32
    2a5a:	4013      	ands	r3, r2
    2a5c:	d006      	beq.n	2a6c <_usart_interrupt_handler+0x21c>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_PACKET_COLLISION;
    2a5e:	69bb      	ldr	r3, [r7, #24]
    2a60:	2232      	movs	r2, #50	; 0x32
    2a62:	2141      	movs	r1, #65	; 0x41
    2a64:	5499      	strb	r1, [r3, r2]
					usart_hw->STATUS.reg = SERCOM_USART_STATUS_COLL;
    2a66:	697b      	ldr	r3, [r7, #20]
    2a68:	2220      	movs	r2, #32
    2a6a:	835a      	strh	r2, [r3, #26]
				}
#endif

				/* Run callback if registered and enabled */
				if (callback_status
						& (1 << USART_CALLBACK_ERROR)) {
    2a6c:	2310      	movs	r3, #16
    2a6e:	18fb      	adds	r3, r7, r3
    2a70:	881b      	ldrh	r3, [r3, #0]
    2a72:	2204      	movs	r2, #4
    2a74:	4013      	ands	r3, r2
				if (callback_status
    2a76:	d050      	beq.n	2b1a <_usart_interrupt_handler+0x2ca>
					(*(module->callback[USART_CALLBACK_ERROR]))(module);
    2a78:	69bb      	ldr	r3, [r7, #24]
    2a7a:	695b      	ldr	r3, [r3, #20]
    2a7c:	69ba      	ldr	r2, [r7, #24]
    2a7e:	0010      	movs	r0, r2
    2a80:	4798      	blx	r3
    2a82:	e04a      	b.n	2b1a <_usart_interrupt_handler+0x2ca>

			} else {

				/* Read current packet from DATA register,
				 * increment buffer pointer and decrement buffer length */
				uint16_t received_data = (usart_hw->DATA.reg & SERCOM_USART_DATA_MASK);
    2a84:	697b      	ldr	r3, [r7, #20]
    2a86:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    2a88:	b29a      	uxth	r2, r3
    2a8a:	230e      	movs	r3, #14
    2a8c:	18fb      	adds	r3, r7, r3
    2a8e:	05d2      	lsls	r2, r2, #23
    2a90:	0dd2      	lsrs	r2, r2, #23
    2a92:	801a      	strh	r2, [r3, #0]

				/* Read value will be at least 8-bits long */
				*(module->rx_buffer_ptr) = received_data;
    2a94:	69bb      	ldr	r3, [r7, #24]
    2a96:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    2a98:	220e      	movs	r2, #14
    2a9a:	18ba      	adds	r2, r7, r2
    2a9c:	8812      	ldrh	r2, [r2, #0]
    2a9e:	b2d2      	uxtb	r2, r2
    2aa0:	701a      	strb	r2, [r3, #0]
				/* Increment 8-bit pointer */
				module->rx_buffer_ptr += 1;
    2aa2:	69bb      	ldr	r3, [r7, #24]
    2aa4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    2aa6:	1c5a      	adds	r2, r3, #1
    2aa8:	69bb      	ldr	r3, [r7, #24]
    2aaa:	625a      	str	r2, [r3, #36]	; 0x24

				if (module->character_size == USART_CHARACTER_SIZE_9BIT) {
    2aac:	69bb      	ldr	r3, [r7, #24]
    2aae:	795b      	ldrb	r3, [r3, #5]
    2ab0:	2b01      	cmp	r3, #1
    2ab2:	d10d      	bne.n	2ad0 <_usart_interrupt_handler+0x280>
					/* 9-bit data, write next received byte to the buffer */
					*(module->rx_buffer_ptr) = (received_data >> 8);
    2ab4:	69bb      	ldr	r3, [r7, #24]
    2ab6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    2ab8:	220e      	movs	r2, #14
    2aba:	18ba      	adds	r2, r7, r2
    2abc:	8812      	ldrh	r2, [r2, #0]
    2abe:	0a12      	lsrs	r2, r2, #8
    2ac0:	b292      	uxth	r2, r2
    2ac2:	b2d2      	uxtb	r2, r2
    2ac4:	701a      	strb	r2, [r3, #0]
					/* Increment 8-bit pointer */
					module->rx_buffer_ptr += 1;
    2ac6:	69bb      	ldr	r3, [r7, #24]
    2ac8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    2aca:	1c5a      	adds	r2, r3, #1
    2acc:	69bb      	ldr	r3, [r7, #24]
    2ace:	625a      	str	r2, [r3, #36]	; 0x24
				}

				/* Check if the last character have been received */
				if(--(module->remaining_rx_buffer_length) == 0) {
    2ad0:	69bb      	ldr	r3, [r7, #24]
    2ad2:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
    2ad4:	b29b      	uxth	r3, r3
    2ad6:	3b01      	subs	r3, #1
    2ad8:	b29b      	uxth	r3, r3
    2ada:	69ba      	ldr	r2, [r7, #24]
    2adc:	1c19      	adds	r1, r3, #0
    2ade:	8591      	strh	r1, [r2, #44]	; 0x2c
    2ae0:	2b00      	cmp	r3, #0
    2ae2:	d11a      	bne.n	2b1a <_usart_interrupt_handler+0x2ca>
					/* Disable RX Complete Interrupt,
					 * and set STATUS_OK */
					usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_RXC;
    2ae4:	697b      	ldr	r3, [r7, #20]
    2ae6:	2204      	movs	r2, #4
    2ae8:	751a      	strb	r2, [r3, #20]
					module->rx_status = STATUS_OK;
    2aea:	69bb      	ldr	r3, [r7, #24]
    2aec:	2232      	movs	r2, #50	; 0x32
    2aee:	2100      	movs	r1, #0
    2af0:	5499      	strb	r1, [r3, r2]

					/* Run callback if registered and enabled */
					if (callback_status
							& (1 << USART_CALLBACK_BUFFER_RECEIVED)) {
    2af2:	2310      	movs	r3, #16
    2af4:	18fb      	adds	r3, r7, r3
    2af6:	881b      	ldrh	r3, [r3, #0]
    2af8:	2202      	movs	r2, #2
    2afa:	4013      	ands	r3, r2
					if (callback_status
    2afc:	d00d      	beq.n	2b1a <_usart_interrupt_handler+0x2ca>
						(*(module->callback[USART_CALLBACK_BUFFER_RECEIVED]))(module);
    2afe:	69bb      	ldr	r3, [r7, #24]
    2b00:	691b      	ldr	r3, [r3, #16]
    2b02:	69ba      	ldr	r2, [r7, #24]
    2b04:	0010      	movs	r0, r2
    2b06:	4798      	blx	r3
    2b08:	e007      	b.n	2b1a <_usart_interrupt_handler+0x2ca>
    2b0a:	46c0      	nop			; (mov r8, r8)
    2b0c:	20003314 	.word	0x20003314
    2b10:	00002681 	.word	0x00002681
					}
				}
			}
		} else {
			/* This should not happen. Disable Receive Complete interrupt. */
			usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_RXC;
    2b14:	697b      	ldr	r3, [r7, #20]
    2b16:	2204      	movs	r2, #4
    2b18:	751a      	strb	r2, [r3, #20]
		}
	}

#ifdef FEATURE_USART_HARDWARE_FLOW_CONTROL
	if (interrupt_status & SERCOM_USART_INTFLAG_CTSIC) {
    2b1a:	2312      	movs	r3, #18
    2b1c:	18fb      	adds	r3, r7, r3
    2b1e:	881b      	ldrh	r3, [r3, #0]
    2b20:	2210      	movs	r2, #16
    2b22:	4013      	ands	r3, r2
    2b24:	d010      	beq.n	2b48 <_usart_interrupt_handler+0x2f8>
		/* Disable interrupts */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTENCLR_CTSIC;
    2b26:	697b      	ldr	r3, [r7, #20]
    2b28:	2210      	movs	r2, #16
    2b2a:	751a      	strb	r2, [r3, #20]
		/* Clear interrupt flag */
		usart_hw->INTFLAG.reg = SERCOM_USART_INTFLAG_CTSIC;
    2b2c:	697b      	ldr	r3, [r7, #20]
    2b2e:	2210      	movs	r2, #16
    2b30:	761a      	strb	r2, [r3, #24]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_CTS_INPUT_CHANGE)) {
    2b32:	2310      	movs	r3, #16
    2b34:	18fb      	adds	r3, r7, r3
    2b36:	881b      	ldrh	r3, [r3, #0]
    2b38:	2210      	movs	r2, #16
    2b3a:	4013      	ands	r3, r2
    2b3c:	d004      	beq.n	2b48 <_usart_interrupt_handler+0x2f8>
			(*(module->callback[USART_CALLBACK_CTS_INPUT_CHANGE]))(module);
    2b3e:	69bb      	ldr	r3, [r7, #24]
    2b40:	69db      	ldr	r3, [r3, #28]
    2b42:	69ba      	ldr	r2, [r7, #24]
    2b44:	0010      	movs	r0, r2
    2b46:	4798      	blx	r3
		}
	}
#endif

#ifdef FEATURE_USART_LIN_SLAVE
	if (interrupt_status & SERCOM_USART_INTFLAG_RXBRK) {
    2b48:	2312      	movs	r3, #18
    2b4a:	18fb      	adds	r3, r7, r3
    2b4c:	881b      	ldrh	r3, [r3, #0]
    2b4e:	2220      	movs	r2, #32
    2b50:	4013      	ands	r3, r2
    2b52:	d010      	beq.n	2b76 <_usart_interrupt_handler+0x326>
		/* Disable interrupts */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTENCLR_RXBRK;
    2b54:	697b      	ldr	r3, [r7, #20]
    2b56:	2220      	movs	r2, #32
    2b58:	751a      	strb	r2, [r3, #20]
		/* Clear interrupt flag */
		usart_hw->INTFLAG.reg = SERCOM_USART_INTFLAG_RXBRK;
    2b5a:	697b      	ldr	r3, [r7, #20]
    2b5c:	2220      	movs	r2, #32
    2b5e:	761a      	strb	r2, [r3, #24]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_BREAK_RECEIVED)) {
    2b60:	2310      	movs	r3, #16
    2b62:	18fb      	adds	r3, r7, r3
    2b64:	881b      	ldrh	r3, [r3, #0]
    2b66:	2208      	movs	r2, #8
    2b68:	4013      	ands	r3, r2
    2b6a:	d004      	beq.n	2b76 <_usart_interrupt_handler+0x326>
			(*(module->callback[USART_CALLBACK_BREAK_RECEIVED]))(module);
    2b6c:	69bb      	ldr	r3, [r7, #24]
    2b6e:	699b      	ldr	r3, [r3, #24]
    2b70:	69ba      	ldr	r2, [r7, #24]
    2b72:	0010      	movs	r0, r2
    2b74:	4798      	blx	r3
		}
	}
#endif

#ifdef FEATURE_USART_START_FRAME_DECTION
	if (interrupt_status & SERCOM_USART_INTFLAG_RXS) {
    2b76:	2312      	movs	r3, #18
    2b78:	18fb      	adds	r3, r7, r3
    2b7a:	881b      	ldrh	r3, [r3, #0]
    2b7c:	2208      	movs	r2, #8
    2b7e:	4013      	ands	r3, r2
    2b80:	d010      	beq.n	2ba4 <_usart_interrupt_handler+0x354>
		/* Disable interrupts */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTENCLR_RXS;
    2b82:	697b      	ldr	r3, [r7, #20]
    2b84:	2208      	movs	r2, #8
    2b86:	751a      	strb	r2, [r3, #20]
		/* Clear interrupt flag */
		usart_hw->INTFLAG.reg = SERCOM_USART_INTFLAG_RXS;
    2b88:	697b      	ldr	r3, [r7, #20]
    2b8a:	2208      	movs	r2, #8
    2b8c:	761a      	strb	r2, [r3, #24]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_START_RECEIVED)) {
    2b8e:	2310      	movs	r3, #16
    2b90:	18fb      	adds	r3, r7, r3
    2b92:	881b      	ldrh	r3, [r3, #0]
    2b94:	2220      	movs	r2, #32
    2b96:	4013      	ands	r3, r2
    2b98:	d004      	beq.n	2ba4 <_usart_interrupt_handler+0x354>
			(*(module->callback[USART_CALLBACK_START_RECEIVED]))(module);
    2b9a:	69bb      	ldr	r3, [r7, #24]
    2b9c:	6a1b      	ldr	r3, [r3, #32]
    2b9e:	69ba      	ldr	r2, [r7, #24]
    2ba0:	0010      	movs	r0, r2
    2ba2:	4798      	blx	r3
		}
	}
#endif
}
    2ba4:	46c0      	nop			; (mov r8, r8)
    2ba6:	46bd      	mov	sp, r7
    2ba8:	b008      	add	sp, #32
    2baa:	bd80      	pop	{r7, pc}

00002bac <system_gclk_gen_get_config_defaults>:
{
    2bac:	b580      	push	{r7, lr}
    2bae:	b082      	sub	sp, #8
    2bb0:	af00      	add	r7, sp, #0
    2bb2:	6078      	str	r0, [r7, #4]
	config->division_factor    = 1;
    2bb4:	687b      	ldr	r3, [r7, #4]
    2bb6:	2201      	movs	r2, #1
    2bb8:	605a      	str	r2, [r3, #4]
	config->high_when_disabled = false;
    2bba:	687b      	ldr	r3, [r7, #4]
    2bbc:	2200      	movs	r2, #0
    2bbe:	705a      	strb	r2, [r3, #1]
	config->source_clock       = GCLK_SOURCE_OSC48M;
    2bc0:	687b      	ldr	r3, [r7, #4]
    2bc2:	2206      	movs	r2, #6
    2bc4:	701a      	strb	r2, [r3, #0]
	config->run_in_standby     = false;
    2bc6:	687b      	ldr	r3, [r7, #4]
    2bc8:	2200      	movs	r2, #0
    2bca:	721a      	strb	r2, [r3, #8]
	config->output_enable      = false;
    2bcc:	687b      	ldr	r3, [r7, #4]
    2bce:	2200      	movs	r2, #0
    2bd0:	725a      	strb	r2, [r3, #9]
}
    2bd2:	46c0      	nop			; (mov r8, r8)
    2bd4:	46bd      	mov	sp, r7
    2bd6:	b002      	add	sp, #8
    2bd8:	bd80      	pop	{r7, pc}
	...

00002bdc <system_cpu_clock_set_divider>:
{
    2bdc:	b580      	push	{r7, lr}
    2bde:	b082      	sub	sp, #8
    2be0:	af00      	add	r7, sp, #0
    2be2:	0002      	movs	r2, r0
    2be4:	1dfb      	adds	r3, r7, #7
    2be6:	701a      	strb	r2, [r3, #0]
	MCLK->CPUDIV.reg = MCLK_CPUDIV_CPUDIV(1 << divider);
    2be8:	4a05      	ldr	r2, [pc, #20]	; (2c00 <system_cpu_clock_set_divider+0x24>)
    2bea:	1dfb      	adds	r3, r7, #7
    2bec:	781b      	ldrb	r3, [r3, #0]
    2bee:	2101      	movs	r1, #1
    2bf0:	4099      	lsls	r1, r3
    2bf2:	000b      	movs	r3, r1
    2bf4:	b2db      	uxtb	r3, r3
    2bf6:	7113      	strb	r3, [r2, #4]
}
    2bf8:	46c0      	nop			; (mov r8, r8)
    2bfa:	46bd      	mov	sp, r7
    2bfc:	b002      	add	sp, #8
    2bfe:	bd80      	pop	{r7, pc}
    2c00:	40000800 	.word	0x40000800

00002c04 <system_flash_set_waitstates>:
 * can be found in the electrical characteristics of the device.
 *
 * \param[in] wait_states Number of wait states to use for internal flash
 */
static inline void system_flash_set_waitstates(uint8_t wait_states)
{
    2c04:	b580      	push	{r7, lr}
    2c06:	b082      	sub	sp, #8
    2c08:	af00      	add	r7, sp, #0
    2c0a:	0002      	movs	r2, r0
    2c0c:	1dfb      	adds	r3, r7, #7
    2c0e:	701a      	strb	r2, [r3, #0]
	Assert(NVMCTRL_CTRLB_RWS((uint32_t)wait_states) ==
			((uint32_t)wait_states << NVMCTRL_CTRLB_RWS_Pos));

	NVMCTRL->CTRLB.bit.RWS = wait_states;
    2c10:	4a08      	ldr	r2, [pc, #32]	; (2c34 <system_flash_set_waitstates+0x30>)
    2c12:	1dfb      	adds	r3, r7, #7
    2c14:	781b      	ldrb	r3, [r3, #0]
    2c16:	210f      	movs	r1, #15
    2c18:	400b      	ands	r3, r1
    2c1a:	b2d9      	uxtb	r1, r3
    2c1c:	6853      	ldr	r3, [r2, #4]
    2c1e:	200f      	movs	r0, #15
    2c20:	4001      	ands	r1, r0
    2c22:	0049      	lsls	r1, r1, #1
    2c24:	201e      	movs	r0, #30
    2c26:	4383      	bics	r3, r0
    2c28:	430b      	orrs	r3, r1
    2c2a:	6053      	str	r3, [r2, #4]
}
    2c2c:	46c0      	nop			; (mov r8, r8)
    2c2e:	46bd      	mov	sp, r7
    2c30:	b002      	add	sp, #8
    2c32:	bd80      	pop	{r7, pc}
    2c34:	41004000 	.word	0x41004000

00002c38 <system_clock_source_get_hz>:
 *
 * \returns Frequency of the given clock source, in Hz.
 */
uint32_t system_clock_source_get_hz(
		const enum system_clock_source clock_source)
{
    2c38:	b580      	push	{r7, lr}
    2c3a:	b082      	sub	sp, #8
    2c3c:	af00      	add	r7, sp, #0
    2c3e:	0002      	movs	r2, r0
    2c40:	1dfb      	adds	r3, r7, #7
    2c42:	701a      	strb	r2, [r3, #0]
	switch (clock_source) {
    2c44:	1dfb      	adds	r3, r7, #7
    2c46:	781b      	ldrb	r3, [r3, #0]
    2c48:	2b07      	cmp	r3, #7
    2c4a:	d829      	bhi.n	2ca0 <system_clock_source_get_hz+0x68>
    2c4c:	009a      	lsls	r2, r3, #2
    2c4e:	4b17      	ldr	r3, [pc, #92]	; (2cac <system_clock_source_get_hz+0x74>)
    2c50:	18d3      	adds	r3, r2, r3
    2c52:	681b      	ldr	r3, [r3, #0]
    2c54:	469f      	mov	pc, r3
	case SYSTEM_CLOCK_SOURCE_XOSC:
		return _system_clock_inst.xosc.frequency;
    2c56:	4b16      	ldr	r3, [pc, #88]	; (2cb0 <system_clock_source_get_hz+0x78>)
    2c58:	685b      	ldr	r3, [r3, #4]
    2c5a:	e022      	b.n	2ca2 <system_clock_source_get_hz+0x6a>

	case SYSTEM_CLOCK_SOURCE_OSC48M:
		return 48000000UL / (OSCCTRL->OSC48MDIV.bit.DIV + 1);
    2c5c:	4b15      	ldr	r3, [pc, #84]	; (2cb4 <system_clock_source_get_hz+0x7c>)
    2c5e:	7d5b      	ldrb	r3, [r3, #21]
    2c60:	071b      	lsls	r3, r3, #28
    2c62:	0f1b      	lsrs	r3, r3, #28
    2c64:	b2db      	uxtb	r3, r3
    2c66:	3301      	adds	r3, #1
    2c68:	001a      	movs	r2, r3
    2c6a:	4b13      	ldr	r3, [pc, #76]	; (2cb8 <system_clock_source_get_hz+0x80>)
    2c6c:	0011      	movs	r1, r2
    2c6e:	4813      	ldr	r0, [pc, #76]	; (2cbc <system_clock_source_get_hz+0x84>)
    2c70:	4798      	blx	r3
    2c72:	0003      	movs	r3, r0
    2c74:	e015      	b.n	2ca2 <system_clock_source_get_hz+0x6a>

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		return 32768UL;
    2c76:	2380      	movs	r3, #128	; 0x80
    2c78:	021b      	lsls	r3, r3, #8
    2c7a:	e012      	b.n	2ca2 <system_clock_source_get_hz+0x6a>

	case SYSTEM_CLOCK_SOURCE_ULP32K:
		return 32768UL;
    2c7c:	2380      	movs	r3, #128	; 0x80
    2c7e:	021b      	lsls	r3, r3, #8
    2c80:	e00f      	b.n	2ca2 <system_clock_source_get_hz+0x6a>

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		return _system_clock_inst.xosc32k.frequency;
    2c82:	4b0b      	ldr	r3, [pc, #44]	; (2cb0 <system_clock_source_get_hz+0x78>)
    2c84:	689b      	ldr	r3, [r3, #8]
    2c86:	e00c      	b.n	2ca2 <system_clock_source_get_hz+0x6a>

	case SYSTEM_CLOCK_SOURCE_DPLL:
		if (!(OSCCTRL->DPLLCTRLA.reg & OSCCTRL_DPLLCTRLA_ENABLE)) {
    2c88:	4b0a      	ldr	r3, [pc, #40]	; (2cb4 <system_clock_source_get_hz+0x7c>)
    2c8a:	7f1b      	ldrb	r3, [r3, #28]
    2c8c:	b2db      	uxtb	r3, r3
    2c8e:	001a      	movs	r2, r3
    2c90:	2302      	movs	r3, #2
    2c92:	4013      	ands	r3, r2
    2c94:	d101      	bne.n	2c9a <system_clock_source_get_hz+0x62>
			return 0;
    2c96:	2300      	movs	r3, #0
    2c98:	e003      	b.n	2ca2 <system_clock_source_get_hz+0x6a>
		}

		return _system_clock_inst.dpll.frequency;
    2c9a:	4b05      	ldr	r3, [pc, #20]	; (2cb0 <system_clock_source_get_hz+0x78>)
    2c9c:	681b      	ldr	r3, [r3, #0]
    2c9e:	e000      	b.n	2ca2 <system_clock_source_get_hz+0x6a>

	default:
		return 0;
    2ca0:	2300      	movs	r3, #0
	}
}
    2ca2:	0018      	movs	r0, r3
    2ca4:	46bd      	mov	sp, r7
    2ca6:	b002      	add	sp, #8
    2ca8:	bd80      	pop	{r7, pc}
    2caa:	46c0      	nop			; (mov r8, r8)
    2cac:	00007320 	.word	0x00007320
    2cb0:	20000984 	.word	0x20000984
    2cb4:	40001000 	.word	0x40001000
    2cb8:	00006a1d 	.word	0x00006a1d
    2cbc:	02dc6c00 	.word	0x02dc6c00

00002cc0 <system_clock_init>:
 * \note OSC48M is always enabled and if the user selects other clocks for GCLK generators,
 * the OSC48M default enable can be disabled after system_clock_init. Make sure the
 * clock switches successfully before disabling OSC48M.
 */
void system_clock_init(void)
{
    2cc0:	b580      	push	{r7, lr}
    2cc2:	b09e      	sub	sp, #120	; 0x78
    2cc4:	af00      	add	r7, sp, #0
	/* Various bits in the INTFLAG register can be set to one at startup.
	   This will ensure that these bits are cleared */
	SUPC->INTFLAG.reg = SUPC_INTFLAG_BODVDDRDY | SUPC_INTFLAG_BODVDDDET;
    2cc6:	4b2b      	ldr	r3, [pc, #172]	; (2d74 <system_clock_init+0xb4>)
    2cc8:	2203      	movs	r2, #3
    2cca:	609a      	str	r2, [r3, #8]

	system_flash_set_waitstates(CONF_CLOCK_FLASH_WAIT_STATES);
    2ccc:	2002      	movs	r0, #2
    2cce:	4b2a      	ldr	r3, [pc, #168]	; (2d78 <system_clock_init+0xb8>)
    2cd0:	4798      	blx	r3
	system_clock_source_osc32k_set_config(&osc32k_conf);
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_OSC32K);
#endif

	/* OSC48M */
	OSCCTRL->OSC48MCTRL.reg |= (CONF_CLOCK_OSC48M_ON_DEMAND << OSCCTRL_OSC48MCTRL_ONDEMAND_Pos)
    2cd2:	492a      	ldr	r1, [pc, #168]	; (2d7c <system_clock_init+0xbc>)
    2cd4:	4b29      	ldr	r3, [pc, #164]	; (2d7c <system_clock_init+0xbc>)
    2cd6:	7d1b      	ldrb	r3, [r3, #20]
    2cd8:	b2db      	uxtb	r3, r3
    2cda:	2280      	movs	r2, #128	; 0x80
    2cdc:	4252      	negs	r2, r2
    2cde:	4313      	orrs	r3, r2
    2ce0:	b2db      	uxtb	r3, r3
    2ce2:	750b      	strb	r3, [r1, #20]
								|(CONF_CLOCK_OSC48M_RUN_IN_STANDBY << OSCCTRL_OSC48MCTRL_RUNSTDBY_Pos);

	if (CONF_CLOCK_OSC48M_FREQ_DIV != SYSTEM_OSC48M_DIV_12){
		OSCCTRL->OSC48MDIV.reg = OSCCTRL_OSC48MDIV_DIV(CONF_CLOCK_OSC48M_FREQ_DIV);
    2ce4:	4b25      	ldr	r3, [pc, #148]	; (2d7c <system_clock_init+0xbc>)
    2ce6:	2200      	movs	r2, #0
    2ce8:	755a      	strb	r2, [r3, #21]
		while(OSCCTRL->OSC48MSYNCBUSY.reg) ;
    2cea:	46c0      	nop			; (mov r8, r8)
    2cec:	4b23      	ldr	r3, [pc, #140]	; (2d7c <system_clock_init+0xbc>)
    2cee:	699b      	ldr	r3, [r3, #24]
    2cf0:	2b00      	cmp	r3, #0
    2cf2:	d1fb      	bne.n	2cec <system_clock_init+0x2c>
	}

	/* GCLK */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	system_gclk_init();
    2cf4:	4b22      	ldr	r3, [pc, #136]	; (2d80 <system_clock_init+0xc0>)
    2cf6:	4798      	blx	r3

	/* Configure all GCLK generators except for the main generator, which
	 * is configured later after all other clock systems are set up */
	MREPEAT(GCLK_GEN_NUM, _CONF_CLOCK_GCLK_CONFIG_NONMAIN, ~);
    2cf8:	230c      	movs	r3, #12
    2cfa:	18fb      	adds	r3, r7, r3
    2cfc:	0018      	movs	r0, r3
    2cfe:	4b21      	ldr	r3, [pc, #132]	; (2d84 <system_clock_init+0xc4>)
    2d00:	4798      	blx	r3
    2d02:	230c      	movs	r3, #12
    2d04:	18fb      	adds	r3, r7, r3
    2d06:	2206      	movs	r2, #6
    2d08:	701a      	strb	r2, [r3, #0]
    2d0a:	230c      	movs	r3, #12
    2d0c:	18fb      	adds	r3, r7, r3
    2d0e:	2201      	movs	r2, #1
    2d10:	605a      	str	r2, [r3, #4]
    2d12:	230c      	movs	r3, #12
    2d14:	18fb      	adds	r3, r7, r3
    2d16:	2200      	movs	r2, #0
    2d18:	721a      	strb	r2, [r3, #8]
    2d1a:	230c      	movs	r3, #12
    2d1c:	18fb      	adds	r3, r7, r3
    2d1e:	2200      	movs	r2, #0
    2d20:	725a      	strb	r2, [r3, #9]
    2d22:	230c      	movs	r3, #12
    2d24:	18fb      	adds	r3, r7, r3
    2d26:	0019      	movs	r1, r3
    2d28:	2008      	movs	r0, #8
    2d2a:	4b17      	ldr	r3, [pc, #92]	; (2d88 <system_clock_init+0xc8>)
    2d2c:	4798      	blx	r3
    2d2e:	2008      	movs	r0, #8
    2d30:	4b16      	ldr	r3, [pc, #88]	; (2d8c <system_clock_init+0xcc>)
    2d32:	4798      	blx	r3
	}

#  endif

	/* CPU and BUS clocks */
	system_cpu_clock_set_divider(CONF_CLOCK_CPU_DIVIDER);
    2d34:	2000      	movs	r0, #0
    2d36:	4b16      	ldr	r3, [pc, #88]	; (2d90 <system_clock_init+0xd0>)
    2d38:	4798      	blx	r3

	/* GCLK 0 */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	/* Configure the main GCLK last as it might depend on other generators */
	_CONF_CLOCK_GCLK_CONFIG(0, ~);
    2d3a:	003b      	movs	r3, r7
    2d3c:	0018      	movs	r0, r3
    2d3e:	4b11      	ldr	r3, [pc, #68]	; (2d84 <system_clock_init+0xc4>)
    2d40:	4798      	blx	r3
    2d42:	003b      	movs	r3, r7
    2d44:	2206      	movs	r2, #6
    2d46:	701a      	strb	r2, [r3, #0]
    2d48:	003b      	movs	r3, r7
    2d4a:	2201      	movs	r2, #1
    2d4c:	605a      	str	r2, [r3, #4]
    2d4e:	003b      	movs	r3, r7
    2d50:	2200      	movs	r2, #0
    2d52:	721a      	strb	r2, [r3, #8]
    2d54:	003b      	movs	r3, r7
    2d56:	2200      	movs	r2, #0
    2d58:	725a      	strb	r2, [r3, #9]
    2d5a:	003b      	movs	r3, r7
    2d5c:	0019      	movs	r1, r3
    2d5e:	2000      	movs	r0, #0
    2d60:	4b09      	ldr	r3, [pc, #36]	; (2d88 <system_clock_init+0xc8>)
    2d62:	4798      	blx	r3
    2d64:	2000      	movs	r0, #0
    2d66:	4b09      	ldr	r3, [pc, #36]	; (2d8c <system_clock_init+0xcc>)
    2d68:	4798      	blx	r3
#endif

}
    2d6a:	46c0      	nop			; (mov r8, r8)
    2d6c:	46bd      	mov	sp, r7
    2d6e:	b01e      	add	sp, #120	; 0x78
    2d70:	bd80      	pop	{r7, pc}
    2d72:	46c0      	nop			; (mov r8, r8)
    2d74:	40001800 	.word	0x40001800
    2d78:	00002c05 	.word	0x00002c05
    2d7c:	40001000 	.word	0x40001000
    2d80:	000063fd 	.word	0x000063fd
    2d84:	00002bad 	.word	0x00002bad
    2d88:	0000642d 	.word	0x0000642d
    2d8c:	0000653d 	.word	0x0000653d
    2d90:	00002bdd 	.word	0x00002bdd

00002d94 <_system_dummy_init>:
 * Dummy initialization function, used as a weak alias target for the various
 * init functions called by \ref system_init().
 */
void _system_dummy_init(void);
void _system_dummy_init(void)
{
    2d94:	b580      	push	{r7, lr}
    2d96:	af00      	add	r7, sp, #0
	return;
    2d98:	46c0      	nop			; (mov r8, r8)
}
    2d9a:	46bd      	mov	sp, r7
    2d9c:	bd80      	pop	{r7, pc}
	...

00002da0 <system_init>:
 *  - Board hardware initialization (via the Board module)
 *  - Event system driver initialization (via the EVSYS module)
 *  - External Interrupt driver initialization (via the EXTINT module)
 */
void system_init(void)
{
    2da0:	b580      	push	{r7, lr}
    2da2:	af00      	add	r7, sp, #0
	/* Configure GCLK and clock sources according to conf_clocks.h */
	system_clock_init();
    2da4:	4b06      	ldr	r3, [pc, #24]	; (2dc0 <system_init+0x20>)
    2da6:	4798      	blx	r3

	/* Initialize board hardware */
	system_board_init();
    2da8:	4b06      	ldr	r3, [pc, #24]	; (2dc4 <system_init+0x24>)
    2daa:	4798      	blx	r3

	/* Initialize EVSYS hardware */
	_system_events_init();
    2dac:	4b06      	ldr	r3, [pc, #24]	; (2dc8 <system_init+0x28>)
    2dae:	4798      	blx	r3

	/* Initialize External hardware */
	_system_extint_init();
    2db0:	4b06      	ldr	r3, [pc, #24]	; (2dcc <system_init+0x2c>)
    2db2:	4798      	blx	r3
	
	/* Initialize DIVAS hardware */
	_system_divas_init();
    2db4:	4b06      	ldr	r3, [pc, #24]	; (2dd0 <system_init+0x30>)
    2db6:	4798      	blx	r3
}
    2db8:	46c0      	nop			; (mov r8, r8)
    2dba:	46bd      	mov	sp, r7
    2dbc:	bd80      	pop	{r7, pc}
    2dbe:	46c0      	nop			; (mov r8, r8)
    2dc0:	00002cc1 	.word	0x00002cc1
    2dc4:	00006265 	.word	0x00006265
    2dc8:	00002d95 	.word	0x00002d95
    2dcc:	00002d95 	.word	0x00002d95
    2dd0:	00002d95 	.word	0x00002d95

00002dd4 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    2dd4:	b580      	push	{r7, lr}
    2dd6:	b082      	sub	sp, #8
    2dd8:	af00      	add	r7, sp, #0
    2dda:	6078      	str	r0, [r7, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2ddc:	687b      	ldr	r3, [r7, #4]
    2dde:	3308      	adds	r3, #8
    2de0:	001a      	movs	r2, r3
    2de2:	687b      	ldr	r3, [r7, #4]
    2de4:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2de6:	687b      	ldr	r3, [r7, #4]
    2de8:	2201      	movs	r2, #1
    2dea:	4252      	negs	r2, r2
    2dec:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2dee:	687b      	ldr	r3, [r7, #4]
    2df0:	3308      	adds	r3, #8
    2df2:	001a      	movs	r2, r3
    2df4:	687b      	ldr	r3, [r7, #4]
    2df6:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2df8:	687b      	ldr	r3, [r7, #4]
    2dfa:	3308      	adds	r3, #8
    2dfc:	001a      	movs	r2, r3
    2dfe:	687b      	ldr	r3, [r7, #4]
    2e00:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    2e02:	687b      	ldr	r3, [r7, #4]
    2e04:	2200      	movs	r2, #0
    2e06:	601a      	str	r2, [r3, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    2e08:	46c0      	nop			; (mov r8, r8)
    2e0a:	46bd      	mov	sp, r7
    2e0c:	b002      	add	sp, #8
    2e0e:	bd80      	pop	{r7, pc}

00002e10 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    2e10:	b580      	push	{r7, lr}
    2e12:	b082      	sub	sp, #8
    2e14:	af00      	add	r7, sp, #0
    2e16:	6078      	str	r0, [r7, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    2e18:	687b      	ldr	r3, [r7, #4]
    2e1a:	2200      	movs	r2, #0
    2e1c:	611a      	str	r2, [r3, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    2e1e:	46c0      	nop			; (mov r8, r8)
    2e20:	46bd      	mov	sp, r7
    2e22:	b002      	add	sp, #8
    2e24:	bd80      	pop	{r7, pc}

00002e26 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2e26:	b580      	push	{r7, lr}
    2e28:	b084      	sub	sp, #16
    2e2a:	af00      	add	r7, sp, #0
    2e2c:	6078      	str	r0, [r7, #4]
    2e2e:	6039      	str	r1, [r7, #0]
ListItem_t * const pxIndex = pxList->pxIndex;
    2e30:	687b      	ldr	r3, [r7, #4]
    2e32:	685b      	ldr	r3, [r3, #4]
    2e34:	60fb      	str	r3, [r7, #12]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    2e36:	683b      	ldr	r3, [r7, #0]
    2e38:	68fa      	ldr	r2, [r7, #12]
    2e3a:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    2e3c:	68fb      	ldr	r3, [r7, #12]
    2e3e:	689a      	ldr	r2, [r3, #8]
    2e40:	683b      	ldr	r3, [r7, #0]
    2e42:	609a      	str	r2, [r3, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    2e44:	68fb      	ldr	r3, [r7, #12]
    2e46:	689b      	ldr	r3, [r3, #8]
    2e48:	683a      	ldr	r2, [r7, #0]
    2e4a:	605a      	str	r2, [r3, #4]
	pxIndex->pxPrevious = pxNewListItem;
    2e4c:	68fb      	ldr	r3, [r7, #12]
    2e4e:	683a      	ldr	r2, [r7, #0]
    2e50:	609a      	str	r2, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2e52:	683b      	ldr	r3, [r7, #0]
    2e54:	687a      	ldr	r2, [r7, #4]
    2e56:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
    2e58:	687b      	ldr	r3, [r7, #4]
    2e5a:	681b      	ldr	r3, [r3, #0]
    2e5c:	1c5a      	adds	r2, r3, #1
    2e5e:	687b      	ldr	r3, [r7, #4]
    2e60:	601a      	str	r2, [r3, #0]
}
    2e62:	46c0      	nop			; (mov r8, r8)
    2e64:	46bd      	mov	sp, r7
    2e66:	b004      	add	sp, #16
    2e68:	bd80      	pop	{r7, pc}

00002e6a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2e6a:	b580      	push	{r7, lr}
    2e6c:	b084      	sub	sp, #16
    2e6e:	af00      	add	r7, sp, #0
    2e70:	6078      	str	r0, [r7, #4]
    2e72:	6039      	str	r1, [r7, #0]
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    2e74:	683b      	ldr	r3, [r7, #0]
    2e76:	681b      	ldr	r3, [r3, #0]
    2e78:	60bb      	str	r3, [r7, #8]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    2e7a:	68bb      	ldr	r3, [r7, #8]
    2e7c:	3301      	adds	r3, #1
    2e7e:	d103      	bne.n	2e88 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    2e80:	687b      	ldr	r3, [r7, #4]
    2e82:	691b      	ldr	r3, [r3, #16]
    2e84:	60fb      	str	r3, [r7, #12]
    2e86:	e00c      	b.n	2ea2 <vListInsert+0x38>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2e88:	687b      	ldr	r3, [r7, #4]
    2e8a:	3308      	adds	r3, #8
    2e8c:	60fb      	str	r3, [r7, #12]
    2e8e:	e002      	b.n	2e96 <vListInsert+0x2c>
    2e90:	68fb      	ldr	r3, [r7, #12]
    2e92:	685b      	ldr	r3, [r3, #4]
    2e94:	60fb      	str	r3, [r7, #12]
    2e96:	68fb      	ldr	r3, [r7, #12]
    2e98:	685b      	ldr	r3, [r3, #4]
    2e9a:	681a      	ldr	r2, [r3, #0]
    2e9c:	68bb      	ldr	r3, [r7, #8]
    2e9e:	429a      	cmp	r2, r3
    2ea0:	d9f6      	bls.n	2e90 <vListInsert+0x26>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2ea2:	68fb      	ldr	r3, [r7, #12]
    2ea4:	685a      	ldr	r2, [r3, #4]
    2ea6:	683b      	ldr	r3, [r7, #0]
    2ea8:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    2eaa:	683b      	ldr	r3, [r7, #0]
    2eac:	685b      	ldr	r3, [r3, #4]
    2eae:	683a      	ldr	r2, [r7, #0]
    2eb0:	609a      	str	r2, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
    2eb2:	683b      	ldr	r3, [r7, #0]
    2eb4:	68fa      	ldr	r2, [r7, #12]
    2eb6:	609a      	str	r2, [r3, #8]
	pxIterator->pxNext = pxNewListItem;
    2eb8:	68fb      	ldr	r3, [r7, #12]
    2eba:	683a      	ldr	r2, [r7, #0]
    2ebc:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2ebe:	683b      	ldr	r3, [r7, #0]
    2ec0:	687a      	ldr	r2, [r7, #4]
    2ec2:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
    2ec4:	687b      	ldr	r3, [r7, #4]
    2ec6:	681b      	ldr	r3, [r3, #0]
    2ec8:	1c5a      	adds	r2, r3, #1
    2eca:	687b      	ldr	r3, [r7, #4]
    2ecc:	601a      	str	r2, [r3, #0]
}
    2ece:	46c0      	nop			; (mov r8, r8)
    2ed0:	46bd      	mov	sp, r7
    2ed2:	b004      	add	sp, #16
    2ed4:	bd80      	pop	{r7, pc}

00002ed6 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    2ed6:	b580      	push	{r7, lr}
    2ed8:	b084      	sub	sp, #16
    2eda:	af00      	add	r7, sp, #0
    2edc:	6078      	str	r0, [r7, #4]
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    2ede:	687b      	ldr	r3, [r7, #4]
    2ee0:	691b      	ldr	r3, [r3, #16]
    2ee2:	60fb      	str	r3, [r7, #12]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2ee4:	687b      	ldr	r3, [r7, #4]
    2ee6:	685b      	ldr	r3, [r3, #4]
    2ee8:	687a      	ldr	r2, [r7, #4]
    2eea:	6892      	ldr	r2, [r2, #8]
    2eec:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2eee:	687b      	ldr	r3, [r7, #4]
    2ef0:	689b      	ldr	r3, [r3, #8]
    2ef2:	687a      	ldr	r2, [r7, #4]
    2ef4:	6852      	ldr	r2, [r2, #4]
    2ef6:	605a      	str	r2, [r3, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    2ef8:	68fb      	ldr	r3, [r7, #12]
    2efa:	685a      	ldr	r2, [r3, #4]
    2efc:	687b      	ldr	r3, [r7, #4]
    2efe:	429a      	cmp	r2, r3
    2f00:	d103      	bne.n	2f0a <uxListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    2f02:	687b      	ldr	r3, [r7, #4]
    2f04:	689a      	ldr	r2, [r3, #8]
    2f06:	68fb      	ldr	r3, [r7, #12]
    2f08:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    2f0a:	687b      	ldr	r3, [r7, #4]
    2f0c:	2200      	movs	r2, #0
    2f0e:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
    2f10:	68fb      	ldr	r3, [r7, #12]
    2f12:	681b      	ldr	r3, [r3, #0]
    2f14:	1e5a      	subs	r2, r3, #1
    2f16:	68fb      	ldr	r3, [r7, #12]
    2f18:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
    2f1a:	68fb      	ldr	r3, [r7, #12]
    2f1c:	681b      	ldr	r3, [r3, #0]
}
    2f1e:	0018      	movs	r0, r3
    2f20:	46bd      	mov	sp, r7
    2f22:	b004      	add	sp, #16
    2f24:	bd80      	pop	{r7, pc}
	...

00002f28 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    2f28:	b580      	push	{r7, lr}
    2f2a:	b084      	sub	sp, #16
    2f2c:	af00      	add	r7, sp, #0
    2f2e:	60f8      	str	r0, [r7, #12]
    2f30:	60b9      	str	r1, [r7, #8]
    2f32:	607a      	str	r2, [r7, #4]
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
    2f34:	68fb      	ldr	r3, [r7, #12]
    2f36:	3b04      	subs	r3, #4
    2f38:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
    2f3a:	68fb      	ldr	r3, [r7, #12]
    2f3c:	2280      	movs	r2, #128	; 0x80
    2f3e:	0452      	lsls	r2, r2, #17
    2f40:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
    2f42:	68fb      	ldr	r3, [r7, #12]
    2f44:	3b04      	subs	r3, #4
    2f46:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
    2f48:	68ba      	ldr	r2, [r7, #8]
    2f4a:	68fb      	ldr	r3, [r7, #12]
    2f4c:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
    2f4e:	68fb      	ldr	r3, [r7, #12]
    2f50:	3b04      	subs	r3, #4
    2f52:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
    2f54:	4a08      	ldr	r2, [pc, #32]	; (2f78 <pxPortInitialiseStack+0x50>)
    2f56:	68fb      	ldr	r3, [r7, #12]
    2f58:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
    2f5a:	68fb      	ldr	r3, [r7, #12]
    2f5c:	3b14      	subs	r3, #20
    2f5e:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
    2f60:	687a      	ldr	r2, [r7, #4]
    2f62:	68fb      	ldr	r3, [r7, #12]
    2f64:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 8; /* R11..R4. */
    2f66:	68fb      	ldr	r3, [r7, #12]
    2f68:	3b20      	subs	r3, #32
    2f6a:	60fb      	str	r3, [r7, #12]

	return pxTopOfStack;
    2f6c:	68fb      	ldr	r3, [r7, #12]
}
    2f6e:	0018      	movs	r0, r3
    2f70:	46bd      	mov	sp, r7
    2f72:	b004      	add	sp, #16
    2f74:	bd80      	pop	{r7, pc}
    2f76:	46c0      	nop			; (mov r8, r8)
    2f78:	00002f7d 	.word	0x00002f7d

00002f7c <prvTaskExitError>:
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
    2f7c:	b580      	push	{r7, lr}
    2f7e:	b082      	sub	sp, #8
    2f80:	af00      	add	r7, sp, #0
volatile uint32_t ulDummy = 0UL;
    2f82:	2300      	movs	r3, #0
    2f84:	607b      	str	r3, [r7, #4]
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
    2f86:	4b07      	ldr	r3, [pc, #28]	; (2fa4 <prvTaskExitError+0x28>)
    2f88:	681b      	ldr	r3, [r3, #0]
    2f8a:	3301      	adds	r3, #1
    2f8c:	d001      	beq.n	2f92 <prvTaskExitError+0x16>
    2f8e:	b672      	cpsid	i
    2f90:	e7fe      	b.n	2f90 <prvTaskExitError+0x14>
	portDISABLE_INTERRUPTS();
    2f92:	b672      	cpsid	i
	while( ulDummy == 0 )
    2f94:	46c0      	nop			; (mov r8, r8)
    2f96:	687b      	ldr	r3, [r7, #4]
    2f98:	2b00      	cmp	r3, #0
    2f9a:	d0fc      	beq.n	2f96 <prvTaskExitError+0x1a>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
    2f9c:	46c0      	nop			; (mov r8, r8)
    2f9e:	46bd      	mov	sp, r7
    2fa0:	b002      	add	sp, #8
    2fa2:	bd80      	pop	{r7, pc}
    2fa4:	20000004 	.word	0x20000004
	...

00002fb0 <vPortStartFirstTask>:
void vPortStartFirstTask( void )
{
	/* The MSP stack is not reset as, unlike on M3/4 parts, there is no vector
	table offset register that can be used to locate the initial stack value.
	Not all M0 parts have the application vector table at address 0. */
	__asm volatile(
    2fb0:	4a0b      	ldr	r2, [pc, #44]	; (2fe0 <pxCurrentTCBConst2>)
    2fb2:	6813      	ldr	r3, [r2, #0]
    2fb4:	6818      	ldr	r0, [r3, #0]
    2fb6:	3020      	adds	r0, #32
    2fb8:	f380 8809 	msr	PSP, r0
    2fbc:	2002      	movs	r0, #2
    2fbe:	f380 8814 	msr	CONTROL, r0
    2fc2:	f3bf 8f6f 	isb	sy
    2fc6:	bc3f      	pop	{r0, r1, r2, r3, r4, r5}
    2fc8:	46ae      	mov	lr, r5
    2fca:	bc08      	pop	{r3}
    2fcc:	bc04      	pop	{r2}
    2fce:	b662      	cpsie	i
    2fd0:	4718      	bx	r3
    2fd2:	46c0      	nop			; (mov r8, r8)
    2fd4:	46c0      	nop			; (mov r8, r8)
    2fd6:	46c0      	nop			; (mov r8, r8)
    2fd8:	46c0      	nop			; (mov r8, r8)
    2fda:	46c0      	nop			; (mov r8, r8)
    2fdc:	46c0      	nop			; (mov r8, r8)
    2fde:	46c0      	nop			; (mov r8, r8)

00002fe0 <pxCurrentTCBConst2>:
    2fe0:	20003198 	.word	0x20003198
	"	bx   r3						\n" /* Finally, jump to the user defined task code. */
	"								\n"
	"	.align 4					\n"
	"pxCurrentTCBConst2: .word pxCurrentTCB	  "
				  );
}
    2fe4:	46c0      	nop			; (mov r8, r8)
    2fe6:	46c0      	nop			; (mov r8, r8)

00002fe8 <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
    2fe8:	b580      	push	{r7, lr}
    2fea:	af00      	add	r7, sp, #0
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
    2fec:	4b0e      	ldr	r3, [pc, #56]	; (3028 <xPortStartScheduler+0x40>)
    2fee:	4a0e      	ldr	r2, [pc, #56]	; (3028 <xPortStartScheduler+0x40>)
    2ff0:	6812      	ldr	r2, [r2, #0]
    2ff2:	21ff      	movs	r1, #255	; 0xff
    2ff4:	0409      	lsls	r1, r1, #16
    2ff6:	430a      	orrs	r2, r1
    2ff8:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
    2ffa:	4b0b      	ldr	r3, [pc, #44]	; (3028 <xPortStartScheduler+0x40>)
    2ffc:	4a0a      	ldr	r2, [pc, #40]	; (3028 <xPortStartScheduler+0x40>)
    2ffe:	6812      	ldr	r2, [r2, #0]
    3000:	21ff      	movs	r1, #255	; 0xff
    3002:	0609      	lsls	r1, r1, #24
    3004:	430a      	orrs	r2, r1
    3006:	601a      	str	r2, [r3, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
    3008:	4b08      	ldr	r3, [pc, #32]	; (302c <xPortStartScheduler+0x44>)
    300a:	4798      	blx	r3

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
    300c:	4b08      	ldr	r3, [pc, #32]	; (3030 <xPortStartScheduler+0x48>)
    300e:	2200      	movs	r2, #0
    3010:	601a      	str	r2, [r3, #0]

	/* Start the first task. */
	vPortStartFirstTask();
    3012:	4b08      	ldr	r3, [pc, #32]	; (3034 <xPortStartScheduler+0x4c>)
    3014:	4798      	blx	r3
	exit error function to prevent compiler warnings about a static function
	not being called in the case that the application writer overrides this
	functionality by defining configTASK_RETURN_ADDRESS.  Call
	vTaskSwitchContext() so link time optimisation does not remove the
	symbol. */
	vTaskSwitchContext();
    3016:	4b08      	ldr	r3, [pc, #32]	; (3038 <xPortStartScheduler+0x50>)
    3018:	4798      	blx	r3
	prvTaskExitError();
    301a:	4b08      	ldr	r3, [pc, #32]	; (303c <xPortStartScheduler+0x54>)
    301c:	4798      	blx	r3

	/* Should not get here! */
	return 0;
    301e:	2300      	movs	r3, #0
}
    3020:	0018      	movs	r0, r3
    3022:	46bd      	mov	sp, r7
    3024:	bd80      	pop	{r7, pc}
    3026:	46c0      	nop			; (mov r8, r8)
    3028:	e000ed20 	.word	0xe000ed20
    302c:	00003159 	.word	0x00003159
    3030:	20000004 	.word	0x20000004
    3034:	00002fb1 	.word	0x00002fb1
    3038:	000045e5 	.word	0x000045e5
    303c:	00002f7d 	.word	0x00002f7d

00003040 <vPortYield>:
	configASSERT( uxCriticalNesting == 1000UL );
}
/*-----------------------------------------------------------*/

void vPortYield( void )
{
    3040:	b580      	push	{r7, lr}
    3042:	af00      	add	r7, sp, #0
	/* Set a PendSV to request a context switch. */
	*( portNVIC_INT_CTRL ) = portNVIC_PENDSVSET;
    3044:	4b05      	ldr	r3, [pc, #20]	; (305c <vPortYield+0x1c>)
    3046:	2280      	movs	r2, #128	; 0x80
    3048:	0552      	lsls	r2, r2, #21
    304a:	601a      	str	r2, [r3, #0]

	/* Barriers are normally not required but do ensure the code is completely
	within the specified behaviour for the architecture. */
	__asm volatile( "dsb" ::: "memory" );
    304c:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
    3050:	f3bf 8f6f 	isb	sy
}
    3054:	46c0      	nop			; (mov r8, r8)
    3056:	46bd      	mov	sp, r7
    3058:	bd80      	pop	{r7, pc}
    305a:	46c0      	nop			; (mov r8, r8)
    305c:	e000ed04 	.word	0xe000ed04

00003060 <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
    3060:	b580      	push	{r7, lr}
    3062:	af00      	add	r7, sp, #0
    portDISABLE_INTERRUPTS();
    3064:	b672      	cpsid	i
    uxCriticalNesting++;
    3066:	4b06      	ldr	r3, [pc, #24]	; (3080 <vPortEnterCritical+0x20>)
    3068:	681b      	ldr	r3, [r3, #0]
    306a:	1c5a      	adds	r2, r3, #1
    306c:	4b04      	ldr	r3, [pc, #16]	; (3080 <vPortEnterCritical+0x20>)
    306e:	601a      	str	r2, [r3, #0]
	__asm volatile( "dsb" ::: "memory" );
    3070:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
    3074:	f3bf 8f6f 	isb	sy
}
    3078:	46c0      	nop			; (mov r8, r8)
    307a:	46bd      	mov	sp, r7
    307c:	bd80      	pop	{r7, pc}
    307e:	46c0      	nop			; (mov r8, r8)
    3080:	20000004 	.word	0x20000004

00003084 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
    3084:	b580      	push	{r7, lr}
    3086:	af00      	add	r7, sp, #0
	configASSERT( uxCriticalNesting );
    3088:	4b09      	ldr	r3, [pc, #36]	; (30b0 <vPortExitCritical+0x2c>)
    308a:	681b      	ldr	r3, [r3, #0]
    308c:	2b00      	cmp	r3, #0
    308e:	d101      	bne.n	3094 <vPortExitCritical+0x10>
    3090:	b672      	cpsid	i
    3092:	e7fe      	b.n	3092 <vPortExitCritical+0xe>
    uxCriticalNesting--;
    3094:	4b06      	ldr	r3, [pc, #24]	; (30b0 <vPortExitCritical+0x2c>)
    3096:	681b      	ldr	r3, [r3, #0]
    3098:	1e5a      	subs	r2, r3, #1
    309a:	4b05      	ldr	r3, [pc, #20]	; (30b0 <vPortExitCritical+0x2c>)
    309c:	601a      	str	r2, [r3, #0]
    if( uxCriticalNesting == 0 )
    309e:	4b04      	ldr	r3, [pc, #16]	; (30b0 <vPortExitCritical+0x2c>)
    30a0:	681b      	ldr	r3, [r3, #0]
    30a2:	2b00      	cmp	r3, #0
    30a4:	d100      	bne.n	30a8 <vPortExitCritical+0x24>
    {
        portENABLE_INTERRUPTS();
    30a6:	b662      	cpsie	i
    }
}
    30a8:	46c0      	nop			; (mov r8, r8)
    30aa:	46bd      	mov	sp, r7
    30ac:	bd80      	pop	{r7, pc}
    30ae:	46c0      	nop			; (mov r8, r8)
    30b0:	20000004 	.word	0x20000004

000030b4 <ulSetInterruptMaskFromISR>:
/*-----------------------------------------------------------*/

uint32_t ulSetInterruptMaskFromISR( void )
{
	__asm volatile(
    30b4:	f3ef 8010 	mrs	r0, PRIMASK
    30b8:	b672      	cpsid	i
    30ba:	4770      	bx	lr
	/* To avoid compiler warnings.  The return statement will nevere be reached,
	but some compilers warn if it is not included, while others won't compile if
	it is. */
	return 0;
#endif
}
    30bc:	46c0      	nop			; (mov r8, r8)
    30be:	0018      	movs	r0, r3

000030c0 <vClearInterruptMaskFromISR>:
/*-----------------------------------------------------------*/

void vClearInterruptMaskFromISR( __attribute__( ( unused ) ) uint32_t ulMask )
{
	__asm volatile(
    30c0:	f380 8810 	msr	PRIMASK, r0
    30c4:	4770      	bx	lr
	/* Just to avoid compiler warning.  ulMask is used from the asm code but
	the compiler can't see that.  Some compilers generate warnings without the
	following line, while others generate warnings if the line is included. */
	( void ) ulMask;
#endif
}
    30c6:	46c0      	nop			; (mov r8, r8)
	...

000030d0 <xPortPendSVHandler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
    30d0:	f3ef 8009 	mrs	r0, PSP
    30d4:	4b0e      	ldr	r3, [pc, #56]	; (3110 <pxCurrentTCBConst>)
    30d6:	681a      	ldr	r2, [r3, #0]
    30d8:	3820      	subs	r0, #32
    30da:	6010      	str	r0, [r2, #0]
    30dc:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
    30de:	4644      	mov	r4, r8
    30e0:	464d      	mov	r5, r9
    30e2:	4656      	mov	r6, sl
    30e4:	465f      	mov	r7, fp
    30e6:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
    30e8:	b508      	push	{r3, lr}
    30ea:	b672      	cpsid	i
    30ec:	f001 fa7a 	bl	45e4 <vTaskSwitchContext>
    30f0:	b662      	cpsie	i
    30f2:	bc0c      	pop	{r2, r3}
    30f4:	6811      	ldr	r1, [r2, #0]
    30f6:	6808      	ldr	r0, [r1, #0]
    30f8:	3010      	adds	r0, #16
    30fa:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
    30fc:	46a0      	mov	r8, r4
    30fe:	46a9      	mov	r9, r5
    3100:	46b2      	mov	sl, r6
    3102:	46bb      	mov	fp, r7
    3104:	f380 8809 	msr	PSP, r0
    3108:	3820      	subs	r0, #32
    310a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
    310c:	4718      	bx	r3
    310e:	46c0      	nop			; (mov r8, r8)

00003110 <pxCurrentTCBConst>:
    3110:	20003198 	.word	0x20003198
	"	bx r3								\n"
	"										\n"
	"	.align 4							\n"
	"pxCurrentTCBConst: .word pxCurrentTCB	  "
	);
}
    3114:	46c0      	nop			; (mov r8, r8)
    3116:	46c0      	nop			; (mov r8, r8)

00003118 <xPortSysTickHandler>:
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
    3118:	b580      	push	{r7, lr}
    311a:	b082      	sub	sp, #8
    311c:	af00      	add	r7, sp, #0
uint32_t ulPreviousMask;

	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
    311e:	4b0a      	ldr	r3, [pc, #40]	; (3148 <xPortSysTickHandler+0x30>)
    3120:	4798      	blx	r3
    3122:	0003      	movs	r3, r0
    3124:	607b      	str	r3, [r7, #4]
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
    3126:	4b09      	ldr	r3, [pc, #36]	; (314c <xPortSysTickHandler+0x34>)
    3128:	4798      	blx	r3
    312a:	1e03      	subs	r3, r0, #0
    312c:	d003      	beq.n	3136 <xPortSysTickHandler+0x1e>
		{
			/* Pend a context switch. */
			*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
    312e:	4b08      	ldr	r3, [pc, #32]	; (3150 <xPortSysTickHandler+0x38>)
    3130:	2280      	movs	r2, #128	; 0x80
    3132:	0552      	lsls	r2, r2, #21
    3134:	601a      	str	r2, [r3, #0]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
    3136:	687b      	ldr	r3, [r7, #4]
    3138:	0018      	movs	r0, r3
    313a:	4b06      	ldr	r3, [pc, #24]	; (3154 <xPortSysTickHandler+0x3c>)
    313c:	4798      	blx	r3
}
    313e:	46c0      	nop			; (mov r8, r8)
    3140:	46bd      	mov	sp, r7
    3142:	b002      	add	sp, #8
    3144:	bd80      	pop	{r7, pc}
    3146:	46c0      	nop			; (mov r8, r8)
    3148:	000030b5 	.word	0x000030b5
    314c:	0000445d 	.word	0x0000445d
    3150:	e000ed04 	.word	0xe000ed04
    3154:	000030c1 	.word	0x000030c1

00003158 <prvSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
    3158:	b580      	push	{r7, lr}
    315a:	af00      	add	r7, sp, #0
	/* Stop and reset the SysTick. */
	*(portNVIC_SYSTICK_CTRL) = 0UL;
    315c:	4b07      	ldr	r3, [pc, #28]	; (317c <prvSetupTimerInterrupt+0x24>)
    315e:	2200      	movs	r2, #0
    3160:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSTICK_CURRENT_VALUE) = 0UL;
    3162:	4b07      	ldr	r3, [pc, #28]	; (3180 <prvSetupTimerInterrupt+0x28>)
    3164:	2200      	movs	r2, #0
    3166:	601a      	str	r2, [r3, #0]

	/* Configure SysTick to interrupt at the requested rate. */
	*(portNVIC_SYSTICK_LOAD) = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
    3168:	4b06      	ldr	r3, [pc, #24]	; (3184 <prvSetupTimerInterrupt+0x2c>)
    316a:	4a07      	ldr	r2, [pc, #28]	; (3188 <prvSetupTimerInterrupt+0x30>)
    316c:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSTICK_CTRL) = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
    316e:	4b03      	ldr	r3, [pc, #12]	; (317c <prvSetupTimerInterrupt+0x24>)
    3170:	2207      	movs	r2, #7
    3172:	601a      	str	r2, [r3, #0]
}
    3174:	46c0      	nop			; (mov r8, r8)
    3176:	46bd      	mov	sp, r7
    3178:	bd80      	pop	{r7, pc}
    317a:	46c0      	nop			; (mov r8, r8)
    317c:	e000e010 	.word	0xe000e010
    3180:	e000e018 	.word	0xe000e018
    3184:	e000e014 	.word	0xe000e014
    3188:	000752ff 	.word	0x000752ff

0000318c <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    318c:	b580      	push	{r7, lr}
    318e:	b084      	sub	sp, #16
    3190:	af00      	add	r7, sp, #0
    3192:	6078      	str	r0, [r7, #4]
void *pvReturn = NULL;
    3194:	2300      	movs	r3, #0
    3196:	60fb      	str	r3, [r7, #12]
static uint8_t *pucAlignedHeap = NULL;

	/* Ensure that blocks are always aligned to the required number of bytes. */
	#if( portBYTE_ALIGNMENT != 1 )
	{
		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
    3198:	687b      	ldr	r3, [r7, #4]
    319a:	2207      	movs	r2, #7
    319c:	4013      	ands	r3, r2
    319e:	d004      	beq.n	31aa <pvPortMalloc+0x1e>
		{
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
    31a0:	687b      	ldr	r3, [r7, #4]
    31a2:	2207      	movs	r2, #7
    31a4:	4393      	bics	r3, r2
    31a6:	3308      	adds	r3, #8
    31a8:	607b      	str	r3, [r7, #4]
		}
	}
	#endif

	vTaskSuspendAll();
    31aa:	4b19      	ldr	r3, [pc, #100]	; (3210 <pvPortMalloc+0x84>)
    31ac:	4798      	blx	r3
	{
		if( pucAlignedHeap == NULL )
    31ae:	4b19      	ldr	r3, [pc, #100]	; (3214 <pvPortMalloc+0x88>)
    31b0:	681b      	ldr	r3, [r3, #0]
    31b2:	2b00      	cmp	r3, #0
    31b4:	d105      	bne.n	31c2 <pvPortMalloc+0x36>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    31b6:	4b18      	ldr	r3, [pc, #96]	; (3218 <pvPortMalloc+0x8c>)
    31b8:	2207      	movs	r2, #7
    31ba:	4393      	bics	r3, r2
    31bc:	001a      	movs	r2, r3
    31be:	4b15      	ldr	r3, [pc, #84]	; (3214 <pvPortMalloc+0x88>)
    31c0:	601a      	str	r2, [r3, #0]
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    31c2:	4b16      	ldr	r3, [pc, #88]	; (321c <pvPortMalloc+0x90>)
    31c4:	681a      	ldr	r2, [r3, #0]
    31c6:	687b      	ldr	r3, [r7, #4]
    31c8:	18d3      	adds	r3, r2, r3
    31ca:	4a15      	ldr	r2, [pc, #84]	; (3220 <pvPortMalloc+0x94>)
    31cc:	4293      	cmp	r3, r2
    31ce:	d813      	bhi.n	31f8 <pvPortMalloc+0x6c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
    31d0:	4b12      	ldr	r3, [pc, #72]	; (321c <pvPortMalloc+0x90>)
    31d2:	681a      	ldr	r2, [r3, #0]
    31d4:	687b      	ldr	r3, [r7, #4]
    31d6:	18d2      	adds	r2, r2, r3
    31d8:	4b10      	ldr	r3, [pc, #64]	; (321c <pvPortMalloc+0x90>)
    31da:	681b      	ldr	r3, [r3, #0]
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    31dc:	429a      	cmp	r2, r3
    31de:	d90b      	bls.n	31f8 <pvPortMalloc+0x6c>
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    31e0:	4b0c      	ldr	r3, [pc, #48]	; (3214 <pvPortMalloc+0x88>)
    31e2:	681a      	ldr	r2, [r3, #0]
    31e4:	4b0d      	ldr	r3, [pc, #52]	; (321c <pvPortMalloc+0x90>)
    31e6:	681b      	ldr	r3, [r3, #0]
    31e8:	18d3      	adds	r3, r2, r3
    31ea:	60fb      	str	r3, [r7, #12]
			xNextFreeByte += xWantedSize;
    31ec:	4b0b      	ldr	r3, [pc, #44]	; (321c <pvPortMalloc+0x90>)
    31ee:	681a      	ldr	r2, [r3, #0]
    31f0:	687b      	ldr	r3, [r7, #4]
    31f2:	18d2      	adds	r2, r2, r3
    31f4:	4b09      	ldr	r3, [pc, #36]	; (321c <pvPortMalloc+0x90>)
    31f6:	601a      	str	r2, [r3, #0]
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    31f8:	4b0a      	ldr	r3, [pc, #40]	; (3224 <pvPortMalloc+0x98>)
    31fa:	4798      	blx	r3

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
    31fc:	68fb      	ldr	r3, [r7, #12]
    31fe:	2b00      	cmp	r3, #0
    3200:	d101      	bne.n	3206 <pvPortMalloc+0x7a>
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
    3202:	4b09      	ldr	r3, [pc, #36]	; (3228 <pvPortMalloc+0x9c>)
    3204:	4798      	blx	r3
		}
	}
	#endif

	return pvReturn;
    3206:	68fb      	ldr	r3, [r7, #12]
}
    3208:	0018      	movs	r0, r3
    320a:	46bd      	mov	sp, r7
    320c:	b004      	add	sp, #16
    320e:	bd80      	pop	{r7, pc}
    3210:	000042f5 	.word	0x000042f5
    3214:	20003194 	.word	0x20003194
    3218:	20000998 	.word	0x20000998
    321c:	20003190 	.word	0x20003190
    3220:	000027f7 	.word	0x000027f7
    3224:	0000430d 	.word	0x0000430d
    3228:	0000608d 	.word	0x0000608d

0000322c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    322c:	b580      	push	{r7, lr}
    322e:	b082      	sub	sp, #8
    3230:	af00      	add	r7, sp, #0
    3232:	6078      	str	r0, [r7, #4]
	heap_4.c for alternative implementations, and the memory management pages of
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
    3234:	687b      	ldr	r3, [r7, #4]
    3236:	2b00      	cmp	r3, #0
    3238:	d001      	beq.n	323e <vPortFree+0x12>
    323a:	b672      	cpsid	i
    323c:	e7fe      	b.n	323c <vPortFree+0x10>
}
    323e:	46c0      	nop			; (mov r8, r8)
    3240:	46bd      	mov	sp, r7
    3242:	b002      	add	sp, #8
    3244:	bd80      	pop	{r7, pc}
	...

00003248 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    3248:	b580      	push	{r7, lr}
    324a:	b084      	sub	sp, #16
    324c:	af00      	add	r7, sp, #0
    324e:	6078      	str	r0, [r7, #4]
    3250:	6039      	str	r1, [r7, #0]
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    3252:	687b      	ldr	r3, [r7, #4]
    3254:	60fb      	str	r3, [r7, #12]

	configASSERT( pxQueue );
    3256:	68fb      	ldr	r3, [r7, #12]
    3258:	2b00      	cmp	r3, #0
    325a:	d101      	bne.n	3260 <xQueueGenericReset+0x18>
    325c:	b672      	cpsid	i
    325e:	e7fe      	b.n	325e <xQueueGenericReset+0x16>

	taskENTER_CRITICAL();
    3260:	4b23      	ldr	r3, [pc, #140]	; (32f0 <xQueueGenericReset+0xa8>)
    3262:	4798      	blx	r3
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    3264:	68fb      	ldr	r3, [r7, #12]
    3266:	681a      	ldr	r2, [r3, #0]
    3268:	68fb      	ldr	r3, [r7, #12]
    326a:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
    326c:	68fb      	ldr	r3, [r7, #12]
    326e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    3270:	434b      	muls	r3, r1
    3272:	18d2      	adds	r2, r2, r3
    3274:	68fb      	ldr	r3, [r7, #12]
    3276:	605a      	str	r2, [r3, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    3278:	68fb      	ldr	r3, [r7, #12]
    327a:	2200      	movs	r2, #0
    327c:	639a      	str	r2, [r3, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
    327e:	68fb      	ldr	r3, [r7, #12]
    3280:	681a      	ldr	r2, [r3, #0]
    3282:	68fb      	ldr	r3, [r7, #12]
    3284:	609a      	str	r2, [r3, #8]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    3286:	68fb      	ldr	r3, [r7, #12]
    3288:	681a      	ldr	r2, [r3, #0]
    328a:	68fb      	ldr	r3, [r7, #12]
    328c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    328e:	1e59      	subs	r1, r3, #1
    3290:	68fb      	ldr	r3, [r7, #12]
    3292:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    3294:	434b      	muls	r3, r1
    3296:	18d2      	adds	r2, r2, r3
    3298:	68fb      	ldr	r3, [r7, #12]
    329a:	60da      	str	r2, [r3, #12]
		pxQueue->cRxLock = queueUNLOCKED;
    329c:	68fb      	ldr	r3, [r7, #12]
    329e:	2244      	movs	r2, #68	; 0x44
    32a0:	21ff      	movs	r1, #255	; 0xff
    32a2:	5499      	strb	r1, [r3, r2]
		pxQueue->cTxLock = queueUNLOCKED;
    32a4:	68fb      	ldr	r3, [r7, #12]
    32a6:	2245      	movs	r2, #69	; 0x45
    32a8:	21ff      	movs	r1, #255	; 0xff
    32aa:	5499      	strb	r1, [r3, r2]

		if( xNewQueue == pdFALSE )
    32ac:	683b      	ldr	r3, [r7, #0]
    32ae:	2b00      	cmp	r3, #0
    32b0:	d10d      	bne.n	32ce <xQueueGenericReset+0x86>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    32b2:	68fb      	ldr	r3, [r7, #12]
    32b4:	691b      	ldr	r3, [r3, #16]
    32b6:	2b00      	cmp	r3, #0
    32b8:	d013      	beq.n	32e2 <xQueueGenericReset+0x9a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    32ba:	68fb      	ldr	r3, [r7, #12]
    32bc:	3310      	adds	r3, #16
    32be:	0018      	movs	r0, r3
    32c0:	4b0c      	ldr	r3, [pc, #48]	; (32f4 <xQueueGenericReset+0xac>)
    32c2:	4798      	blx	r3
    32c4:	1e03      	subs	r3, r0, #0
    32c6:	d00c      	beq.n	32e2 <xQueueGenericReset+0x9a>
				{
					queueYIELD_IF_USING_PREEMPTION();
    32c8:	4b0b      	ldr	r3, [pc, #44]	; (32f8 <xQueueGenericReset+0xb0>)
    32ca:	4798      	blx	r3
    32cc:	e009      	b.n	32e2 <xQueueGenericReset+0x9a>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    32ce:	68fb      	ldr	r3, [r7, #12]
    32d0:	3310      	adds	r3, #16
    32d2:	0018      	movs	r0, r3
    32d4:	4b09      	ldr	r3, [pc, #36]	; (32fc <xQueueGenericReset+0xb4>)
    32d6:	4798      	blx	r3
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    32d8:	68fb      	ldr	r3, [r7, #12]
    32da:	3324      	adds	r3, #36	; 0x24
    32dc:	0018      	movs	r0, r3
    32de:	4b07      	ldr	r3, [pc, #28]	; (32fc <xQueueGenericReset+0xb4>)
    32e0:	4798      	blx	r3
		}
	}
	taskEXIT_CRITICAL();
    32e2:	4b07      	ldr	r3, [pc, #28]	; (3300 <xQueueGenericReset+0xb8>)
    32e4:	4798      	blx	r3

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    32e6:	2301      	movs	r3, #1
}
    32e8:	0018      	movs	r0, r3
    32ea:	46bd      	mov	sp, r7
    32ec:	b004      	add	sp, #16
    32ee:	bd80      	pop	{r7, pc}
    32f0:	00003061 	.word	0x00003061
    32f4:	00004775 	.word	0x00004775
    32f8:	00003041 	.word	0x00003041
    32fc:	00002dd5 	.word	0x00002dd5
    3300:	00003085 	.word	0x00003085

00003304 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    3304:	b590      	push	{r4, r7, lr}
    3306:	b08b      	sub	sp, #44	; 0x2c
    3308:	af02      	add	r7, sp, #8
    330a:	60f8      	str	r0, [r7, #12]
    330c:	60b9      	str	r1, [r7, #8]
    330e:	1dfb      	adds	r3, r7, #7
    3310:	701a      	strb	r2, [r3, #0]
	Queue_t *pxNewQueue;
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
    3312:	68fb      	ldr	r3, [r7, #12]
    3314:	2b00      	cmp	r3, #0
    3316:	d101      	bne.n	331c <xQueueGenericCreate+0x18>
    3318:	b672      	cpsid	i
    331a:	e7fe      	b.n	331a <xQueueGenericCreate+0x16>

		if( uxItemSize == ( UBaseType_t ) 0 )
    331c:	68bb      	ldr	r3, [r7, #8]
    331e:	2b00      	cmp	r3, #0
    3320:	d102      	bne.n	3328 <xQueueGenericCreate+0x24>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    3322:	2300      	movs	r3, #0
    3324:	61fb      	str	r3, [r7, #28]
    3326:	e003      	b.n	3330 <xQueueGenericCreate+0x2c>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3328:	68fb      	ldr	r3, [r7, #12]
    332a:	68ba      	ldr	r2, [r7, #8]
    332c:	4353      	muls	r3, r2
    332e:	61fb      	str	r3, [r7, #28]
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    3330:	69fb      	ldr	r3, [r7, #28]
    3332:	3354      	adds	r3, #84	; 0x54
    3334:	0018      	movs	r0, r3
    3336:	4b0c      	ldr	r3, [pc, #48]	; (3368 <xQueueGenericCreate+0x64>)
    3338:	4798      	blx	r3
    333a:	0003      	movs	r3, r0
    333c:	61bb      	str	r3, [r7, #24]

		if( pxNewQueue != NULL )
    333e:	69bb      	ldr	r3, [r7, #24]
    3340:	2b00      	cmp	r3, #0
    3342:	d00c      	beq.n	335e <xQueueGenericCreate+0x5a>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
    3344:	69bb      	ldr	r3, [r7, #24]
    3346:	3354      	adds	r3, #84	; 0x54
    3348:	617b      	str	r3, [r7, #20]
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    334a:	1dfb      	adds	r3, r7, #7
    334c:	781c      	ldrb	r4, [r3, #0]
    334e:	697a      	ldr	r2, [r7, #20]
    3350:	68b9      	ldr	r1, [r7, #8]
    3352:	68f8      	ldr	r0, [r7, #12]
    3354:	69bb      	ldr	r3, [r7, #24]
    3356:	9300      	str	r3, [sp, #0]
    3358:	0023      	movs	r3, r4
    335a:	4c04      	ldr	r4, [pc, #16]	; (336c <xQueueGenericCreate+0x68>)
    335c:	47a0      	blx	r4
		else
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
		}

		return pxNewQueue;
    335e:	69bb      	ldr	r3, [r7, #24]
	}
    3360:	0018      	movs	r0, r3
    3362:	46bd      	mov	sp, r7
    3364:	b009      	add	sp, #36	; 0x24
    3366:	bd90      	pop	{r4, r7, pc}
    3368:	0000318d 	.word	0x0000318d
    336c:	00003371 	.word	0x00003371

00003370 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    3370:	b580      	push	{r7, lr}
    3372:	b084      	sub	sp, #16
    3374:	af00      	add	r7, sp, #0
    3376:	60f8      	str	r0, [r7, #12]
    3378:	60b9      	str	r1, [r7, #8]
    337a:	607a      	str	r2, [r7, #4]
    337c:	001a      	movs	r2, r3
    337e:	1cfb      	adds	r3, r7, #3
    3380:	701a      	strb	r2, [r3, #0]
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    3382:	68bb      	ldr	r3, [r7, #8]
    3384:	2b00      	cmp	r3, #0
    3386:	d103      	bne.n	3390 <prvInitialiseNewQueue+0x20>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    3388:	69bb      	ldr	r3, [r7, #24]
    338a:	69ba      	ldr	r2, [r7, #24]
    338c:	601a      	str	r2, [r3, #0]
    338e:	e002      	b.n	3396 <prvInitialiseNewQueue+0x26>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    3390:	69bb      	ldr	r3, [r7, #24]
    3392:	687a      	ldr	r2, [r7, #4]
    3394:	601a      	str	r2, [r3, #0]
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    3396:	69bb      	ldr	r3, [r7, #24]
    3398:	68fa      	ldr	r2, [r7, #12]
    339a:	63da      	str	r2, [r3, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
    339c:	69bb      	ldr	r3, [r7, #24]
    339e:	68ba      	ldr	r2, [r7, #8]
    33a0:	641a      	str	r2, [r3, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    33a2:	69bb      	ldr	r3, [r7, #24]
    33a4:	2101      	movs	r1, #1
    33a6:	0018      	movs	r0, r3
    33a8:	4b06      	ldr	r3, [pc, #24]	; (33c4 <prvInitialiseNewQueue+0x54>)
    33aa:	4798      	blx	r3

	#if ( configUSE_TRACE_FACILITY == 1 )
	{
		pxNewQueue->ucQueueType = ucQueueType;
    33ac:	69bb      	ldr	r3, [r7, #24]
    33ae:	1cfa      	adds	r2, r7, #3
    33b0:	2150      	movs	r1, #80	; 0x50
    33b2:	7812      	ldrb	r2, [r2, #0]
    33b4:	545a      	strb	r2, [r3, r1]
	}
	#endif /* configUSE_TRACE_FACILITY */

	#if( configUSE_QUEUE_SETS == 1 )
	{
		pxNewQueue->pxQueueSetContainer = NULL;
    33b6:	69bb      	ldr	r3, [r7, #24]
    33b8:	2200      	movs	r2, #0
    33ba:	649a      	str	r2, [r3, #72]	; 0x48
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    33bc:	46c0      	nop			; (mov r8, r8)
    33be:	46bd      	mov	sp, r7
    33c0:	b004      	add	sp, #16
    33c2:	bd80      	pop	{r7, pc}
    33c4:	00003249 	.word	0x00003249

000033c8 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    33c8:	b580      	push	{r7, lr}
    33ca:	b08a      	sub	sp, #40	; 0x28
    33cc:	af00      	add	r7, sp, #0
    33ce:	60f8      	str	r0, [r7, #12]
    33d0:	60b9      	str	r1, [r7, #8]
    33d2:	607a      	str	r2, [r7, #4]
    33d4:	603b      	str	r3, [r7, #0]
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    33d6:	2300      	movs	r3, #0
    33d8:	627b      	str	r3, [r7, #36]	; 0x24
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    33da:	68fb      	ldr	r3, [r7, #12]
    33dc:	623b      	str	r3, [r7, #32]

	configASSERT( pxQueue );
    33de:	6a3b      	ldr	r3, [r7, #32]
    33e0:	2b00      	cmp	r3, #0
    33e2:	d101      	bne.n	33e8 <xQueueGenericSend+0x20>
    33e4:	b672      	cpsid	i
    33e6:	e7fe      	b.n	33e6 <xQueueGenericSend+0x1e>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    33e8:	68bb      	ldr	r3, [r7, #8]
    33ea:	2b00      	cmp	r3, #0
    33ec:	d103      	bne.n	33f6 <xQueueGenericSend+0x2e>
    33ee:	6a3b      	ldr	r3, [r7, #32]
    33f0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    33f2:	2b00      	cmp	r3, #0
    33f4:	d101      	bne.n	33fa <xQueueGenericSend+0x32>
    33f6:	2301      	movs	r3, #1
    33f8:	e000      	b.n	33fc <xQueueGenericSend+0x34>
    33fa:	2300      	movs	r3, #0
    33fc:	2b00      	cmp	r3, #0
    33fe:	d101      	bne.n	3404 <xQueueGenericSend+0x3c>
    3400:	b672      	cpsid	i
    3402:	e7fe      	b.n	3402 <xQueueGenericSend+0x3a>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    3404:	683b      	ldr	r3, [r7, #0]
    3406:	2b02      	cmp	r3, #2
    3408:	d103      	bne.n	3412 <xQueueGenericSend+0x4a>
    340a:	6a3b      	ldr	r3, [r7, #32]
    340c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    340e:	2b01      	cmp	r3, #1
    3410:	d101      	bne.n	3416 <xQueueGenericSend+0x4e>
    3412:	2301      	movs	r3, #1
    3414:	e000      	b.n	3418 <xQueueGenericSend+0x50>
    3416:	2300      	movs	r3, #0
    3418:	2b00      	cmp	r3, #0
    341a:	d101      	bne.n	3420 <xQueueGenericSend+0x58>
    341c:	b672      	cpsid	i
    341e:	e7fe      	b.n	341e <xQueueGenericSend+0x56>
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    3420:	4b53      	ldr	r3, [pc, #332]	; (3570 <xQueueGenericSend+0x1a8>)
    3422:	4798      	blx	r3
    3424:	1e03      	subs	r3, r0, #0
    3426:	d102      	bne.n	342e <xQueueGenericSend+0x66>
    3428:	687b      	ldr	r3, [r7, #4]
    342a:	2b00      	cmp	r3, #0
    342c:	d101      	bne.n	3432 <xQueueGenericSend+0x6a>
    342e:	2301      	movs	r3, #1
    3430:	e000      	b.n	3434 <xQueueGenericSend+0x6c>
    3432:	2300      	movs	r3, #0
    3434:	2b00      	cmp	r3, #0
    3436:	d101      	bne.n	343c <xQueueGenericSend+0x74>
    3438:	b672      	cpsid	i
    343a:	e7fe      	b.n	343a <xQueueGenericSend+0x72>
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    343c:	4b4d      	ldr	r3, [pc, #308]	; (3574 <xQueueGenericSend+0x1ac>)
    343e:	4798      	blx	r3
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    3440:	6a3b      	ldr	r3, [r7, #32]
    3442:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    3444:	6a3b      	ldr	r3, [r7, #32]
    3446:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    3448:	429a      	cmp	r2, r3
    344a:	d302      	bcc.n	3452 <xQueueGenericSend+0x8a>
    344c:	683b      	ldr	r3, [r7, #0]
    344e:	2b02      	cmp	r3, #2
    3450:	d12d      	bne.n	34ae <xQueueGenericSend+0xe6>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3452:	683a      	ldr	r2, [r7, #0]
    3454:	68b9      	ldr	r1, [r7, #8]
    3456:	6a3b      	ldr	r3, [r7, #32]
    3458:	0018      	movs	r0, r3
    345a:	4b47      	ldr	r3, [pc, #284]	; (3578 <xQueueGenericSend+0x1b0>)
    345c:	4798      	blx	r3
    345e:	0003      	movs	r3, r0
    3460:	61fb      	str	r3, [r7, #28]

				#if ( configUSE_QUEUE_SETS == 1 )
				{
					if( pxQueue->pxQueueSetContainer != NULL )
    3462:	6a3b      	ldr	r3, [r7, #32]
    3464:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    3466:	2b00      	cmp	r3, #0
    3468:	d00a      	beq.n	3480 <xQueueGenericSend+0xb8>
					{
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
    346a:	683a      	ldr	r2, [r7, #0]
    346c:	6a3b      	ldr	r3, [r7, #32]
    346e:	0011      	movs	r1, r2
    3470:	0018      	movs	r0, r3
    3472:	4b42      	ldr	r3, [pc, #264]	; (357c <xQueueGenericSend+0x1b4>)
    3474:	4798      	blx	r3
    3476:	1e03      	subs	r3, r0, #0
    3478:	d015      	beq.n	34a6 <xQueueGenericSend+0xde>
						{
							/* The queue is a member of a queue set, and posting
							to the queue set caused a higher priority task to
							unblock. A context switch is required. */
							queueYIELD_IF_USING_PREEMPTION();
    347a:	4b41      	ldr	r3, [pc, #260]	; (3580 <xQueueGenericSend+0x1b8>)
    347c:	4798      	blx	r3
    347e:	e012      	b.n	34a6 <xQueueGenericSend+0xde>
					}
					else
					{
						/* If there was a task waiting for data to arrive on the
						queue then unblock it now. */
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3480:	6a3b      	ldr	r3, [r7, #32]
    3482:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    3484:	2b00      	cmp	r3, #0
    3486:	d009      	beq.n	349c <xQueueGenericSend+0xd4>
						{
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3488:	6a3b      	ldr	r3, [r7, #32]
    348a:	3324      	adds	r3, #36	; 0x24
    348c:	0018      	movs	r0, r3
    348e:	4b3d      	ldr	r3, [pc, #244]	; (3584 <xQueueGenericSend+0x1bc>)
    3490:	4798      	blx	r3
    3492:	1e03      	subs	r3, r0, #0
    3494:	d007      	beq.n	34a6 <xQueueGenericSend+0xde>
							{
								/* The unblocked task has a priority higher than
								our own so yield immediately.  Yes it is ok to
								do this from within the critical section - the
								kernel takes care of that. */
								queueYIELD_IF_USING_PREEMPTION();
    3496:	4b3a      	ldr	r3, [pc, #232]	; (3580 <xQueueGenericSend+0x1b8>)
    3498:	4798      	blx	r3
    349a:	e004      	b.n	34a6 <xQueueGenericSend+0xde>
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
						}
						else if( xYieldRequired != pdFALSE )
    349c:	69fb      	ldr	r3, [r7, #28]
    349e:	2b00      	cmp	r3, #0
    34a0:	d001      	beq.n	34a6 <xQueueGenericSend+0xde>
						{
							/* This path is a special case that will only get
							executed if the task was holding multiple mutexes
							and the mutexes were given back in an order that is
							different to that in which they were taken. */
							queueYIELD_IF_USING_PREEMPTION();
    34a2:	4b37      	ldr	r3, [pc, #220]	; (3580 <xQueueGenericSend+0x1b8>)
    34a4:	4798      	blx	r3
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    34a6:	4b38      	ldr	r3, [pc, #224]	; (3588 <xQueueGenericSend+0x1c0>)
    34a8:	4798      	blx	r3
				return pdPASS;
    34aa:	2301      	movs	r3, #1
    34ac:	e05c      	b.n	3568 <xQueueGenericSend+0x1a0>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    34ae:	687b      	ldr	r3, [r7, #4]
    34b0:	2b00      	cmp	r3, #0
    34b2:	d103      	bne.n	34bc <xQueueGenericSend+0xf4>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    34b4:	4b34      	ldr	r3, [pc, #208]	; (3588 <xQueueGenericSend+0x1c0>)
    34b6:	4798      	blx	r3

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    34b8:	2300      	movs	r3, #0
    34ba:	e055      	b.n	3568 <xQueueGenericSend+0x1a0>
				}
				else if( xEntryTimeSet == pdFALSE )
    34bc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    34be:	2b00      	cmp	r3, #0
    34c0:	d106      	bne.n	34d0 <xQueueGenericSend+0x108>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    34c2:	2314      	movs	r3, #20
    34c4:	18fb      	adds	r3, r7, r3
    34c6:	0018      	movs	r0, r3
    34c8:	4b30      	ldr	r3, [pc, #192]	; (358c <xQueueGenericSend+0x1c4>)
    34ca:	4798      	blx	r3
					xEntryTimeSet = pdTRUE;
    34cc:	2301      	movs	r3, #1
    34ce:	627b      	str	r3, [r7, #36]	; 0x24
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    34d0:	4b2d      	ldr	r3, [pc, #180]	; (3588 <xQueueGenericSend+0x1c0>)
    34d2:	4798      	blx	r3

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    34d4:	4b2e      	ldr	r3, [pc, #184]	; (3590 <xQueueGenericSend+0x1c8>)
    34d6:	4798      	blx	r3
		prvLockQueue( pxQueue );
    34d8:	4b26      	ldr	r3, [pc, #152]	; (3574 <xQueueGenericSend+0x1ac>)
    34da:	4798      	blx	r3
    34dc:	6a3b      	ldr	r3, [r7, #32]
    34de:	2244      	movs	r2, #68	; 0x44
    34e0:	5c9b      	ldrb	r3, [r3, r2]
    34e2:	b25b      	sxtb	r3, r3
    34e4:	3301      	adds	r3, #1
    34e6:	d103      	bne.n	34f0 <xQueueGenericSend+0x128>
    34e8:	6a3b      	ldr	r3, [r7, #32]
    34ea:	2244      	movs	r2, #68	; 0x44
    34ec:	2100      	movs	r1, #0
    34ee:	5499      	strb	r1, [r3, r2]
    34f0:	6a3b      	ldr	r3, [r7, #32]
    34f2:	2245      	movs	r2, #69	; 0x45
    34f4:	5c9b      	ldrb	r3, [r3, r2]
    34f6:	b25b      	sxtb	r3, r3
    34f8:	3301      	adds	r3, #1
    34fa:	d103      	bne.n	3504 <xQueueGenericSend+0x13c>
    34fc:	6a3b      	ldr	r3, [r7, #32]
    34fe:	2245      	movs	r2, #69	; 0x45
    3500:	2100      	movs	r1, #0
    3502:	5499      	strb	r1, [r3, r2]
    3504:	4b20      	ldr	r3, [pc, #128]	; (3588 <xQueueGenericSend+0x1c0>)
    3506:	4798      	blx	r3

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3508:	1d3a      	adds	r2, r7, #4
    350a:	2314      	movs	r3, #20
    350c:	18fb      	adds	r3, r7, r3
    350e:	0011      	movs	r1, r2
    3510:	0018      	movs	r0, r3
    3512:	4b20      	ldr	r3, [pc, #128]	; (3594 <xQueueGenericSend+0x1cc>)
    3514:	4798      	blx	r3
    3516:	1e03      	subs	r3, r0, #0
    3518:	d11f      	bne.n	355a <xQueueGenericSend+0x192>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    351a:	6a3b      	ldr	r3, [r7, #32]
    351c:	0018      	movs	r0, r3
    351e:	4b1e      	ldr	r3, [pc, #120]	; (3598 <xQueueGenericSend+0x1d0>)
    3520:	4798      	blx	r3
    3522:	1e03      	subs	r3, r0, #0
    3524:	d012      	beq.n	354c <xQueueGenericSend+0x184>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    3526:	6a3b      	ldr	r3, [r7, #32]
    3528:	3310      	adds	r3, #16
    352a:	687a      	ldr	r2, [r7, #4]
    352c:	0011      	movs	r1, r2
    352e:	0018      	movs	r0, r3
    3530:	4b1a      	ldr	r3, [pc, #104]	; (359c <xQueueGenericSend+0x1d4>)
    3532:	4798      	blx	r3
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    3534:	6a3b      	ldr	r3, [r7, #32]
    3536:	0018      	movs	r0, r3
    3538:	4b19      	ldr	r3, [pc, #100]	; (35a0 <xQueueGenericSend+0x1d8>)
    353a:	4798      	blx	r3
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    353c:	4b19      	ldr	r3, [pc, #100]	; (35a4 <xQueueGenericSend+0x1dc>)
    353e:	4798      	blx	r3
    3540:	1e03      	subs	r3, r0, #0
    3542:	d000      	beq.n	3546 <xQueueGenericSend+0x17e>
    3544:	e77a      	b.n	343c <xQueueGenericSend+0x74>
				{
					portYIELD_WITHIN_API();
    3546:	4b0e      	ldr	r3, [pc, #56]	; (3580 <xQueueGenericSend+0x1b8>)
    3548:	4798      	blx	r3
    354a:	e777      	b.n	343c <xQueueGenericSend+0x74>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    354c:	6a3b      	ldr	r3, [r7, #32]
    354e:	0018      	movs	r0, r3
    3550:	4b13      	ldr	r3, [pc, #76]	; (35a0 <xQueueGenericSend+0x1d8>)
    3552:	4798      	blx	r3
				( void ) xTaskResumeAll();
    3554:	4b13      	ldr	r3, [pc, #76]	; (35a4 <xQueueGenericSend+0x1dc>)
    3556:	4798      	blx	r3
    3558:	e770      	b.n	343c <xQueueGenericSend+0x74>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    355a:	6a3b      	ldr	r3, [r7, #32]
    355c:	0018      	movs	r0, r3
    355e:	4b10      	ldr	r3, [pc, #64]	; (35a0 <xQueueGenericSend+0x1d8>)
    3560:	4798      	blx	r3
			( void ) xTaskResumeAll();
    3562:	4b10      	ldr	r3, [pc, #64]	; (35a4 <xQueueGenericSend+0x1dc>)
    3564:	4798      	blx	r3

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    3566:	2300      	movs	r3, #0
		}
	}
}
    3568:	0018      	movs	r0, r3
    356a:	46bd      	mov	sp, r7
    356c:	b00a      	add	sp, #40	; 0x28
    356e:	bd80      	pop	{r7, pc}
    3570:	00004aad 	.word	0x00004aad
    3574:	00003061 	.word	0x00003061
    3578:	00003b89 	.word	0x00003b89
    357c:	00003edd 	.word	0x00003edd
    3580:	00003041 	.word	0x00003041
    3584:	00004775 	.word	0x00004775
    3588:	00003085 	.word	0x00003085
    358c:	00004835 	.word	0x00004835
    3590:	000042f5 	.word	0x000042f5
    3594:	0000485d 	.word	0x0000485d
    3598:	00003ddd 	.word	0x00003ddd
    359c:	000046dd 	.word	0x000046dd
    35a0:	00003cb9 	.word	0x00003cb9
    35a4:	0000430d 	.word	0x0000430d

000035a8 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    35a8:	b580      	push	{r7, lr}
    35aa:	b088      	sub	sp, #32
    35ac:	af00      	add	r7, sp, #0
    35ae:	60f8      	str	r0, [r7, #12]
    35b0:	60b9      	str	r1, [r7, #8]
    35b2:	607a      	str	r2, [r7, #4]
    35b4:	603b      	str	r3, [r7, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    35b6:	68fb      	ldr	r3, [r7, #12]
    35b8:	61bb      	str	r3, [r7, #24]

	configASSERT( pxQueue );
    35ba:	69bb      	ldr	r3, [r7, #24]
    35bc:	2b00      	cmp	r3, #0
    35be:	d101      	bne.n	35c4 <xQueueGenericSendFromISR+0x1c>
    35c0:	b672      	cpsid	i
    35c2:	e7fe      	b.n	35c2 <xQueueGenericSendFromISR+0x1a>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    35c4:	68bb      	ldr	r3, [r7, #8]
    35c6:	2b00      	cmp	r3, #0
    35c8:	d103      	bne.n	35d2 <xQueueGenericSendFromISR+0x2a>
    35ca:	69bb      	ldr	r3, [r7, #24]
    35cc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    35ce:	2b00      	cmp	r3, #0
    35d0:	d101      	bne.n	35d6 <xQueueGenericSendFromISR+0x2e>
    35d2:	2301      	movs	r3, #1
    35d4:	e000      	b.n	35d8 <xQueueGenericSendFromISR+0x30>
    35d6:	2300      	movs	r3, #0
    35d8:	2b00      	cmp	r3, #0
    35da:	d101      	bne.n	35e0 <xQueueGenericSendFromISR+0x38>
    35dc:	b672      	cpsid	i
    35de:	e7fe      	b.n	35de <xQueueGenericSendFromISR+0x36>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    35e0:	683b      	ldr	r3, [r7, #0]
    35e2:	2b02      	cmp	r3, #2
    35e4:	d103      	bne.n	35ee <xQueueGenericSendFromISR+0x46>
    35e6:	69bb      	ldr	r3, [r7, #24]
    35e8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    35ea:	2b01      	cmp	r3, #1
    35ec:	d101      	bne.n	35f2 <xQueueGenericSendFromISR+0x4a>
    35ee:	2301      	movs	r3, #1
    35f0:	e000      	b.n	35f4 <xQueueGenericSendFromISR+0x4c>
    35f2:	2300      	movs	r3, #0
    35f4:	2b00      	cmp	r3, #0
    35f6:	d101      	bne.n	35fc <xQueueGenericSendFromISR+0x54>
    35f8:	b672      	cpsid	i
    35fa:	e7fe      	b.n	35fa <xQueueGenericSendFromISR+0x52>
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    35fc:	4b2d      	ldr	r3, [pc, #180]	; (36b4 <xQueueGenericSendFromISR+0x10c>)
    35fe:	4798      	blx	r3
    3600:	0003      	movs	r3, r0
    3602:	617b      	str	r3, [r7, #20]
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    3604:	69bb      	ldr	r3, [r7, #24]
    3606:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    3608:	69bb      	ldr	r3, [r7, #24]
    360a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    360c:	429a      	cmp	r2, r3
    360e:	d302      	bcc.n	3616 <xQueueGenericSendFromISR+0x6e>
    3610:	683b      	ldr	r3, [r7, #0]
    3612:	2b02      	cmp	r3, #2
    3614:	d142      	bne.n	369c <xQueueGenericSendFromISR+0xf4>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    3616:	2313      	movs	r3, #19
    3618:	18fb      	adds	r3, r7, r3
    361a:	69ba      	ldr	r2, [r7, #24]
    361c:	2145      	movs	r1, #69	; 0x45
    361e:	5c52      	ldrb	r2, [r2, r1]
    3620:	701a      	strb	r2, [r3, #0]
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3622:	683a      	ldr	r2, [r7, #0]
    3624:	68b9      	ldr	r1, [r7, #8]
    3626:	69bb      	ldr	r3, [r7, #24]
    3628:	0018      	movs	r0, r3
    362a:	4b23      	ldr	r3, [pc, #140]	; (36b8 <xQueueGenericSendFromISR+0x110>)
    362c:	4798      	blx	r3

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    362e:	2313      	movs	r3, #19
    3630:	18fb      	adds	r3, r7, r3
    3632:	781b      	ldrb	r3, [r3, #0]
    3634:	b25b      	sxtb	r3, r3
    3636:	3301      	adds	r3, #1
    3638:	d124      	bne.n	3684 <xQueueGenericSendFromISR+0xdc>
			{
				#if ( configUSE_QUEUE_SETS == 1 )
				{
					if( pxQueue->pxQueueSetContainer != NULL )
    363a:	69bb      	ldr	r3, [r7, #24]
    363c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    363e:	2b00      	cmp	r3, #0
    3640:	d00e      	beq.n	3660 <xQueueGenericSendFromISR+0xb8>
					{
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
    3642:	683a      	ldr	r2, [r7, #0]
    3644:	69bb      	ldr	r3, [r7, #24]
    3646:	0011      	movs	r1, r2
    3648:	0018      	movs	r0, r3
    364a:	4b1c      	ldr	r3, [pc, #112]	; (36bc <xQueueGenericSendFromISR+0x114>)
    364c:	4798      	blx	r3
    364e:	1e03      	subs	r3, r0, #0
    3650:	d021      	beq.n	3696 <xQueueGenericSendFromISR+0xee>
						{
							/* The queue is a member of a queue set, and posting
							to the queue set caused a higher priority task to
							unblock.  A context switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    3652:	687b      	ldr	r3, [r7, #4]
    3654:	2b00      	cmp	r3, #0
    3656:	d01e      	beq.n	3696 <xQueueGenericSendFromISR+0xee>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    3658:	687b      	ldr	r3, [r7, #4]
    365a:	2201      	movs	r2, #1
    365c:	601a      	str	r2, [r3, #0]
    365e:	e01a      	b.n	3696 <xQueueGenericSendFromISR+0xee>
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else
					{
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3660:	69bb      	ldr	r3, [r7, #24]
    3662:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    3664:	2b00      	cmp	r3, #0
    3666:	d016      	beq.n	3696 <xQueueGenericSendFromISR+0xee>
						{
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3668:	69bb      	ldr	r3, [r7, #24]
    366a:	3324      	adds	r3, #36	; 0x24
    366c:	0018      	movs	r0, r3
    366e:	4b14      	ldr	r3, [pc, #80]	; (36c0 <xQueueGenericSendFromISR+0x118>)
    3670:	4798      	blx	r3
    3672:	1e03      	subs	r3, r0, #0
    3674:	d00f      	beq.n	3696 <xQueueGenericSendFromISR+0xee>
							{
								/* The task waiting has a higher priority so
								record that a context switch is required. */
								if( pxHigherPriorityTaskWoken != NULL )
    3676:	687b      	ldr	r3, [r7, #4]
    3678:	2b00      	cmp	r3, #0
    367a:	d00c      	beq.n	3696 <xQueueGenericSendFromISR+0xee>
								{
									*pxHigherPriorityTaskWoken = pdTRUE;
    367c:	687b      	ldr	r3, [r7, #4]
    367e:	2201      	movs	r2, #1
    3680:	601a      	str	r2, [r3, #0]
    3682:	e008      	b.n	3696 <xQueueGenericSendFromISR+0xee>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    3684:	2313      	movs	r3, #19
    3686:	18fb      	adds	r3, r7, r3
    3688:	781b      	ldrb	r3, [r3, #0]
    368a:	3301      	adds	r3, #1
    368c:	b2db      	uxtb	r3, r3
    368e:	b259      	sxtb	r1, r3
    3690:	69bb      	ldr	r3, [r7, #24]
    3692:	2245      	movs	r2, #69	; 0x45
    3694:	5499      	strb	r1, [r3, r2]
			}

			xReturn = pdPASS;
    3696:	2301      	movs	r3, #1
    3698:	61fb      	str	r3, [r7, #28]
		{
    369a:	e001      	b.n	36a0 <xQueueGenericSendFromISR+0xf8>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    369c:	2300      	movs	r3, #0
    369e:	61fb      	str	r3, [r7, #28]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    36a0:	697b      	ldr	r3, [r7, #20]
    36a2:	0018      	movs	r0, r3
    36a4:	4b07      	ldr	r3, [pc, #28]	; (36c4 <xQueueGenericSendFromISR+0x11c>)
    36a6:	4798      	blx	r3

	return xReturn;
    36a8:	69fb      	ldr	r3, [r7, #28]
}
    36aa:	0018      	movs	r0, r3
    36ac:	46bd      	mov	sp, r7
    36ae:	b008      	add	sp, #32
    36b0:	bd80      	pop	{r7, pc}
    36b2:	46c0      	nop			; (mov r8, r8)
    36b4:	000030b5 	.word	0x000030b5
    36b8:	00003b89 	.word	0x00003b89
    36bc:	00003edd 	.word	0x00003edd
    36c0:	00004775 	.word	0x00004775
    36c4:	000030c1 	.word	0x000030c1

000036c8 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    36c8:	b580      	push	{r7, lr}
    36ca:	b088      	sub	sp, #32
    36cc:	af00      	add	r7, sp, #0
    36ce:	6078      	str	r0, [r7, #4]
    36d0:	6039      	str	r1, [r7, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    36d2:	687b      	ldr	r3, [r7, #4]
    36d4:	61bb      	str	r3, [r7, #24]
	item size is 0.  Don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */

	configASSERT( pxQueue );
    36d6:	69bb      	ldr	r3, [r7, #24]
    36d8:	2b00      	cmp	r3, #0
    36da:	d101      	bne.n	36e0 <xQueueGiveFromISR+0x18>
    36dc:	b672      	cpsid	i
    36de:	e7fe      	b.n	36de <xQueueGiveFromISR+0x16>

	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
	if the item size is not 0. */
	configASSERT( pxQueue->uxItemSize == 0 );
    36e0:	69bb      	ldr	r3, [r7, #24]
    36e2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    36e4:	2b00      	cmp	r3, #0
    36e6:	d001      	beq.n	36ec <xQueueGiveFromISR+0x24>
    36e8:	b672      	cpsid	i
    36ea:	e7fe      	b.n	36ea <xQueueGiveFromISR+0x22>

	/* Normally a mutex would not be given from an interrupt, especially if
	there is a mutex holder, as priority inheritance makes no sense for an
	interrupts, only tasks. */
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
    36ec:	69bb      	ldr	r3, [r7, #24]
    36ee:	681b      	ldr	r3, [r3, #0]
    36f0:	2b00      	cmp	r3, #0
    36f2:	d103      	bne.n	36fc <xQueueGiveFromISR+0x34>
    36f4:	69bb      	ldr	r3, [r7, #24]
    36f6:	685b      	ldr	r3, [r3, #4]
    36f8:	2b00      	cmp	r3, #0
    36fa:	d101      	bne.n	3700 <xQueueGiveFromISR+0x38>
    36fc:	2301      	movs	r3, #1
    36fe:	e000      	b.n	3702 <xQueueGiveFromISR+0x3a>
    3700:	2300      	movs	r3, #0
    3702:	2b00      	cmp	r3, #0
    3704:	d101      	bne.n	370a <xQueueGiveFromISR+0x42>
    3706:	b672      	cpsid	i
    3708:	e7fe      	b.n	3708 <xQueueGiveFromISR+0x40>
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    370a:	4b2b      	ldr	r3, [pc, #172]	; (37b8 <xQueueGiveFromISR+0xf0>)
    370c:	4798      	blx	r3
    370e:	0003      	movs	r3, r0
    3710:	617b      	str	r3, [r7, #20]
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3712:	69bb      	ldr	r3, [r7, #24]
    3714:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    3716:	613b      	str	r3, [r7, #16]

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    3718:	69bb      	ldr	r3, [r7, #24]
    371a:	6bda      	ldr	r2, [r3, #60]	; 0x3c
    371c:	693b      	ldr	r3, [r7, #16]
    371e:	429a      	cmp	r2, r3
    3720:	d93f      	bls.n	37a2 <xQueueGiveFromISR+0xda>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    3722:	230f      	movs	r3, #15
    3724:	18fb      	adds	r3, r7, r3
    3726:	69ba      	ldr	r2, [r7, #24]
    3728:	2145      	movs	r1, #69	; 0x45
    372a:	5c52      	ldrb	r2, [r2, r1]
    372c:	701a      	strb	r2, [r3, #0]
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    372e:	693b      	ldr	r3, [r7, #16]
    3730:	1c5a      	adds	r2, r3, #1
    3732:	69bb      	ldr	r3, [r7, #24]
    3734:	639a      	str	r2, [r3, #56]	; 0x38

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    3736:	230f      	movs	r3, #15
    3738:	18fb      	adds	r3, r7, r3
    373a:	781b      	ldrb	r3, [r3, #0]
    373c:	b25b      	sxtb	r3, r3
    373e:	3301      	adds	r3, #1
    3740:	d123      	bne.n	378a <xQueueGiveFromISR+0xc2>
			{
				#if ( configUSE_QUEUE_SETS == 1 )
				{
					if( pxQueue->pxQueueSetContainer != NULL )
    3742:	69bb      	ldr	r3, [r7, #24]
    3744:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    3746:	2b00      	cmp	r3, #0
    3748:	d00d      	beq.n	3766 <xQueueGiveFromISR+0x9e>
					{
						if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
    374a:	69bb      	ldr	r3, [r7, #24]
    374c:	2100      	movs	r1, #0
    374e:	0018      	movs	r0, r3
    3750:	4b1a      	ldr	r3, [pc, #104]	; (37bc <xQueueGiveFromISR+0xf4>)
    3752:	4798      	blx	r3
    3754:	1e03      	subs	r3, r0, #0
    3756:	d021      	beq.n	379c <xQueueGiveFromISR+0xd4>
						{
							/* The semaphore is a member of a queue set, and
							posting	to the queue set caused a higher priority
							task to	unblock.  A context switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    3758:	683b      	ldr	r3, [r7, #0]
    375a:	2b00      	cmp	r3, #0
    375c:	d01e      	beq.n	379c <xQueueGiveFromISR+0xd4>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    375e:	683b      	ldr	r3, [r7, #0]
    3760:	2201      	movs	r2, #1
    3762:	601a      	str	r2, [r3, #0]
    3764:	e01a      	b.n	379c <xQueueGiveFromISR+0xd4>
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else
					{
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3766:	69bb      	ldr	r3, [r7, #24]
    3768:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    376a:	2b00      	cmp	r3, #0
    376c:	d016      	beq.n	379c <xQueueGiveFromISR+0xd4>
						{
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    376e:	69bb      	ldr	r3, [r7, #24]
    3770:	3324      	adds	r3, #36	; 0x24
    3772:	0018      	movs	r0, r3
    3774:	4b12      	ldr	r3, [pc, #72]	; (37c0 <xQueueGiveFromISR+0xf8>)
    3776:	4798      	blx	r3
    3778:	1e03      	subs	r3, r0, #0
    377a:	d00f      	beq.n	379c <xQueueGiveFromISR+0xd4>
							{
								/* The task waiting has a higher priority so
								record that a context switch is required. */
								if( pxHigherPriorityTaskWoken != NULL )
    377c:	683b      	ldr	r3, [r7, #0]
    377e:	2b00      	cmp	r3, #0
    3780:	d00c      	beq.n	379c <xQueueGiveFromISR+0xd4>
								{
									*pxHigherPriorityTaskWoken = pdTRUE;
    3782:	683b      	ldr	r3, [r7, #0]
    3784:	2201      	movs	r2, #1
    3786:	601a      	str	r2, [r3, #0]
    3788:	e008      	b.n	379c <xQueueGiveFromISR+0xd4>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    378a:	230f      	movs	r3, #15
    378c:	18fb      	adds	r3, r7, r3
    378e:	781b      	ldrb	r3, [r3, #0]
    3790:	3301      	adds	r3, #1
    3792:	b2db      	uxtb	r3, r3
    3794:	b259      	sxtb	r1, r3
    3796:	69bb      	ldr	r3, [r7, #24]
    3798:	2245      	movs	r2, #69	; 0x45
    379a:	5499      	strb	r1, [r3, r2]
			}

			xReturn = pdPASS;
    379c:	2301      	movs	r3, #1
    379e:	61fb      	str	r3, [r7, #28]
    37a0:	e001      	b.n	37a6 <xQueueGiveFromISR+0xde>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    37a2:	2300      	movs	r3, #0
    37a4:	61fb      	str	r3, [r7, #28]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    37a6:	697b      	ldr	r3, [r7, #20]
    37a8:	0018      	movs	r0, r3
    37aa:	4b06      	ldr	r3, [pc, #24]	; (37c4 <xQueueGiveFromISR+0xfc>)
    37ac:	4798      	blx	r3

	return xReturn;
    37ae:	69fb      	ldr	r3, [r7, #28]
}
    37b0:	0018      	movs	r0, r3
    37b2:	46bd      	mov	sp, r7
    37b4:	b008      	add	sp, #32
    37b6:	bd80      	pop	{r7, pc}
    37b8:	000030b5 	.word	0x000030b5
    37bc:	00003edd 	.word	0x00003edd
    37c0:	00004775 	.word	0x00004775
    37c4:	000030c1 	.word	0x000030c1

000037c8 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    37c8:	b580      	push	{r7, lr}
    37ca:	b08a      	sub	sp, #40	; 0x28
    37cc:	af00      	add	r7, sp, #0
    37ce:	60f8      	str	r0, [r7, #12]
    37d0:	60b9      	str	r1, [r7, #8]
    37d2:	607a      	str	r2, [r7, #4]
BaseType_t xEntryTimeSet = pdFALSE;
    37d4:	2300      	movs	r3, #0
    37d6:	627b      	str	r3, [r7, #36]	; 0x24
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    37d8:	68fb      	ldr	r3, [r7, #12]
    37da:	623b      	str	r3, [r7, #32]

	/* Check the pointer is not NULL. */
	configASSERT( ( pxQueue ) );
    37dc:	6a3b      	ldr	r3, [r7, #32]
    37de:	2b00      	cmp	r3, #0
    37e0:	d101      	bne.n	37e6 <xQueueReceive+0x1e>
    37e2:	b672      	cpsid	i
    37e4:	e7fe      	b.n	37e4 <xQueueReceive+0x1c>

	/* The buffer into which data is received can only be NULL if the data size
	is zero (so no data is copied into the buffer. */
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
    37e6:	68bb      	ldr	r3, [r7, #8]
    37e8:	2b00      	cmp	r3, #0
    37ea:	d103      	bne.n	37f4 <xQueueReceive+0x2c>
    37ec:	6a3b      	ldr	r3, [r7, #32]
    37ee:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    37f0:	2b00      	cmp	r3, #0
    37f2:	d101      	bne.n	37f8 <xQueueReceive+0x30>
    37f4:	2301      	movs	r3, #1
    37f6:	e000      	b.n	37fa <xQueueReceive+0x32>
    37f8:	2300      	movs	r3, #0
    37fa:	2b00      	cmp	r3, #0
    37fc:	d101      	bne.n	3802 <xQueueReceive+0x3a>
    37fe:	b672      	cpsid	i
    3800:	e7fe      	b.n	3800 <xQueueReceive+0x38>

	/* Cannot block if the scheduler is suspended. */
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    3802:	4b4c      	ldr	r3, [pc, #304]	; (3934 <xQueueReceive+0x16c>)
    3804:	4798      	blx	r3
    3806:	1e03      	subs	r3, r0, #0
    3808:	d102      	bne.n	3810 <xQueueReceive+0x48>
    380a:	687b      	ldr	r3, [r7, #4]
    380c:	2b00      	cmp	r3, #0
    380e:	d101      	bne.n	3814 <xQueueReceive+0x4c>
    3810:	2301      	movs	r3, #1
    3812:	e000      	b.n	3816 <xQueueReceive+0x4e>
    3814:	2300      	movs	r3, #0
    3816:	2b00      	cmp	r3, #0
    3818:	d101      	bne.n	381e <xQueueReceive+0x56>
    381a:	b672      	cpsid	i
    381c:	e7fe      	b.n	381c <xQueueReceive+0x54>
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    381e:	4b46      	ldr	r3, [pc, #280]	; (3938 <xQueueReceive+0x170>)
    3820:	4798      	blx	r3
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3822:	6a3b      	ldr	r3, [r7, #32]
    3824:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    3826:	61fb      	str	r3, [r7, #28]

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3828:	69fb      	ldr	r3, [r7, #28]
    382a:	2b00      	cmp	r3, #0
    382c:	d01a      	beq.n	3864 <xQueueReceive+0x9c>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    382e:	68ba      	ldr	r2, [r7, #8]
    3830:	6a3b      	ldr	r3, [r7, #32]
    3832:	0011      	movs	r1, r2
    3834:	0018      	movs	r0, r3
    3836:	4b41      	ldr	r3, [pc, #260]	; (393c <xQueueReceive+0x174>)
    3838:	4798      	blx	r3
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    383a:	69fb      	ldr	r3, [r7, #28]
    383c:	1e5a      	subs	r2, r3, #1
    383e:	6a3b      	ldr	r3, [r7, #32]
    3840:	639a      	str	r2, [r3, #56]	; 0x38

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3842:	6a3b      	ldr	r3, [r7, #32]
    3844:	691b      	ldr	r3, [r3, #16]
    3846:	2b00      	cmp	r3, #0
    3848:	d008      	beq.n	385c <xQueueReceive+0x94>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    384a:	6a3b      	ldr	r3, [r7, #32]
    384c:	3310      	adds	r3, #16
    384e:	0018      	movs	r0, r3
    3850:	4b3b      	ldr	r3, [pc, #236]	; (3940 <xQueueReceive+0x178>)
    3852:	4798      	blx	r3
    3854:	1e03      	subs	r3, r0, #0
    3856:	d001      	beq.n	385c <xQueueReceive+0x94>
					{
						queueYIELD_IF_USING_PREEMPTION();
    3858:	4b3a      	ldr	r3, [pc, #232]	; (3944 <xQueueReceive+0x17c>)
    385a:	4798      	blx	r3
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    385c:	4b3a      	ldr	r3, [pc, #232]	; (3948 <xQueueReceive+0x180>)
    385e:	4798      	blx	r3
				return pdPASS;
    3860:	2301      	movs	r3, #1
    3862:	e062      	b.n	392a <xQueueReceive+0x162>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    3864:	687b      	ldr	r3, [r7, #4]
    3866:	2b00      	cmp	r3, #0
    3868:	d103      	bne.n	3872 <xQueueReceive+0xaa>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    386a:	4b37      	ldr	r3, [pc, #220]	; (3948 <xQueueReceive+0x180>)
    386c:	4798      	blx	r3
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    386e:	2300      	movs	r3, #0
    3870:	e05b      	b.n	392a <xQueueReceive+0x162>
				}
				else if( xEntryTimeSet == pdFALSE )
    3872:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    3874:	2b00      	cmp	r3, #0
    3876:	d106      	bne.n	3886 <xQueueReceive+0xbe>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    3878:	2314      	movs	r3, #20
    387a:	18fb      	adds	r3, r7, r3
    387c:	0018      	movs	r0, r3
    387e:	4b33      	ldr	r3, [pc, #204]	; (394c <xQueueReceive+0x184>)
    3880:	4798      	blx	r3
					xEntryTimeSet = pdTRUE;
    3882:	2301      	movs	r3, #1
    3884:	627b      	str	r3, [r7, #36]	; 0x24
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    3886:	4b30      	ldr	r3, [pc, #192]	; (3948 <xQueueReceive+0x180>)
    3888:	4798      	blx	r3

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    388a:	4b31      	ldr	r3, [pc, #196]	; (3950 <xQueueReceive+0x188>)
    388c:	4798      	blx	r3
		prvLockQueue( pxQueue );
    388e:	4b2a      	ldr	r3, [pc, #168]	; (3938 <xQueueReceive+0x170>)
    3890:	4798      	blx	r3
    3892:	6a3b      	ldr	r3, [r7, #32]
    3894:	2244      	movs	r2, #68	; 0x44
    3896:	5c9b      	ldrb	r3, [r3, r2]
    3898:	b25b      	sxtb	r3, r3
    389a:	3301      	adds	r3, #1
    389c:	d103      	bne.n	38a6 <xQueueReceive+0xde>
    389e:	6a3b      	ldr	r3, [r7, #32]
    38a0:	2244      	movs	r2, #68	; 0x44
    38a2:	2100      	movs	r1, #0
    38a4:	5499      	strb	r1, [r3, r2]
    38a6:	6a3b      	ldr	r3, [r7, #32]
    38a8:	2245      	movs	r2, #69	; 0x45
    38aa:	5c9b      	ldrb	r3, [r3, r2]
    38ac:	b25b      	sxtb	r3, r3
    38ae:	3301      	adds	r3, #1
    38b0:	d103      	bne.n	38ba <xQueueReceive+0xf2>
    38b2:	6a3b      	ldr	r3, [r7, #32]
    38b4:	2245      	movs	r2, #69	; 0x45
    38b6:	2100      	movs	r1, #0
    38b8:	5499      	strb	r1, [r3, r2]
    38ba:	4b23      	ldr	r3, [pc, #140]	; (3948 <xQueueReceive+0x180>)
    38bc:	4798      	blx	r3

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    38be:	1d3a      	adds	r2, r7, #4
    38c0:	2314      	movs	r3, #20
    38c2:	18fb      	adds	r3, r7, r3
    38c4:	0011      	movs	r1, r2
    38c6:	0018      	movs	r0, r3
    38c8:	4b22      	ldr	r3, [pc, #136]	; (3954 <xQueueReceive+0x18c>)
    38ca:	4798      	blx	r3
    38cc:	1e03      	subs	r3, r0, #0
    38ce:	d11e      	bne.n	390e <xQueueReceive+0x146>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    38d0:	6a3b      	ldr	r3, [r7, #32]
    38d2:	0018      	movs	r0, r3
    38d4:	4b20      	ldr	r3, [pc, #128]	; (3958 <xQueueReceive+0x190>)
    38d6:	4798      	blx	r3
    38d8:	1e03      	subs	r3, r0, #0
    38da:	d011      	beq.n	3900 <xQueueReceive+0x138>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    38dc:	6a3b      	ldr	r3, [r7, #32]
    38de:	3324      	adds	r3, #36	; 0x24
    38e0:	687a      	ldr	r2, [r7, #4]
    38e2:	0011      	movs	r1, r2
    38e4:	0018      	movs	r0, r3
    38e6:	4b1d      	ldr	r3, [pc, #116]	; (395c <xQueueReceive+0x194>)
    38e8:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
    38ea:	6a3b      	ldr	r3, [r7, #32]
    38ec:	0018      	movs	r0, r3
    38ee:	4b1c      	ldr	r3, [pc, #112]	; (3960 <xQueueReceive+0x198>)
    38f0:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
    38f2:	4b1c      	ldr	r3, [pc, #112]	; (3964 <xQueueReceive+0x19c>)
    38f4:	4798      	blx	r3
    38f6:	1e03      	subs	r3, r0, #0
    38f8:	d191      	bne.n	381e <xQueueReceive+0x56>
				{
					portYIELD_WITHIN_API();
    38fa:	4b12      	ldr	r3, [pc, #72]	; (3944 <xQueueReceive+0x17c>)
    38fc:	4798      	blx	r3
    38fe:	e78e      	b.n	381e <xQueueReceive+0x56>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    3900:	6a3b      	ldr	r3, [r7, #32]
    3902:	0018      	movs	r0, r3
    3904:	4b16      	ldr	r3, [pc, #88]	; (3960 <xQueueReceive+0x198>)
    3906:	4798      	blx	r3
				( void ) xTaskResumeAll();
    3908:	4b16      	ldr	r3, [pc, #88]	; (3964 <xQueueReceive+0x19c>)
    390a:	4798      	blx	r3
    390c:	e787      	b.n	381e <xQueueReceive+0x56>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    390e:	6a3b      	ldr	r3, [r7, #32]
    3910:	0018      	movs	r0, r3
    3912:	4b13      	ldr	r3, [pc, #76]	; (3960 <xQueueReceive+0x198>)
    3914:	4798      	blx	r3
			( void ) xTaskResumeAll();
    3916:	4b13      	ldr	r3, [pc, #76]	; (3964 <xQueueReceive+0x19c>)
    3918:	4798      	blx	r3

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    391a:	6a3b      	ldr	r3, [r7, #32]
    391c:	0018      	movs	r0, r3
    391e:	4b0e      	ldr	r3, [pc, #56]	; (3958 <xQueueReceive+0x190>)
    3920:	4798      	blx	r3
    3922:	1e03      	subs	r3, r0, #0
    3924:	d100      	bne.n	3928 <xQueueReceive+0x160>
    3926:	e77a      	b.n	381e <xQueueReceive+0x56>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    3928:	2300      	movs	r3, #0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    392a:	0018      	movs	r0, r3
    392c:	46bd      	mov	sp, r7
    392e:	b00a      	add	sp, #40	; 0x28
    3930:	bd80      	pop	{r7, pc}
    3932:	46c0      	nop			; (mov r8, r8)
    3934:	00004aad 	.word	0x00004aad
    3938:	00003061 	.word	0x00003061
    393c:	00003c69 	.word	0x00003c69
    3940:	00004775 	.word	0x00004775
    3944:	00003041 	.word	0x00003041
    3948:	00003085 	.word	0x00003085
    394c:	00004835 	.word	0x00004835
    3950:	000042f5 	.word	0x000042f5
    3954:	0000485d 	.word	0x0000485d
    3958:	00003da9 	.word	0x00003da9
    395c:	000046dd 	.word	0x000046dd
    3960:	00003cb9 	.word	0x00003cb9
    3964:	0000430d 	.word	0x0000430d

00003968 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    3968:	b580      	push	{r7, lr}
    396a:	b08a      	sub	sp, #40	; 0x28
    396c:	af00      	add	r7, sp, #0
    396e:	6078      	str	r0, [r7, #4]
    3970:	6039      	str	r1, [r7, #0]
BaseType_t xEntryTimeSet = pdFALSE;
    3972:	2300      	movs	r3, #0
    3974:	627b      	str	r3, [r7, #36]	; 0x24
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    3976:	687b      	ldr	r3, [r7, #4]
    3978:	61fb      	str	r3, [r7, #28]

#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
    397a:	2300      	movs	r3, #0
    397c:	623b      	str	r3, [r7, #32]
#endif

	/* Check the queue pointer is not NULL. */
	configASSERT( ( pxQueue ) );
    397e:	69fb      	ldr	r3, [r7, #28]
    3980:	2b00      	cmp	r3, #0
    3982:	d101      	bne.n	3988 <xQueueSemaphoreTake+0x20>
    3984:	b672      	cpsid	i
    3986:	e7fe      	b.n	3986 <xQueueSemaphoreTake+0x1e>

	/* Check this really is a semaphore, in which case the item size will be
	0. */
	configASSERT( pxQueue->uxItemSize == 0 );
    3988:	69fb      	ldr	r3, [r7, #28]
    398a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    398c:	2b00      	cmp	r3, #0
    398e:	d001      	beq.n	3994 <xQueueSemaphoreTake+0x2c>
    3990:	b672      	cpsid	i
    3992:	e7fe      	b.n	3992 <xQueueSemaphoreTake+0x2a>

	/* Cannot block if the scheduler is suspended. */
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    3994:	4b61      	ldr	r3, [pc, #388]	; (3b1c <xQueueSemaphoreTake+0x1b4>)
    3996:	4798      	blx	r3
    3998:	1e03      	subs	r3, r0, #0
    399a:	d102      	bne.n	39a2 <xQueueSemaphoreTake+0x3a>
    399c:	683b      	ldr	r3, [r7, #0]
    399e:	2b00      	cmp	r3, #0
    39a0:	d101      	bne.n	39a6 <xQueueSemaphoreTake+0x3e>
    39a2:	2301      	movs	r3, #1
    39a4:	e000      	b.n	39a8 <xQueueSemaphoreTake+0x40>
    39a6:	2300      	movs	r3, #0
    39a8:	2b00      	cmp	r3, #0
    39aa:	d101      	bne.n	39b0 <xQueueSemaphoreTake+0x48>
    39ac:	b672      	cpsid	i
    39ae:	e7fe      	b.n	39ae <xQueueSemaphoreTake+0x46>
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    39b0:	4b5b      	ldr	r3, [pc, #364]	; (3b20 <xQueueSemaphoreTake+0x1b8>)
    39b2:	4798      	blx	r3
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    39b4:	69fb      	ldr	r3, [r7, #28]
    39b6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    39b8:	61bb      	str	r3, [r7, #24]

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    39ba:	69bb      	ldr	r3, [r7, #24]
    39bc:	2b00      	cmp	r3, #0
    39be:	d01d      	beq.n	39fc <xQueueSemaphoreTake+0x94>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    39c0:	69bb      	ldr	r3, [r7, #24]
    39c2:	1e5a      	subs	r2, r3, #1
    39c4:	69fb      	ldr	r3, [r7, #28]
    39c6:	639a      	str	r2, [r3, #56]	; 0x38

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    39c8:	69fb      	ldr	r3, [r7, #28]
    39ca:	681b      	ldr	r3, [r3, #0]
    39cc:	2b00      	cmp	r3, #0
    39ce:	d104      	bne.n	39da <xQueueSemaphoreTake+0x72>
					{
						/* Record the information required to implement
						priority inheritance should it become necessary. */
						pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    39d0:	4b54      	ldr	r3, [pc, #336]	; (3b24 <xQueueSemaphoreTake+0x1bc>)
    39d2:	4798      	blx	r3
    39d4:	0002      	movs	r2, r0
    39d6:	69fb      	ldr	r3, [r7, #28]
    39d8:	605a      	str	r2, [r3, #4]
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    39da:	69fb      	ldr	r3, [r7, #28]
    39dc:	691b      	ldr	r3, [r3, #16]
    39de:	2b00      	cmp	r3, #0
    39e0:	d008      	beq.n	39f4 <xQueueSemaphoreTake+0x8c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    39e2:	69fb      	ldr	r3, [r7, #28]
    39e4:	3310      	adds	r3, #16
    39e6:	0018      	movs	r0, r3
    39e8:	4b4f      	ldr	r3, [pc, #316]	; (3b28 <xQueueSemaphoreTake+0x1c0>)
    39ea:	4798      	blx	r3
    39ec:	1e03      	subs	r3, r0, #0
    39ee:	d001      	beq.n	39f4 <xQueueSemaphoreTake+0x8c>
					{
						queueYIELD_IF_USING_PREEMPTION();
    39f0:	4b4e      	ldr	r3, [pc, #312]	; (3b2c <xQueueSemaphoreTake+0x1c4>)
    39f2:	4798      	blx	r3
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    39f4:	4b4e      	ldr	r3, [pc, #312]	; (3b30 <xQueueSemaphoreTake+0x1c8>)
    39f6:	4798      	blx	r3
				return pdPASS;
    39f8:	2301      	movs	r3, #1
    39fa:	e08b      	b.n	3b14 <xQueueSemaphoreTake+0x1ac>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    39fc:	683b      	ldr	r3, [r7, #0]
    39fe:	2b00      	cmp	r3, #0
    3a00:	d108      	bne.n	3a14 <xQueueSemaphoreTake+0xac>
					/* For inheritance to have occurred there must have been an
					initial timeout, and an adjusted timeout cannot become 0, as
					if it were 0 the function would have exited. */
					#if( configUSE_MUTEXES == 1 )
					{
						configASSERT( xInheritanceOccurred == pdFALSE );
    3a02:	6a3b      	ldr	r3, [r7, #32]
    3a04:	2b00      	cmp	r3, #0
    3a06:	d001      	beq.n	3a0c <xQueueSemaphoreTake+0xa4>
    3a08:	b672      	cpsid	i
    3a0a:	e7fe      	b.n	3a0a <xQueueSemaphoreTake+0xa2>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    3a0c:	4b48      	ldr	r3, [pc, #288]	; (3b30 <xQueueSemaphoreTake+0x1c8>)
    3a0e:	4798      	blx	r3
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    3a10:	2300      	movs	r3, #0
    3a12:	e07f      	b.n	3b14 <xQueueSemaphoreTake+0x1ac>
				}
				else if( xEntryTimeSet == pdFALSE )
    3a14:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    3a16:	2b00      	cmp	r3, #0
    3a18:	d106      	bne.n	3a28 <xQueueSemaphoreTake+0xc0>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    3a1a:	230c      	movs	r3, #12
    3a1c:	18fb      	adds	r3, r7, r3
    3a1e:	0018      	movs	r0, r3
    3a20:	4b44      	ldr	r3, [pc, #272]	; (3b34 <xQueueSemaphoreTake+0x1cc>)
    3a22:	4798      	blx	r3
					xEntryTimeSet = pdTRUE;
    3a24:	2301      	movs	r3, #1
    3a26:	627b      	str	r3, [r7, #36]	; 0x24
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    3a28:	4b41      	ldr	r3, [pc, #260]	; (3b30 <xQueueSemaphoreTake+0x1c8>)
    3a2a:	4798      	blx	r3

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    3a2c:	4b42      	ldr	r3, [pc, #264]	; (3b38 <xQueueSemaphoreTake+0x1d0>)
    3a2e:	4798      	blx	r3
		prvLockQueue( pxQueue );
    3a30:	4b3b      	ldr	r3, [pc, #236]	; (3b20 <xQueueSemaphoreTake+0x1b8>)
    3a32:	4798      	blx	r3
    3a34:	69fb      	ldr	r3, [r7, #28]
    3a36:	2244      	movs	r2, #68	; 0x44
    3a38:	5c9b      	ldrb	r3, [r3, r2]
    3a3a:	b25b      	sxtb	r3, r3
    3a3c:	3301      	adds	r3, #1
    3a3e:	d103      	bne.n	3a48 <xQueueSemaphoreTake+0xe0>
    3a40:	69fb      	ldr	r3, [r7, #28]
    3a42:	2244      	movs	r2, #68	; 0x44
    3a44:	2100      	movs	r1, #0
    3a46:	5499      	strb	r1, [r3, r2]
    3a48:	69fb      	ldr	r3, [r7, #28]
    3a4a:	2245      	movs	r2, #69	; 0x45
    3a4c:	5c9b      	ldrb	r3, [r3, r2]
    3a4e:	b25b      	sxtb	r3, r3
    3a50:	3301      	adds	r3, #1
    3a52:	d103      	bne.n	3a5c <xQueueSemaphoreTake+0xf4>
    3a54:	69fb      	ldr	r3, [r7, #28]
    3a56:	2245      	movs	r2, #69	; 0x45
    3a58:	2100      	movs	r1, #0
    3a5a:	5499      	strb	r1, [r3, r2]
    3a5c:	4b34      	ldr	r3, [pc, #208]	; (3b30 <xQueueSemaphoreTake+0x1c8>)
    3a5e:	4798      	blx	r3

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3a60:	003a      	movs	r2, r7
    3a62:	230c      	movs	r3, #12
    3a64:	18fb      	adds	r3, r7, r3
    3a66:	0011      	movs	r1, r2
    3a68:	0018      	movs	r0, r3
    3a6a:	4b34      	ldr	r3, [pc, #208]	; (3b3c <xQueueSemaphoreTake+0x1d4>)
    3a6c:	4798      	blx	r3
    3a6e:	1e03      	subs	r3, r0, #0
    3a70:	d12e      	bne.n	3ad0 <xQueueSemaphoreTake+0x168>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3a72:	69fb      	ldr	r3, [r7, #28]
    3a74:	0018      	movs	r0, r3
    3a76:	4b32      	ldr	r3, [pc, #200]	; (3b40 <xQueueSemaphoreTake+0x1d8>)
    3a78:	4798      	blx	r3
    3a7a:	1e03      	subs	r3, r0, #0
    3a7c:	d021      	beq.n	3ac2 <xQueueSemaphoreTake+0x15a>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    3a7e:	69fb      	ldr	r3, [r7, #28]
    3a80:	681b      	ldr	r3, [r3, #0]
    3a82:	2b00      	cmp	r3, #0
    3a84:	d10a      	bne.n	3a9c <xQueueSemaphoreTake+0x134>
					{
						taskENTER_CRITICAL();
    3a86:	4b26      	ldr	r3, [pc, #152]	; (3b20 <xQueueSemaphoreTake+0x1b8>)
    3a88:	4798      	blx	r3
						{
							xInheritanceOccurred = xTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    3a8a:	69fb      	ldr	r3, [r7, #28]
    3a8c:	685b      	ldr	r3, [r3, #4]
    3a8e:	0018      	movs	r0, r3
    3a90:	4b2c      	ldr	r3, [pc, #176]	; (3b44 <xQueueSemaphoreTake+0x1dc>)
    3a92:	4798      	blx	r3
    3a94:	0003      	movs	r3, r0
    3a96:	623b      	str	r3, [r7, #32]
						}
						taskEXIT_CRITICAL();
    3a98:	4b25      	ldr	r3, [pc, #148]	; (3b30 <xQueueSemaphoreTake+0x1c8>)
    3a9a:	4798      	blx	r3
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3a9c:	69fb      	ldr	r3, [r7, #28]
    3a9e:	3324      	adds	r3, #36	; 0x24
    3aa0:	683a      	ldr	r2, [r7, #0]
    3aa2:	0011      	movs	r1, r2
    3aa4:	0018      	movs	r0, r3
    3aa6:	4b28      	ldr	r3, [pc, #160]	; (3b48 <xQueueSemaphoreTake+0x1e0>)
    3aa8:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
    3aaa:	69fb      	ldr	r3, [r7, #28]
    3aac:	0018      	movs	r0, r3
    3aae:	4b27      	ldr	r3, [pc, #156]	; (3b4c <xQueueSemaphoreTake+0x1e4>)
    3ab0:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
    3ab2:	4b27      	ldr	r3, [pc, #156]	; (3b50 <xQueueSemaphoreTake+0x1e8>)
    3ab4:	4798      	blx	r3
    3ab6:	1e03      	subs	r3, r0, #0
    3ab8:	d000      	beq.n	3abc <xQueueSemaphoreTake+0x154>
    3aba:	e779      	b.n	39b0 <xQueueSemaphoreTake+0x48>
				{
					portYIELD_WITHIN_API();
    3abc:	4b1b      	ldr	r3, [pc, #108]	; (3b2c <xQueueSemaphoreTake+0x1c4>)
    3abe:	4798      	blx	r3
    3ac0:	e776      	b.n	39b0 <xQueueSemaphoreTake+0x48>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    3ac2:	69fb      	ldr	r3, [r7, #28]
    3ac4:	0018      	movs	r0, r3
    3ac6:	4b21      	ldr	r3, [pc, #132]	; (3b4c <xQueueSemaphoreTake+0x1e4>)
    3ac8:	4798      	blx	r3
				( void ) xTaskResumeAll();
    3aca:	4b21      	ldr	r3, [pc, #132]	; (3b50 <xQueueSemaphoreTake+0x1e8>)
    3acc:	4798      	blx	r3
    3ace:	e76f      	b.n	39b0 <xQueueSemaphoreTake+0x48>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    3ad0:	69fb      	ldr	r3, [r7, #28]
    3ad2:	0018      	movs	r0, r3
    3ad4:	4b1d      	ldr	r3, [pc, #116]	; (3b4c <xQueueSemaphoreTake+0x1e4>)
    3ad6:	4798      	blx	r3
			( void ) xTaskResumeAll();
    3ad8:	4b1d      	ldr	r3, [pc, #116]	; (3b50 <xQueueSemaphoreTake+0x1e8>)
    3ada:	4798      	blx	r3

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3adc:	69fb      	ldr	r3, [r7, #28]
    3ade:	0018      	movs	r0, r3
    3ae0:	4b17      	ldr	r3, [pc, #92]	; (3b40 <xQueueSemaphoreTake+0x1d8>)
    3ae2:	4798      	blx	r3
    3ae4:	1e03      	subs	r3, r0, #0
    3ae6:	d100      	bne.n	3aea <xQueueSemaphoreTake+0x182>
    3ae8:	e762      	b.n	39b0 <xQueueSemaphoreTake+0x48>
				#if ( configUSE_MUTEXES == 1 )
				{
					/* xInheritanceOccurred could only have be set if
					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
					test the mutex type again to check it is actually a mutex. */
					if( xInheritanceOccurred != pdFALSE )
    3aea:	6a3b      	ldr	r3, [r7, #32]
    3aec:	2b00      	cmp	r3, #0
    3aee:	d010      	beq.n	3b12 <xQueueSemaphoreTake+0x1aa>
					{
						taskENTER_CRITICAL();
    3af0:	4b0b      	ldr	r3, [pc, #44]	; (3b20 <xQueueSemaphoreTake+0x1b8>)
    3af2:	4798      	blx	r3
							/* This task blocking on the mutex caused another
							task to inherit this task's priority.  Now this task
							has timed out the priority should be disinherited
							again, but only as low as the next highest priority
							task that is waiting for the same mutex. */
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
    3af4:	69fb      	ldr	r3, [r7, #28]
    3af6:	0018      	movs	r0, r3
    3af8:	4b16      	ldr	r3, [pc, #88]	; (3b54 <xQueueSemaphoreTake+0x1ec>)
    3afa:	4798      	blx	r3
    3afc:	0003      	movs	r3, r0
    3afe:	617b      	str	r3, [r7, #20]
							vTaskPriorityDisinheritAfterTimeout( ( void * ) pxQueue->pxMutexHolder, uxHighestWaitingPriority );
    3b00:	69fb      	ldr	r3, [r7, #28]
    3b02:	685b      	ldr	r3, [r3, #4]
    3b04:	697a      	ldr	r2, [r7, #20]
    3b06:	0011      	movs	r1, r2
    3b08:	0018      	movs	r0, r3
    3b0a:	4b13      	ldr	r3, [pc, #76]	; (3b58 <xQueueSemaphoreTake+0x1f0>)
    3b0c:	4798      	blx	r3
						}
						taskEXIT_CRITICAL();
    3b0e:	4b08      	ldr	r3, [pc, #32]	; (3b30 <xQueueSemaphoreTake+0x1c8>)
    3b10:	4798      	blx	r3
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    3b12:	2300      	movs	r3, #0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    3b14:	0018      	movs	r0, r3
    3b16:	46bd      	mov	sp, r7
    3b18:	b00a      	add	sp, #40	; 0x28
    3b1a:	bd80      	pop	{r7, pc}
    3b1c:	00004aad 	.word	0x00004aad
    3b20:	00003061 	.word	0x00003061
    3b24:	00004d79 	.word	0x00004d79
    3b28:	00004775 	.word	0x00004775
    3b2c:	00003041 	.word	0x00003041
    3b30:	00003085 	.word	0x00003085
    3b34:	00004835 	.word	0x00004835
    3b38:	000042f5 	.word	0x000042f5
    3b3c:	0000485d 	.word	0x0000485d
    3b40:	00003da9 	.word	0x00003da9
    3b44:	00004ae5 	.word	0x00004ae5
    3b48:	000046dd 	.word	0x000046dd
    3b4c:	00003cb9 	.word	0x00003cb9
    3b50:	0000430d 	.word	0x0000430d
    3b54:	00003b5d 	.word	0x00003b5d
    3b58:	00004c89 	.word	0x00004c89

00003b5c <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
	{
    3b5c:	b580      	push	{r7, lr}
    3b5e:	b084      	sub	sp, #16
    3b60:	af00      	add	r7, sp, #0
    3b62:	6078      	str	r0, [r7, #4]
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0 )
    3b64:	687b      	ldr	r3, [r7, #4]
    3b66:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    3b68:	2b00      	cmp	r3, #0
    3b6a:	d006      	beq.n	3b7a <prvGetDisinheritPriorityAfterTimeout+0x1e>
		{
			uxHighestPriorityOfWaitingTasks = configMAX_PRIORITIES - listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
    3b6c:	687b      	ldr	r3, [r7, #4]
    3b6e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    3b70:	681b      	ldr	r3, [r3, #0]
    3b72:	2205      	movs	r2, #5
    3b74:	1ad3      	subs	r3, r2, r3
    3b76:	60fb      	str	r3, [r7, #12]
    3b78:	e001      	b.n	3b7e <prvGetDisinheritPriorityAfterTimeout+0x22>
		}
		else
		{
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
    3b7a:	2300      	movs	r3, #0
    3b7c:	60fb      	str	r3, [r7, #12]
		}

		return uxHighestPriorityOfWaitingTasks;
    3b7e:	68fb      	ldr	r3, [r7, #12]
	}
    3b80:	0018      	movs	r0, r3
    3b82:	46bd      	mov	sp, r7
    3b84:	b004      	add	sp, #16
    3b86:	bd80      	pop	{r7, pc}

00003b88 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    3b88:	b580      	push	{r7, lr}
    3b8a:	b086      	sub	sp, #24
    3b8c:	af00      	add	r7, sp, #0
    3b8e:	60f8      	str	r0, [r7, #12]
    3b90:	60b9      	str	r1, [r7, #8]
    3b92:	607a      	str	r2, [r7, #4]
BaseType_t xReturn = pdFALSE;
    3b94:	2300      	movs	r3, #0
    3b96:	617b      	str	r3, [r7, #20]
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3b98:	68fb      	ldr	r3, [r7, #12]
    3b9a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    3b9c:	613b      	str	r3, [r7, #16]

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    3b9e:	68fb      	ldr	r3, [r7, #12]
    3ba0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    3ba2:	2b00      	cmp	r3, #0
    3ba4:	d10e      	bne.n	3bc4 <prvCopyDataToQueue+0x3c>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    3ba6:	68fb      	ldr	r3, [r7, #12]
    3ba8:	681b      	ldr	r3, [r3, #0]
    3baa:	2b00      	cmp	r3, #0
    3bac:	d14e      	bne.n	3c4c <prvCopyDataToQueue+0xc4>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    3bae:	68fb      	ldr	r3, [r7, #12]
    3bb0:	685b      	ldr	r3, [r3, #4]
    3bb2:	0018      	movs	r0, r3
    3bb4:	4b2a      	ldr	r3, [pc, #168]	; (3c60 <prvCopyDataToQueue+0xd8>)
    3bb6:	4798      	blx	r3
    3bb8:	0003      	movs	r3, r0
    3bba:	617b      	str	r3, [r7, #20]
				pxQueue->pxMutexHolder = NULL;
    3bbc:	68fb      	ldr	r3, [r7, #12]
    3bbe:	2200      	movs	r2, #0
    3bc0:	605a      	str	r2, [r3, #4]
    3bc2:	e043      	b.n	3c4c <prvCopyDataToQueue+0xc4>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    3bc4:	687b      	ldr	r3, [r7, #4]
    3bc6:	2b00      	cmp	r3, #0
    3bc8:	d119      	bne.n	3bfe <prvCopyDataToQueue+0x76>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    3bca:	68fb      	ldr	r3, [r7, #12]
    3bcc:	6898      	ldr	r0, [r3, #8]
    3bce:	68fb      	ldr	r3, [r7, #12]
    3bd0:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    3bd2:	68bb      	ldr	r3, [r7, #8]
    3bd4:	0019      	movs	r1, r3
    3bd6:	4b23      	ldr	r3, [pc, #140]	; (3c64 <prvCopyDataToQueue+0xdc>)
    3bd8:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    3bda:	68fb      	ldr	r3, [r7, #12]
    3bdc:	689a      	ldr	r2, [r3, #8]
    3bde:	68fb      	ldr	r3, [r7, #12]
    3be0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    3be2:	18d2      	adds	r2, r2, r3
    3be4:	68fb      	ldr	r3, [r7, #12]
    3be6:	609a      	str	r2, [r3, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3be8:	68fb      	ldr	r3, [r7, #12]
    3bea:	689a      	ldr	r2, [r3, #8]
    3bec:	68fb      	ldr	r3, [r7, #12]
    3bee:	685b      	ldr	r3, [r3, #4]
    3bf0:	429a      	cmp	r2, r3
    3bf2:	d32b      	bcc.n	3c4c <prvCopyDataToQueue+0xc4>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    3bf4:	68fb      	ldr	r3, [r7, #12]
    3bf6:	681a      	ldr	r2, [r3, #0]
    3bf8:	68fb      	ldr	r3, [r7, #12]
    3bfa:	609a      	str	r2, [r3, #8]
    3bfc:	e026      	b.n	3c4c <prvCopyDataToQueue+0xc4>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3bfe:	68fb      	ldr	r3, [r7, #12]
    3c00:	68d8      	ldr	r0, [r3, #12]
    3c02:	68fb      	ldr	r3, [r7, #12]
    3c04:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    3c06:	68bb      	ldr	r3, [r7, #8]
    3c08:	0019      	movs	r1, r3
    3c0a:	4b16      	ldr	r3, [pc, #88]	; (3c64 <prvCopyDataToQueue+0xdc>)
    3c0c:	4798      	blx	r3
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    3c0e:	68fb      	ldr	r3, [r7, #12]
    3c10:	68da      	ldr	r2, [r3, #12]
    3c12:	68fb      	ldr	r3, [r7, #12]
    3c14:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    3c16:	425b      	negs	r3, r3
    3c18:	18d2      	adds	r2, r2, r3
    3c1a:	68fb      	ldr	r3, [r7, #12]
    3c1c:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3c1e:	68fb      	ldr	r3, [r7, #12]
    3c20:	68da      	ldr	r2, [r3, #12]
    3c22:	68fb      	ldr	r3, [r7, #12]
    3c24:	681b      	ldr	r3, [r3, #0]
    3c26:	429a      	cmp	r2, r3
    3c28:	d207      	bcs.n	3c3a <prvCopyDataToQueue+0xb2>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    3c2a:	68fb      	ldr	r3, [r7, #12]
    3c2c:	685a      	ldr	r2, [r3, #4]
    3c2e:	68fb      	ldr	r3, [r7, #12]
    3c30:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    3c32:	425b      	negs	r3, r3
    3c34:	18d2      	adds	r2, r2, r3
    3c36:	68fb      	ldr	r3, [r7, #12]
    3c38:	60da      	str	r2, [r3, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    3c3a:	687b      	ldr	r3, [r7, #4]
    3c3c:	2b02      	cmp	r3, #2
    3c3e:	d105      	bne.n	3c4c <prvCopyDataToQueue+0xc4>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3c40:	693b      	ldr	r3, [r7, #16]
    3c42:	2b00      	cmp	r3, #0
    3c44:	d002      	beq.n	3c4c <prvCopyDataToQueue+0xc4>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    3c46:	693b      	ldr	r3, [r7, #16]
    3c48:	3b01      	subs	r3, #1
    3c4a:	613b      	str	r3, [r7, #16]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    3c4c:	693b      	ldr	r3, [r7, #16]
    3c4e:	1c5a      	adds	r2, r3, #1
    3c50:	68fb      	ldr	r3, [r7, #12]
    3c52:	639a      	str	r2, [r3, #56]	; 0x38

	return xReturn;
    3c54:	697b      	ldr	r3, [r7, #20]
}
    3c56:	0018      	movs	r0, r3
    3c58:	46bd      	mov	sp, r7
    3c5a:	b006      	add	sp, #24
    3c5c:	bd80      	pop	{r7, pc}
    3c5e:	46c0      	nop			; (mov r8, r8)
    3c60:	00004bc9 	.word	0x00004bc9
    3c64:	00006c25 	.word	0x00006c25

00003c68 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    3c68:	b580      	push	{r7, lr}
    3c6a:	b082      	sub	sp, #8
    3c6c:	af00      	add	r7, sp, #0
    3c6e:	6078      	str	r0, [r7, #4]
    3c70:	6039      	str	r1, [r7, #0]
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    3c72:	687b      	ldr	r3, [r7, #4]
    3c74:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    3c76:	2b00      	cmp	r3, #0
    3c78:	d018      	beq.n	3cac <prvCopyDataFromQueue+0x44>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    3c7a:	687b      	ldr	r3, [r7, #4]
    3c7c:	68da      	ldr	r2, [r3, #12]
    3c7e:	687b      	ldr	r3, [r7, #4]
    3c80:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    3c82:	18d2      	adds	r2, r2, r3
    3c84:	687b      	ldr	r3, [r7, #4]
    3c86:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    3c88:	687b      	ldr	r3, [r7, #4]
    3c8a:	68da      	ldr	r2, [r3, #12]
    3c8c:	687b      	ldr	r3, [r7, #4]
    3c8e:	685b      	ldr	r3, [r3, #4]
    3c90:	429a      	cmp	r2, r3
    3c92:	d303      	bcc.n	3c9c <prvCopyDataFromQueue+0x34>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    3c94:	687b      	ldr	r3, [r7, #4]
    3c96:	681a      	ldr	r2, [r3, #0]
    3c98:	687b      	ldr	r3, [r7, #4]
    3c9a:	60da      	str	r2, [r3, #12]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    3c9c:	687b      	ldr	r3, [r7, #4]
    3c9e:	68d9      	ldr	r1, [r3, #12]
    3ca0:	687b      	ldr	r3, [r7, #4]
    3ca2:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    3ca4:	683b      	ldr	r3, [r7, #0]
    3ca6:	0018      	movs	r0, r3
    3ca8:	4b02      	ldr	r3, [pc, #8]	; (3cb4 <prvCopyDataFromQueue+0x4c>)
    3caa:	4798      	blx	r3
	}
}
    3cac:	46c0      	nop			; (mov r8, r8)
    3cae:	46bd      	mov	sp, r7
    3cb0:	b002      	add	sp, #8
    3cb2:	bd80      	pop	{r7, pc}
    3cb4:	00006c25 	.word	0x00006c25

00003cb8 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    3cb8:	b580      	push	{r7, lr}
    3cba:	b084      	sub	sp, #16
    3cbc:	af00      	add	r7, sp, #0
    3cbe:	6078      	str	r0, [r7, #4]

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    3cc0:	4b34      	ldr	r3, [pc, #208]	; (3d94 <prvUnlockQueue+0xdc>)
    3cc2:	4798      	blx	r3
	{
		int8_t cTxLock = pxQueue->cTxLock;
    3cc4:	230f      	movs	r3, #15
    3cc6:	18fb      	adds	r3, r7, r3
    3cc8:	687a      	ldr	r2, [r7, #4]
    3cca:	2145      	movs	r1, #69	; 0x45
    3ccc:	5c52      	ldrb	r2, [r2, r1]
    3cce:	701a      	strb	r2, [r3, #0]

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    3cd0:	e022      	b.n	3d18 <prvUnlockQueue+0x60>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			#if ( configUSE_QUEUE_SETS == 1 )
			{
				if( pxQueue->pxQueueSetContainer != NULL )
    3cd2:	687b      	ldr	r3, [r7, #4]
    3cd4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    3cd6:	2b00      	cmp	r3, #0
    3cd8:	d009      	beq.n	3cee <prvUnlockQueue+0x36>
				{
					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
    3cda:	687b      	ldr	r3, [r7, #4]
    3cdc:	2100      	movs	r1, #0
    3cde:	0018      	movs	r0, r3
    3ce0:	4b2d      	ldr	r3, [pc, #180]	; (3d98 <prvUnlockQueue+0xe0>)
    3ce2:	4798      	blx	r3
    3ce4:	1e03      	subs	r3, r0, #0
    3ce6:	d00f      	beq.n	3d08 <prvUnlockQueue+0x50>
					{
						/* The queue is a member of a queue set, and posting to
						the queue set caused a higher priority task to unblock.
						A context switch is required. */
						vTaskMissedYield();
    3ce8:	4b2c      	ldr	r3, [pc, #176]	; (3d9c <prvUnlockQueue+0xe4>)
    3cea:	4798      	blx	r3
    3cec:	e00c      	b.n	3d08 <prvUnlockQueue+0x50>
				else
				{
					/* Tasks that are removed from the event list will get
					added to the pending ready list as the scheduler is still
					suspended. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3cee:	687b      	ldr	r3, [r7, #4]
    3cf0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    3cf2:	2b00      	cmp	r3, #0
    3cf4:	d017      	beq.n	3d26 <prvUnlockQueue+0x6e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3cf6:	687b      	ldr	r3, [r7, #4]
    3cf8:	3324      	adds	r3, #36	; 0x24
    3cfa:	0018      	movs	r0, r3
    3cfc:	4b28      	ldr	r3, [pc, #160]	; (3da0 <prvUnlockQueue+0xe8>)
    3cfe:	4798      	blx	r3
    3d00:	1e03      	subs	r3, r0, #0
    3d02:	d001      	beq.n	3d08 <prvUnlockQueue+0x50>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							vTaskMissedYield();
    3d04:	4b25      	ldr	r3, [pc, #148]	; (3d9c <prvUnlockQueue+0xe4>)
    3d06:	4798      	blx	r3
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    3d08:	230f      	movs	r3, #15
    3d0a:	18fb      	adds	r3, r7, r3
    3d0c:	781b      	ldrb	r3, [r3, #0]
    3d0e:	3b01      	subs	r3, #1
    3d10:	b2da      	uxtb	r2, r3
    3d12:	230f      	movs	r3, #15
    3d14:	18fb      	adds	r3, r7, r3
    3d16:	701a      	strb	r2, [r3, #0]
		while( cTxLock > queueLOCKED_UNMODIFIED )
    3d18:	230f      	movs	r3, #15
    3d1a:	18fb      	adds	r3, r7, r3
    3d1c:	781b      	ldrb	r3, [r3, #0]
    3d1e:	b25b      	sxtb	r3, r3
    3d20:	2b00      	cmp	r3, #0
    3d22:	dcd6      	bgt.n	3cd2 <prvUnlockQueue+0x1a>
    3d24:	e000      	b.n	3d28 <prvUnlockQueue+0x70>
						break;
    3d26:	46c0      	nop			; (mov r8, r8)
		}

		pxQueue->cTxLock = queueUNLOCKED;
    3d28:	687b      	ldr	r3, [r7, #4]
    3d2a:	2245      	movs	r2, #69	; 0x45
    3d2c:	21ff      	movs	r1, #255	; 0xff
    3d2e:	5499      	strb	r1, [r3, r2]
	}
	taskEXIT_CRITICAL();
    3d30:	4b1c      	ldr	r3, [pc, #112]	; (3da4 <prvUnlockQueue+0xec>)
    3d32:	4798      	blx	r3

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    3d34:	4b17      	ldr	r3, [pc, #92]	; (3d94 <prvUnlockQueue+0xdc>)
    3d36:	4798      	blx	r3
	{
		int8_t cRxLock = pxQueue->cRxLock;
    3d38:	230e      	movs	r3, #14
    3d3a:	18fb      	adds	r3, r7, r3
    3d3c:	687a      	ldr	r2, [r7, #4]
    3d3e:	2144      	movs	r1, #68	; 0x44
    3d40:	5c52      	ldrb	r2, [r2, r1]
    3d42:	701a      	strb	r2, [r3, #0]

		while( cRxLock > queueLOCKED_UNMODIFIED )
    3d44:	e014      	b.n	3d70 <prvUnlockQueue+0xb8>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3d46:	687b      	ldr	r3, [r7, #4]
    3d48:	691b      	ldr	r3, [r3, #16]
    3d4a:	2b00      	cmp	r3, #0
    3d4c:	d017      	beq.n	3d7e <prvUnlockQueue+0xc6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3d4e:	687b      	ldr	r3, [r7, #4]
    3d50:	3310      	adds	r3, #16
    3d52:	0018      	movs	r0, r3
    3d54:	4b12      	ldr	r3, [pc, #72]	; (3da0 <prvUnlockQueue+0xe8>)
    3d56:	4798      	blx	r3
    3d58:	1e03      	subs	r3, r0, #0
    3d5a:	d001      	beq.n	3d60 <prvUnlockQueue+0xa8>
				{
					vTaskMissedYield();
    3d5c:	4b0f      	ldr	r3, [pc, #60]	; (3d9c <prvUnlockQueue+0xe4>)
    3d5e:	4798      	blx	r3
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    3d60:	230e      	movs	r3, #14
    3d62:	18fb      	adds	r3, r7, r3
    3d64:	781b      	ldrb	r3, [r3, #0]
    3d66:	3b01      	subs	r3, #1
    3d68:	b2da      	uxtb	r2, r3
    3d6a:	230e      	movs	r3, #14
    3d6c:	18fb      	adds	r3, r7, r3
    3d6e:	701a      	strb	r2, [r3, #0]
		while( cRxLock > queueLOCKED_UNMODIFIED )
    3d70:	230e      	movs	r3, #14
    3d72:	18fb      	adds	r3, r7, r3
    3d74:	781b      	ldrb	r3, [r3, #0]
    3d76:	b25b      	sxtb	r3, r3
    3d78:	2b00      	cmp	r3, #0
    3d7a:	dce4      	bgt.n	3d46 <prvUnlockQueue+0x8e>
    3d7c:	e000      	b.n	3d80 <prvUnlockQueue+0xc8>
			}
			else
			{
				break;
    3d7e:	46c0      	nop			; (mov r8, r8)
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    3d80:	687b      	ldr	r3, [r7, #4]
    3d82:	2244      	movs	r2, #68	; 0x44
    3d84:	21ff      	movs	r1, #255	; 0xff
    3d86:	5499      	strb	r1, [r3, r2]
	}
	taskEXIT_CRITICAL();
    3d88:	4b06      	ldr	r3, [pc, #24]	; (3da4 <prvUnlockQueue+0xec>)
    3d8a:	4798      	blx	r3
}
    3d8c:	46c0      	nop			; (mov r8, r8)
    3d8e:	46bd      	mov	sp, r7
    3d90:	b004      	add	sp, #16
    3d92:	bd80      	pop	{r7, pc}
    3d94:	00003061 	.word	0x00003061
    3d98:	00003edd 	.word	0x00003edd
    3d9c:	00004909 	.word	0x00004909
    3da0:	00004775 	.word	0x00004775
    3da4:	00003085 	.word	0x00003085

00003da8 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    3da8:	b580      	push	{r7, lr}
    3daa:	b084      	sub	sp, #16
    3dac:	af00      	add	r7, sp, #0
    3dae:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
    3db0:	4b08      	ldr	r3, [pc, #32]	; (3dd4 <prvIsQueueEmpty+0x2c>)
    3db2:	4798      	blx	r3
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    3db4:	687b      	ldr	r3, [r7, #4]
    3db6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    3db8:	2b00      	cmp	r3, #0
    3dba:	d102      	bne.n	3dc2 <prvIsQueueEmpty+0x1a>
		{
			xReturn = pdTRUE;
    3dbc:	2301      	movs	r3, #1
    3dbe:	60fb      	str	r3, [r7, #12]
    3dc0:	e001      	b.n	3dc6 <prvIsQueueEmpty+0x1e>
		}
		else
		{
			xReturn = pdFALSE;
    3dc2:	2300      	movs	r3, #0
    3dc4:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
    3dc6:	4b04      	ldr	r3, [pc, #16]	; (3dd8 <prvIsQueueEmpty+0x30>)
    3dc8:	4798      	blx	r3

	return xReturn;
    3dca:	68fb      	ldr	r3, [r7, #12]
}
    3dcc:	0018      	movs	r0, r3
    3dce:	46bd      	mov	sp, r7
    3dd0:	b004      	add	sp, #16
    3dd2:	bd80      	pop	{r7, pc}
    3dd4:	00003061 	.word	0x00003061
    3dd8:	00003085 	.word	0x00003085

00003ddc <prvIsQueueFull>:
	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    3ddc:	b580      	push	{r7, lr}
    3dde:	b084      	sub	sp, #16
    3de0:	af00      	add	r7, sp, #0
    3de2:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
    3de4:	4b09      	ldr	r3, [pc, #36]	; (3e0c <prvIsQueueFull+0x30>)
    3de6:	4798      	blx	r3
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    3de8:	687b      	ldr	r3, [r7, #4]
    3dea:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    3dec:	687b      	ldr	r3, [r7, #4]
    3dee:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    3df0:	429a      	cmp	r2, r3
    3df2:	d102      	bne.n	3dfa <prvIsQueueFull+0x1e>
		{
			xReturn = pdTRUE;
    3df4:	2301      	movs	r3, #1
    3df6:	60fb      	str	r3, [r7, #12]
    3df8:	e001      	b.n	3dfe <prvIsQueueFull+0x22>
		}
		else
		{
			xReturn = pdFALSE;
    3dfa:	2300      	movs	r3, #0
    3dfc:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
    3dfe:	4b04      	ldr	r3, [pc, #16]	; (3e10 <prvIsQueueFull+0x34>)
    3e00:	4798      	blx	r3

	return xReturn;
    3e02:	68fb      	ldr	r3, [r7, #12]
}
    3e04:	0018      	movs	r0, r3
    3e06:	46bd      	mov	sp, r7
    3e08:	b004      	add	sp, #16
    3e0a:	bd80      	pop	{r7, pc}
    3e0c:	00003061 	.word	0x00003061
    3e10:	00003085 	.word	0x00003085

00003e14 <vQueueAddToRegistry>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    3e14:	b580      	push	{r7, lr}
    3e16:	b084      	sub	sp, #16
    3e18:	af00      	add	r7, sp, #0
    3e1a:	6078      	str	r0, [r7, #4]
    3e1c:	6039      	str	r1, [r7, #0]
	UBaseType_t ux;

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    3e1e:	2300      	movs	r3, #0
    3e20:	60fb      	str	r3, [r7, #12]
    3e22:	e015      	b.n	3e50 <vQueueAddToRegistry+0x3c>
		{
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
    3e24:	4b0e      	ldr	r3, [pc, #56]	; (3e60 <vQueueAddToRegistry+0x4c>)
    3e26:	68fa      	ldr	r2, [r7, #12]
    3e28:	00d2      	lsls	r2, r2, #3
    3e2a:	58d3      	ldr	r3, [r2, r3]
    3e2c:	2b00      	cmp	r3, #0
    3e2e:	d10c      	bne.n	3e4a <vQueueAddToRegistry+0x36>
			{
				/* Store the information on this queue. */
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
    3e30:	4b0b      	ldr	r3, [pc, #44]	; (3e60 <vQueueAddToRegistry+0x4c>)
    3e32:	68fa      	ldr	r2, [r7, #12]
    3e34:	00d2      	lsls	r2, r2, #3
    3e36:	6839      	ldr	r1, [r7, #0]
    3e38:	50d1      	str	r1, [r2, r3]
				xQueueRegistry[ ux ].xHandle = xQueue;
    3e3a:	4a09      	ldr	r2, [pc, #36]	; (3e60 <vQueueAddToRegistry+0x4c>)
    3e3c:	68fb      	ldr	r3, [r7, #12]
    3e3e:	00db      	lsls	r3, r3, #3
    3e40:	18d3      	adds	r3, r2, r3
    3e42:	3304      	adds	r3, #4
    3e44:	687a      	ldr	r2, [r7, #4]
    3e46:	601a      	str	r2, [r3, #0]

				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
				break;
    3e48:	e005      	b.n	3e56 <vQueueAddToRegistry+0x42>
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    3e4a:	68fb      	ldr	r3, [r7, #12]
    3e4c:	3301      	adds	r3, #1
    3e4e:	60fb      	str	r3, [r7, #12]
    3e50:	68fb      	ldr	r3, [r7, #12]
    3e52:	2b07      	cmp	r3, #7
    3e54:	d9e6      	bls.n	3e24 <vQueueAddToRegistry+0x10>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    3e56:	46c0      	nop			; (mov r8, r8)
    3e58:	46bd      	mov	sp, r7
    3e5a:	b004      	add	sp, #16
    3e5c:	bd80      	pop	{r7, pc}
    3e5e:	46c0      	nop			; (mov r8, r8)
    3e60:	2000332c 	.word	0x2000332c

00003e64 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
    3e64:	b580      	push	{r7, lr}
    3e66:	b086      	sub	sp, #24
    3e68:	af00      	add	r7, sp, #0
    3e6a:	60f8      	str	r0, [r7, #12]
    3e6c:	60b9      	str	r1, [r7, #8]
    3e6e:	607a      	str	r2, [r7, #4]
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    3e70:	68fb      	ldr	r3, [r7, #12]
    3e72:	617b      	str	r3, [r7, #20]
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    3e74:	4b15      	ldr	r3, [pc, #84]	; (3ecc <vQueueWaitForMessageRestricted+0x68>)
    3e76:	4798      	blx	r3
    3e78:	697b      	ldr	r3, [r7, #20]
    3e7a:	2244      	movs	r2, #68	; 0x44
    3e7c:	5c9b      	ldrb	r3, [r3, r2]
    3e7e:	b25b      	sxtb	r3, r3
    3e80:	3301      	adds	r3, #1
    3e82:	d103      	bne.n	3e8c <vQueueWaitForMessageRestricted+0x28>
    3e84:	697b      	ldr	r3, [r7, #20]
    3e86:	2244      	movs	r2, #68	; 0x44
    3e88:	2100      	movs	r1, #0
    3e8a:	5499      	strb	r1, [r3, r2]
    3e8c:	697b      	ldr	r3, [r7, #20]
    3e8e:	2245      	movs	r2, #69	; 0x45
    3e90:	5c9b      	ldrb	r3, [r3, r2]
    3e92:	b25b      	sxtb	r3, r3
    3e94:	3301      	adds	r3, #1
    3e96:	d103      	bne.n	3ea0 <vQueueWaitForMessageRestricted+0x3c>
    3e98:	697b      	ldr	r3, [r7, #20]
    3e9a:	2245      	movs	r2, #69	; 0x45
    3e9c:	2100      	movs	r1, #0
    3e9e:	5499      	strb	r1, [r3, r2]
    3ea0:	4b0b      	ldr	r3, [pc, #44]	; (3ed0 <vQueueWaitForMessageRestricted+0x6c>)
    3ea2:	4798      	blx	r3
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    3ea4:	697b      	ldr	r3, [r7, #20]
    3ea6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    3ea8:	2b00      	cmp	r3, #0
    3eaa:	d106      	bne.n	3eba <vQueueWaitForMessageRestricted+0x56>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    3eac:	697b      	ldr	r3, [r7, #20]
    3eae:	3324      	adds	r3, #36	; 0x24
    3eb0:	687a      	ldr	r2, [r7, #4]
    3eb2:	68b9      	ldr	r1, [r7, #8]
    3eb4:	0018      	movs	r0, r3
    3eb6:	4b07      	ldr	r3, [pc, #28]	; (3ed4 <vQueueWaitForMessageRestricted+0x70>)
    3eb8:	4798      	blx	r3
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
    3eba:	697b      	ldr	r3, [r7, #20]
    3ebc:	0018      	movs	r0, r3
    3ebe:	4b06      	ldr	r3, [pc, #24]	; (3ed8 <vQueueWaitForMessageRestricted+0x74>)
    3ec0:	4798      	blx	r3
	}
    3ec2:	46c0      	nop			; (mov r8, r8)
    3ec4:	46bd      	mov	sp, r7
    3ec6:	b006      	add	sp, #24
    3ec8:	bd80      	pop	{r7, pc}
    3eca:	46c0      	nop			; (mov r8, r8)
    3ecc:	00003061 	.word	0x00003061
    3ed0:	00003085 	.word	0x00003085
    3ed4:	00004721 	.word	0x00004721
    3ed8:	00003cb9 	.word	0x00003cb9

00003edc <prvNotifyQueueSetContainer>:
/*-----------------------------------------------------------*/

#if ( configUSE_QUEUE_SETS == 1 )

	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition )
	{
    3edc:	b580      	push	{r7, lr}
    3ede:	b086      	sub	sp, #24
    3ee0:	af00      	add	r7, sp, #0
    3ee2:	6078      	str	r0, [r7, #4]
    3ee4:	6039      	str	r1, [r7, #0]
	Queue_t *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
    3ee6:	687b      	ldr	r3, [r7, #4]
    3ee8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    3eea:	613b      	str	r3, [r7, #16]
	BaseType_t xReturn = pdFALSE;
    3eec:	2300      	movs	r3, #0
    3eee:	617b      	str	r3, [r7, #20]

		/* This function must be called form a critical section. */

		configASSERT( pxQueueSetContainer );
    3ef0:	693b      	ldr	r3, [r7, #16]
    3ef2:	2b00      	cmp	r3, #0
    3ef4:	d101      	bne.n	3efa <prvNotifyQueueSetContainer+0x1e>
    3ef6:	b672      	cpsid	i
    3ef8:	e7fe      	b.n	3ef8 <prvNotifyQueueSetContainer+0x1c>
		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
    3efa:	693b      	ldr	r3, [r7, #16]
    3efc:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    3efe:	693b      	ldr	r3, [r7, #16]
    3f00:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    3f02:	429a      	cmp	r2, r3
    3f04:	d301      	bcc.n	3f0a <prvNotifyQueueSetContainer+0x2e>
    3f06:	b672      	cpsid	i
    3f08:	e7fe      	b.n	3f08 <prvNotifyQueueSetContainer+0x2c>

		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
    3f0a:	693b      	ldr	r3, [r7, #16]
    3f0c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    3f0e:	693b      	ldr	r3, [r7, #16]
    3f10:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    3f12:	429a      	cmp	r2, r3
    3f14:	d22a      	bcs.n	3f6c <prvNotifyQueueSetContainer+0x90>
		{
			const int8_t cTxLock = pxQueueSetContainer->cTxLock;
    3f16:	230f      	movs	r3, #15
    3f18:	18fb      	adds	r3, r7, r3
    3f1a:	693a      	ldr	r2, [r7, #16]
    3f1c:	2145      	movs	r1, #69	; 0x45
    3f1e:	5c52      	ldrb	r2, [r2, r1]
    3f20:	701a      	strb	r2, [r3, #0]

			traceQUEUE_SEND( pxQueueSetContainer );

			/* The data copied is the handle of the queue that contains data. */
			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
    3f22:	683a      	ldr	r2, [r7, #0]
    3f24:	1d39      	adds	r1, r7, #4
    3f26:	693b      	ldr	r3, [r7, #16]
    3f28:	0018      	movs	r0, r3
    3f2a:	4b13      	ldr	r3, [pc, #76]	; (3f78 <prvNotifyQueueSetContainer+0x9c>)
    3f2c:	4798      	blx	r3
    3f2e:	0003      	movs	r3, r0
    3f30:	617b      	str	r3, [r7, #20]

			if( cTxLock == queueUNLOCKED )
    3f32:	230f      	movs	r3, #15
    3f34:	18fb      	adds	r3, r7, r3
    3f36:	781b      	ldrb	r3, [r3, #0]
    3f38:	b25b      	sxtb	r3, r3
    3f3a:	3301      	adds	r3, #1
    3f3c:	d10d      	bne.n	3f5a <prvNotifyQueueSetContainer+0x7e>
			{
				if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
    3f3e:	693b      	ldr	r3, [r7, #16]
    3f40:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    3f42:	2b00      	cmp	r3, #0
    3f44:	d012      	beq.n	3f6c <prvNotifyQueueSetContainer+0x90>
				{
					if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
    3f46:	693b      	ldr	r3, [r7, #16]
    3f48:	3324      	adds	r3, #36	; 0x24
    3f4a:	0018      	movs	r0, r3
    3f4c:	4b0b      	ldr	r3, [pc, #44]	; (3f7c <prvNotifyQueueSetContainer+0xa0>)
    3f4e:	4798      	blx	r3
    3f50:	1e03      	subs	r3, r0, #0
    3f52:	d00b      	beq.n	3f6c <prvNotifyQueueSetContainer+0x90>
					{
						/* The task waiting has a higher priority. */
						xReturn = pdTRUE;
    3f54:	2301      	movs	r3, #1
    3f56:	617b      	str	r3, [r7, #20]
    3f58:	e008      	b.n	3f6c <prvNotifyQueueSetContainer+0x90>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				pxQueueSetContainer->cTxLock = ( int8_t ) ( cTxLock + 1 );
    3f5a:	230f      	movs	r3, #15
    3f5c:	18fb      	adds	r3, r7, r3
    3f5e:	781b      	ldrb	r3, [r3, #0]
    3f60:	3301      	adds	r3, #1
    3f62:	b2db      	uxtb	r3, r3
    3f64:	b259      	sxtb	r1, r3
    3f66:	693b      	ldr	r3, [r7, #16]
    3f68:	2245      	movs	r2, #69	; 0x45
    3f6a:	5499      	strb	r1, [r3, r2]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    3f6c:	697b      	ldr	r3, [r7, #20]
	}
    3f6e:	0018      	movs	r0, r3
    3f70:	46bd      	mov	sp, r7
    3f72:	b006      	add	sp, #24
    3f74:	bd80      	pop	{r7, pc}
    3f76:	46c0      	nop			; (mov r8, r8)
    3f78:	00003b89 	.word	0x00003b89
    3f7c:	00004775 	.word	0x00004775

00003f80 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    3f80:	b590      	push	{r4, r7, lr}
    3f82:	b08d      	sub	sp, #52	; 0x34
    3f84:	af04      	add	r7, sp, #16
    3f86:	60f8      	str	r0, [r7, #12]
    3f88:	60b9      	str	r1, [r7, #8]
    3f8a:	603b      	str	r3, [r7, #0]
    3f8c:	1dbb      	adds	r3, r7, #6
    3f8e:	801a      	strh	r2, [r3, #0]
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3f90:	1dbb      	adds	r3, r7, #6
    3f92:	881b      	ldrh	r3, [r3, #0]
    3f94:	009b      	lsls	r3, r3, #2
    3f96:	0018      	movs	r0, r3
    3f98:	4b1d      	ldr	r3, [pc, #116]	; (4010 <xTaskCreate+0x90>)
    3f9a:	4798      	blx	r3
    3f9c:	0003      	movs	r3, r0
    3f9e:	617b      	str	r3, [r7, #20]

			if( pxStack != NULL )
    3fa0:	697b      	ldr	r3, [r7, #20]
    3fa2:	2b00      	cmp	r3, #0
    3fa4:	d010      	beq.n	3fc8 <xTaskCreate+0x48>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
    3fa6:	2058      	movs	r0, #88	; 0x58
    3fa8:	4b19      	ldr	r3, [pc, #100]	; (4010 <xTaskCreate+0x90>)
    3faa:	4798      	blx	r3
    3fac:	0003      	movs	r3, r0
    3fae:	61fb      	str	r3, [r7, #28]

				if( pxNewTCB != NULL )
    3fb0:	69fb      	ldr	r3, [r7, #28]
    3fb2:	2b00      	cmp	r3, #0
    3fb4:	d003      	beq.n	3fbe <xTaskCreate+0x3e>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    3fb6:	69fb      	ldr	r3, [r7, #28]
    3fb8:	697a      	ldr	r2, [r7, #20]
    3fba:	631a      	str	r2, [r3, #48]	; 0x30
    3fbc:	e006      	b.n	3fcc <xTaskCreate+0x4c>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    3fbe:	697b      	ldr	r3, [r7, #20]
    3fc0:	0018      	movs	r0, r3
    3fc2:	4b14      	ldr	r3, [pc, #80]	; (4014 <xTaskCreate+0x94>)
    3fc4:	4798      	blx	r3
    3fc6:	e001      	b.n	3fcc <xTaskCreate+0x4c>
				}
			}
			else
			{
				pxNewTCB = NULL;
    3fc8:	2300      	movs	r3, #0
    3fca:	61fb      	str	r3, [r7, #28]
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    3fcc:	69fb      	ldr	r3, [r7, #28]
    3fce:	2b00      	cmp	r3, #0
    3fd0:	d016      	beq.n	4000 <xTaskCreate+0x80>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    3fd2:	1dbb      	adds	r3, r7, #6
    3fd4:	881a      	ldrh	r2, [r3, #0]
    3fd6:	683c      	ldr	r4, [r7, #0]
    3fd8:	68b9      	ldr	r1, [r7, #8]
    3fda:	68f8      	ldr	r0, [r7, #12]
    3fdc:	2300      	movs	r3, #0
    3fde:	9303      	str	r3, [sp, #12]
    3fe0:	69fb      	ldr	r3, [r7, #28]
    3fe2:	9302      	str	r3, [sp, #8]
    3fe4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    3fe6:	9301      	str	r3, [sp, #4]
    3fe8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    3fea:	9300      	str	r3, [sp, #0]
    3fec:	0023      	movs	r3, r4
    3fee:	4c0a      	ldr	r4, [pc, #40]	; (4018 <xTaskCreate+0x98>)
    3ff0:	47a0      	blx	r4
			prvAddNewTaskToReadyList( pxNewTCB );
    3ff2:	69fb      	ldr	r3, [r7, #28]
    3ff4:	0018      	movs	r0, r3
    3ff6:	4b09      	ldr	r3, [pc, #36]	; (401c <xTaskCreate+0x9c>)
    3ff8:	4798      	blx	r3
			xReturn = pdPASS;
    3ffa:	2301      	movs	r3, #1
    3ffc:	61bb      	str	r3, [r7, #24]
    3ffe:	e002      	b.n	4006 <xTaskCreate+0x86>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    4000:	2301      	movs	r3, #1
    4002:	425b      	negs	r3, r3
    4004:	61bb      	str	r3, [r7, #24]
		}

		return xReturn;
    4006:	69bb      	ldr	r3, [r7, #24]
	}
    4008:	0018      	movs	r0, r3
    400a:	46bd      	mov	sp, r7
    400c:	b009      	add	sp, #36	; 0x24
    400e:	bd90      	pop	{r4, r7, pc}
    4010:	0000318d 	.word	0x0000318d
    4014:	0000322d 	.word	0x0000322d
    4018:	00004021 	.word	0x00004021
    401c:	00004131 	.word	0x00004131

00004020 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
    4020:	b580      	push	{r7, lr}
    4022:	b086      	sub	sp, #24
    4024:	af00      	add	r7, sp, #0
    4026:	60f8      	str	r0, [r7, #12]
    4028:	60b9      	str	r1, [r7, #8]
    402a:	607a      	str	r2, [r7, #4]
    402c:	603b      	str	r3, [r7, #0]

	/* Avoid dependency on memset() if it is not required. */
	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
	{
		/* Fill the stack with a known value to assist debugging. */
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
    402e:	6abb      	ldr	r3, [r7, #40]	; 0x28
    4030:	6b18      	ldr	r0, [r3, #48]	; 0x30
    4032:	687b      	ldr	r3, [r7, #4]
    4034:	009b      	lsls	r3, r3, #2
    4036:	001a      	movs	r2, r3
    4038:	21a5      	movs	r1, #165	; 0xa5
    403a:	4b39      	ldr	r3, [pc, #228]	; (4120 <prvInitialiseNewTask+0x100>)
    403c:	4798      	blx	r3
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    403e:	6abb      	ldr	r3, [r7, #40]	; 0x28
    4040:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    4042:	687b      	ldr	r3, [r7, #4]
    4044:	4937      	ldr	r1, [pc, #220]	; (4124 <prvInitialiseNewTask+0x104>)
    4046:	468c      	mov	ip, r1
    4048:	4463      	add	r3, ip
    404a:	009b      	lsls	r3, r3, #2
    404c:	18d3      	adds	r3, r2, r3
    404e:	613b      	str	r3, [r7, #16]
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
    4050:	693b      	ldr	r3, [r7, #16]
    4052:	2207      	movs	r2, #7
    4054:	4393      	bics	r3, r2
    4056:	613b      	str	r3, [r7, #16]

		/* Check the alignment of the calculated top of stack is correct. */
		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
    4058:	693b      	ldr	r3, [r7, #16]
    405a:	2207      	movs	r2, #7
    405c:	4013      	ands	r3, r2
    405e:	d001      	beq.n	4064 <prvInitialiseNewTask+0x44>
    4060:	b672      	cpsid	i
    4062:	e7fe      	b.n	4062 <prvInitialiseNewTask+0x42>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    4064:	2300      	movs	r3, #0
    4066:	617b      	str	r3, [r7, #20]
    4068:	e013      	b.n	4092 <prvInitialiseNewTask+0x72>
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    406a:	68ba      	ldr	r2, [r7, #8]
    406c:	697b      	ldr	r3, [r7, #20]
    406e:	18d3      	adds	r3, r2, r3
    4070:	7818      	ldrb	r0, [r3, #0]
    4072:	6aba      	ldr	r2, [r7, #40]	; 0x28
    4074:	2134      	movs	r1, #52	; 0x34
    4076:	697b      	ldr	r3, [r7, #20]
    4078:	18d3      	adds	r3, r2, r3
    407a:	185b      	adds	r3, r3, r1
    407c:	1c02      	adds	r2, r0, #0
    407e:	701a      	strb	r2, [r3, #0]

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    4080:	68ba      	ldr	r2, [r7, #8]
    4082:	697b      	ldr	r3, [r7, #20]
    4084:	18d3      	adds	r3, r2, r3
    4086:	781b      	ldrb	r3, [r3, #0]
    4088:	2b00      	cmp	r3, #0
    408a:	d006      	beq.n	409a <prvInitialiseNewTask+0x7a>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    408c:	697b      	ldr	r3, [r7, #20]
    408e:	3301      	adds	r3, #1
    4090:	617b      	str	r3, [r7, #20]
    4092:	697b      	ldr	r3, [r7, #20]
    4094:	2b09      	cmp	r3, #9
    4096:	d9e8      	bls.n	406a <prvInitialiseNewTask+0x4a>
    4098:	e000      	b.n	409c <prvInitialiseNewTask+0x7c>
		{
			break;
    409a:	46c0      	nop			; (mov r8, r8)
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    409c:	6abb      	ldr	r3, [r7, #40]	; 0x28
    409e:	223d      	movs	r2, #61	; 0x3d
    40a0:	2100      	movs	r1, #0
    40a2:	5499      	strb	r1, [r3, r2]

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    40a4:	6a3b      	ldr	r3, [r7, #32]
    40a6:	2b04      	cmp	r3, #4
    40a8:	d901      	bls.n	40ae <prvInitialiseNewTask+0x8e>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    40aa:	2304      	movs	r3, #4
    40ac:	623b      	str	r3, [r7, #32]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    40ae:	6abb      	ldr	r3, [r7, #40]	; 0x28
    40b0:	6a3a      	ldr	r2, [r7, #32]
    40b2:	62da      	str	r2, [r3, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
    40b4:	6abb      	ldr	r3, [r7, #40]	; 0x28
    40b6:	6a3a      	ldr	r2, [r7, #32]
    40b8:	649a      	str	r2, [r3, #72]	; 0x48
		pxNewTCB->uxMutexesHeld = 0;
    40ba:	6abb      	ldr	r3, [r7, #40]	; 0x28
    40bc:	2200      	movs	r2, #0
    40be:	64da      	str	r2, [r3, #76]	; 0x4c
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    40c0:	6abb      	ldr	r3, [r7, #40]	; 0x28
    40c2:	3304      	adds	r3, #4
    40c4:	0018      	movs	r0, r3
    40c6:	4b18      	ldr	r3, [pc, #96]	; (4128 <prvInitialiseNewTask+0x108>)
    40c8:	4798      	blx	r3
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    40ca:	6abb      	ldr	r3, [r7, #40]	; 0x28
    40cc:	3318      	adds	r3, #24
    40ce:	0018      	movs	r0, r3
    40d0:	4b15      	ldr	r3, [pc, #84]	; (4128 <prvInitialiseNewTask+0x108>)
    40d2:	4798      	blx	r3

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    40d4:	6abb      	ldr	r3, [r7, #40]	; 0x28
    40d6:	6aba      	ldr	r2, [r7, #40]	; 0x28
    40d8:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    40da:	6a3b      	ldr	r3, [r7, #32]
    40dc:	2205      	movs	r2, #5
    40de:	1ad2      	subs	r2, r2, r3
    40e0:	6abb      	ldr	r3, [r7, #40]	; 0x28
    40e2:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    40e4:	6abb      	ldr	r3, [r7, #40]	; 0x28
    40e6:	6aba      	ldr	r2, [r7, #40]	; 0x28
    40e8:	625a      	str	r2, [r3, #36]	; 0x24
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    40ea:	6abb      	ldr	r3, [r7, #40]	; 0x28
    40ec:	2200      	movs	r2, #0
    40ee:	651a      	str	r2, [r3, #80]	; 0x50
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    40f0:	6abb      	ldr	r3, [r7, #40]	; 0x28
    40f2:	2254      	movs	r2, #84	; 0x54
    40f4:	2100      	movs	r1, #0
    40f6:	5499      	strb	r1, [r3, r2]
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    40f8:	683a      	ldr	r2, [r7, #0]
    40fa:	68f9      	ldr	r1, [r7, #12]
    40fc:	693b      	ldr	r3, [r7, #16]
    40fe:	0018      	movs	r0, r3
    4100:	4b0a      	ldr	r3, [pc, #40]	; (412c <prvInitialiseNewTask+0x10c>)
    4102:	4798      	blx	r3
    4104:	0002      	movs	r2, r0
    4106:	6abb      	ldr	r3, [r7, #40]	; 0x28
    4108:	601a      	str	r2, [r3, #0]
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
    410a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    410c:	2b00      	cmp	r3, #0
    410e:	d002      	beq.n	4116 <prvInitialiseNewTask+0xf6>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    4110:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    4112:	6aba      	ldr	r2, [r7, #40]	; 0x28
    4114:	601a      	str	r2, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    4116:	46c0      	nop			; (mov r8, r8)
    4118:	46bd      	mov	sp, r7
    411a:	b006      	add	sp, #24
    411c:	bd80      	pop	{r7, pc}
    411e:	46c0      	nop			; (mov r8, r8)
    4120:	00006c37 	.word	0x00006c37
    4124:	3fffffff 	.word	0x3fffffff
    4128:	00002e11 	.word	0x00002e11
    412c:	00002f29 	.word	0x00002f29

00004130 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    4130:	b580      	push	{r7, lr}
    4132:	b082      	sub	sp, #8
    4134:	af00      	add	r7, sp, #0
    4136:	6078      	str	r0, [r7, #4]
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    4138:	4b2b      	ldr	r3, [pc, #172]	; (41e8 <prvAddNewTaskToReadyList+0xb8>)
    413a:	4798      	blx	r3
	{
		uxCurrentNumberOfTasks++;
    413c:	4b2b      	ldr	r3, [pc, #172]	; (41ec <prvAddNewTaskToReadyList+0xbc>)
    413e:	681b      	ldr	r3, [r3, #0]
    4140:	1c5a      	adds	r2, r3, #1
    4142:	4b2a      	ldr	r3, [pc, #168]	; (41ec <prvAddNewTaskToReadyList+0xbc>)
    4144:	601a      	str	r2, [r3, #0]
		if( pxCurrentTCB == NULL )
    4146:	4b2a      	ldr	r3, [pc, #168]	; (41f0 <prvAddNewTaskToReadyList+0xc0>)
    4148:	681b      	ldr	r3, [r3, #0]
    414a:	2b00      	cmp	r3, #0
    414c:	d109      	bne.n	4162 <prvAddNewTaskToReadyList+0x32>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    414e:	4b28      	ldr	r3, [pc, #160]	; (41f0 <prvAddNewTaskToReadyList+0xc0>)
    4150:	687a      	ldr	r2, [r7, #4]
    4152:	601a      	str	r2, [r3, #0]

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    4154:	4b25      	ldr	r3, [pc, #148]	; (41ec <prvAddNewTaskToReadyList+0xbc>)
    4156:	681b      	ldr	r3, [r3, #0]
    4158:	2b01      	cmp	r3, #1
    415a:	d110      	bne.n	417e <prvAddNewTaskToReadyList+0x4e>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    415c:	4b25      	ldr	r3, [pc, #148]	; (41f4 <prvAddNewTaskToReadyList+0xc4>)
    415e:	4798      	blx	r3
    4160:	e00d      	b.n	417e <prvAddNewTaskToReadyList+0x4e>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    4162:	4b25      	ldr	r3, [pc, #148]	; (41f8 <prvAddNewTaskToReadyList+0xc8>)
    4164:	681b      	ldr	r3, [r3, #0]
    4166:	2b00      	cmp	r3, #0
    4168:	d109      	bne.n	417e <prvAddNewTaskToReadyList+0x4e>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    416a:	4b21      	ldr	r3, [pc, #132]	; (41f0 <prvAddNewTaskToReadyList+0xc0>)
    416c:	681b      	ldr	r3, [r3, #0]
    416e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4170:	687b      	ldr	r3, [r7, #4]
    4172:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    4174:	429a      	cmp	r2, r3
    4176:	d802      	bhi.n	417e <prvAddNewTaskToReadyList+0x4e>
				{
					pxCurrentTCB = pxNewTCB;
    4178:	4b1d      	ldr	r3, [pc, #116]	; (41f0 <prvAddNewTaskToReadyList+0xc0>)
    417a:	687a      	ldr	r2, [r7, #4]
    417c:	601a      	str	r2, [r3, #0]
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    417e:	4b1f      	ldr	r3, [pc, #124]	; (41fc <prvAddNewTaskToReadyList+0xcc>)
    4180:	681b      	ldr	r3, [r3, #0]
    4182:	1c5a      	adds	r2, r3, #1
    4184:	4b1d      	ldr	r3, [pc, #116]	; (41fc <prvAddNewTaskToReadyList+0xcc>)
    4186:	601a      	str	r2, [r3, #0]

		#if ( configUSE_TRACE_FACILITY == 1 )
		{
			/* Add a counter into the TCB for tracing only. */
			pxNewTCB->uxTCBNumber = uxTaskNumber;
    4188:	4b1c      	ldr	r3, [pc, #112]	; (41fc <prvAddNewTaskToReadyList+0xcc>)
    418a:	681a      	ldr	r2, [r3, #0]
    418c:	687b      	ldr	r3, [r7, #4]
    418e:	641a      	str	r2, [r3, #64]	; 0x40
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    4190:	687b      	ldr	r3, [r7, #4]
    4192:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4194:	4b1a      	ldr	r3, [pc, #104]	; (4200 <prvAddNewTaskToReadyList+0xd0>)
    4196:	681b      	ldr	r3, [r3, #0]
    4198:	429a      	cmp	r2, r3
    419a:	d903      	bls.n	41a4 <prvAddNewTaskToReadyList+0x74>
    419c:	687b      	ldr	r3, [r7, #4]
    419e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    41a0:	4b17      	ldr	r3, [pc, #92]	; (4200 <prvAddNewTaskToReadyList+0xd0>)
    41a2:	601a      	str	r2, [r3, #0]
    41a4:	687b      	ldr	r3, [r7, #4]
    41a6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    41a8:	0013      	movs	r3, r2
    41aa:	009b      	lsls	r3, r3, #2
    41ac:	189b      	adds	r3, r3, r2
    41ae:	009b      	lsls	r3, r3, #2
    41b0:	4a14      	ldr	r2, [pc, #80]	; (4204 <prvAddNewTaskToReadyList+0xd4>)
    41b2:	189a      	adds	r2, r3, r2
    41b4:	687b      	ldr	r3, [r7, #4]
    41b6:	3304      	adds	r3, #4
    41b8:	0019      	movs	r1, r3
    41ba:	0010      	movs	r0, r2
    41bc:	4b12      	ldr	r3, [pc, #72]	; (4208 <prvAddNewTaskToReadyList+0xd8>)
    41be:	4798      	blx	r3

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    41c0:	4b12      	ldr	r3, [pc, #72]	; (420c <prvAddNewTaskToReadyList+0xdc>)
    41c2:	4798      	blx	r3

	if( xSchedulerRunning != pdFALSE )
    41c4:	4b0c      	ldr	r3, [pc, #48]	; (41f8 <prvAddNewTaskToReadyList+0xc8>)
    41c6:	681b      	ldr	r3, [r3, #0]
    41c8:	2b00      	cmp	r3, #0
    41ca:	d008      	beq.n	41de <prvAddNewTaskToReadyList+0xae>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    41cc:	4b08      	ldr	r3, [pc, #32]	; (41f0 <prvAddNewTaskToReadyList+0xc0>)
    41ce:	681b      	ldr	r3, [r3, #0]
    41d0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    41d2:	687b      	ldr	r3, [r7, #4]
    41d4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    41d6:	429a      	cmp	r2, r3
    41d8:	d201      	bcs.n	41de <prvAddNewTaskToReadyList+0xae>
		{
			taskYIELD_IF_USING_PREEMPTION();
    41da:	4b0d      	ldr	r3, [pc, #52]	; (4210 <prvAddNewTaskToReadyList+0xe0>)
    41dc:	4798      	blx	r3
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    41de:	46c0      	nop			; (mov r8, r8)
    41e0:	46bd      	mov	sp, r7
    41e2:	b002      	add	sp, #8
    41e4:	bd80      	pop	{r7, pc}
    41e6:	46c0      	nop			; (mov r8, r8)
    41e8:	00003061 	.word	0x00003061
    41ec:	20003270 	.word	0x20003270
    41f0:	20003198 	.word	0x20003198
    41f4:	00004945 	.word	0x00004945
    41f8:	2000327c 	.word	0x2000327c
    41fc:	2000328c 	.word	0x2000328c
    4200:	20003278 	.word	0x20003278
    4204:	2000319c 	.word	0x2000319c
    4208:	00002e27 	.word	0x00002e27
    420c:	00003085 	.word	0x00003085
    4210:	00003041 	.word	0x00003041

00004214 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    4214:	b580      	push	{r7, lr}
    4216:	b084      	sub	sp, #16
    4218:	af00      	add	r7, sp, #0
    421a:	6078      	str	r0, [r7, #4]
	BaseType_t xAlreadyYielded = pdFALSE;
    421c:	2300      	movs	r3, #0
    421e:	60fb      	str	r3, [r7, #12]

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    4220:	687b      	ldr	r3, [r7, #4]
    4222:	2b00      	cmp	r3, #0
    4224:	d010      	beq.n	4248 <vTaskDelay+0x34>
		{
			configASSERT( uxSchedulerSuspended == 0 );
    4226:	4b0d      	ldr	r3, [pc, #52]	; (425c <vTaskDelay+0x48>)
    4228:	681b      	ldr	r3, [r3, #0]
    422a:	2b00      	cmp	r3, #0
    422c:	d001      	beq.n	4232 <vTaskDelay+0x1e>
    422e:	b672      	cpsid	i
    4230:	e7fe      	b.n	4230 <vTaskDelay+0x1c>
			vTaskSuspendAll();
    4232:	4b0b      	ldr	r3, [pc, #44]	; (4260 <vTaskDelay+0x4c>)
    4234:	4798      	blx	r3
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    4236:	687b      	ldr	r3, [r7, #4]
    4238:	2100      	movs	r1, #0
    423a:	0018      	movs	r0, r3
    423c:	4b09      	ldr	r3, [pc, #36]	; (4264 <vTaskDelay+0x50>)
    423e:	4798      	blx	r3
			}
			xAlreadyYielded = xTaskResumeAll();
    4240:	4b09      	ldr	r3, [pc, #36]	; (4268 <vTaskDelay+0x54>)
    4242:	4798      	blx	r3
    4244:	0003      	movs	r3, r0
    4246:	60fb      	str	r3, [r7, #12]
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    4248:	68fb      	ldr	r3, [r7, #12]
    424a:	2b00      	cmp	r3, #0
    424c:	d101      	bne.n	4252 <vTaskDelay+0x3e>
		{
			portYIELD_WITHIN_API();
    424e:	4b07      	ldr	r3, [pc, #28]	; (426c <vTaskDelay+0x58>)
    4250:	4798      	blx	r3
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    4252:	46c0      	nop			; (mov r8, r8)
    4254:	46bd      	mov	sp, r7
    4256:	b004      	add	sp, #16
    4258:	bd80      	pop	{r7, pc}
    425a:	46c0      	nop			; (mov r8, r8)
    425c:	20003298 	.word	0x20003298
    4260:	000042f5 	.word	0x000042f5
    4264:	00004f35 	.word	0x00004f35
    4268:	0000430d 	.word	0x0000430d
    426c:	00003041 	.word	0x00003041

00004270 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    4270:	b590      	push	{r4, r7, lr}
    4272:	b085      	sub	sp, #20
    4274:	af02      	add	r7, sp, #8
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    4276:	4916      	ldr	r1, [pc, #88]	; (42d0 <vTaskStartScheduler+0x60>)
    4278:	4816      	ldr	r0, [pc, #88]	; (42d4 <vTaskStartScheduler+0x64>)
    427a:	4b17      	ldr	r3, [pc, #92]	; (42d8 <vTaskStartScheduler+0x68>)
    427c:	9301      	str	r3, [sp, #4]
    427e:	2300      	movs	r3, #0
    4280:	9300      	str	r3, [sp, #0]
    4282:	2300      	movs	r3, #0
    4284:	2282      	movs	r2, #130	; 0x82
    4286:	4c15      	ldr	r4, [pc, #84]	; (42dc <vTaskStartScheduler+0x6c>)
    4288:	47a0      	blx	r4
    428a:	0003      	movs	r3, r0
    428c:	607b      	str	r3, [r7, #4]
	}
	#endif /* configSUPPORT_STATIC_ALLOCATION */

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
    428e:	687b      	ldr	r3, [r7, #4]
    4290:	2b01      	cmp	r3, #1
    4292:	d103      	bne.n	429c <vTaskStartScheduler+0x2c>
		{
			xReturn = xTimerCreateTimerTask();
    4294:	4b12      	ldr	r3, [pc, #72]	; (42e0 <vTaskStartScheduler+0x70>)
    4296:	4798      	blx	r3
    4298:	0003      	movs	r3, r0
    429a:	607b      	str	r3, [r7, #4]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    429c:	687b      	ldr	r3, [r7, #4]
    429e:	2b01      	cmp	r3, #1
    42a0:	d10d      	bne.n	42be <vTaskStartScheduler+0x4e>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    42a2:	b672      	cpsid	i
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    42a4:	4b0f      	ldr	r3, [pc, #60]	; (42e4 <vTaskStartScheduler+0x74>)
    42a6:	2201      	movs	r2, #1
    42a8:	4252      	negs	r2, r2
    42aa:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
    42ac:	4b0e      	ldr	r3, [pc, #56]	; (42e8 <vTaskStartScheduler+0x78>)
    42ae:	2201      	movs	r2, #1
    42b0:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
    42b2:	4b0e      	ldr	r3, [pc, #56]	; (42ec <vTaskStartScheduler+0x7c>)
    42b4:	2200      	movs	r2, #0
    42b6:	601a      	str	r2, [r3, #0]
		FreeRTOSConfig.h file. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    42b8:	4b0d      	ldr	r3, [pc, #52]	; (42f0 <vTaskStartScheduler+0x80>)
    42ba:	4798      	blx	r3
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    42bc:	e004      	b.n	42c8 <vTaskStartScheduler+0x58>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
    42be:	687b      	ldr	r3, [r7, #4]
    42c0:	3301      	adds	r3, #1
    42c2:	d101      	bne.n	42c8 <vTaskStartScheduler+0x58>
    42c4:	b672      	cpsid	i
    42c6:	e7fe      	b.n	42c6 <vTaskStartScheduler+0x56>
}
    42c8:	46c0      	nop			; (mov r8, r8)
    42ca:	46bd      	mov	sp, r7
    42cc:	b003      	add	sp, #12
    42ce:	bd90      	pop	{r4, r7, pc}
    42d0:	00007340 	.word	0x00007340
    42d4:	0000491d 	.word	0x0000491d
    42d8:	20003294 	.word	0x20003294
    42dc:	00003f81 	.word	0x00003f81
    42e0:	00004fe9 	.word	0x00004fe9
    42e4:	20003290 	.word	0x20003290
    42e8:	2000327c 	.word	0x2000327c
    42ec:	20003274 	.word	0x20003274
    42f0:	00002fe9 	.word	0x00002fe9

000042f4 <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    42f4:	b580      	push	{r7, lr}
    42f6:	af00      	add	r7, sp, #0
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    42f8:	4b03      	ldr	r3, [pc, #12]	; (4308 <vTaskSuspendAll+0x14>)
    42fa:	681b      	ldr	r3, [r3, #0]
    42fc:	1c5a      	adds	r2, r3, #1
    42fe:	4b02      	ldr	r3, [pc, #8]	; (4308 <vTaskSuspendAll+0x14>)
    4300:	601a      	str	r2, [r3, #0]
}
    4302:	46c0      	nop			; (mov r8, r8)
    4304:	46bd      	mov	sp, r7
    4306:	bd80      	pop	{r7, pc}
    4308:	20003298 	.word	0x20003298

0000430c <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    430c:	b580      	push	{r7, lr}
    430e:	b084      	sub	sp, #16
    4310:	af00      	add	r7, sp, #0
TCB_t *pxTCB = NULL;
    4312:	2300      	movs	r3, #0
    4314:	60fb      	str	r3, [r7, #12]
BaseType_t xAlreadyYielded = pdFALSE;
    4316:	2300      	movs	r3, #0
    4318:	60bb      	str	r3, [r7, #8]

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
    431a:	4b3a      	ldr	r3, [pc, #232]	; (4404 <xTaskResumeAll+0xf8>)
    431c:	681b      	ldr	r3, [r3, #0]
    431e:	2b00      	cmp	r3, #0
    4320:	d101      	bne.n	4326 <xTaskResumeAll+0x1a>
    4322:	b672      	cpsid	i
    4324:	e7fe      	b.n	4324 <xTaskResumeAll+0x18>
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    4326:	4b38      	ldr	r3, [pc, #224]	; (4408 <xTaskResumeAll+0xfc>)
    4328:	4798      	blx	r3
	{
		--uxSchedulerSuspended;
    432a:	4b36      	ldr	r3, [pc, #216]	; (4404 <xTaskResumeAll+0xf8>)
    432c:	681b      	ldr	r3, [r3, #0]
    432e:	1e5a      	subs	r2, r3, #1
    4330:	4b34      	ldr	r3, [pc, #208]	; (4404 <xTaskResumeAll+0xf8>)
    4332:	601a      	str	r2, [r3, #0]

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4334:	4b33      	ldr	r3, [pc, #204]	; (4404 <xTaskResumeAll+0xf8>)
    4336:	681b      	ldr	r3, [r3, #0]
    4338:	2b00      	cmp	r3, #0
    433a:	d15b      	bne.n	43f4 <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    433c:	4b33      	ldr	r3, [pc, #204]	; (440c <xTaskResumeAll+0x100>)
    433e:	681b      	ldr	r3, [r3, #0]
    4340:	2b00      	cmp	r3, #0
    4342:	d057      	beq.n	43f4 <xTaskResumeAll+0xe8>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    4344:	e02f      	b.n	43a6 <xTaskResumeAll+0x9a>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    4346:	4b32      	ldr	r3, [pc, #200]	; (4410 <xTaskResumeAll+0x104>)
    4348:	68db      	ldr	r3, [r3, #12]
    434a:	68db      	ldr	r3, [r3, #12]
    434c:	60fb      	str	r3, [r7, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    434e:	68fb      	ldr	r3, [r7, #12]
    4350:	3318      	adds	r3, #24
    4352:	0018      	movs	r0, r3
    4354:	4b2f      	ldr	r3, [pc, #188]	; (4414 <xTaskResumeAll+0x108>)
    4356:	4798      	blx	r3
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4358:	68fb      	ldr	r3, [r7, #12]
    435a:	3304      	adds	r3, #4
    435c:	0018      	movs	r0, r3
    435e:	4b2d      	ldr	r3, [pc, #180]	; (4414 <xTaskResumeAll+0x108>)
    4360:	4798      	blx	r3
					prvAddTaskToReadyList( pxTCB );
    4362:	68fb      	ldr	r3, [r7, #12]
    4364:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4366:	4b2c      	ldr	r3, [pc, #176]	; (4418 <xTaskResumeAll+0x10c>)
    4368:	681b      	ldr	r3, [r3, #0]
    436a:	429a      	cmp	r2, r3
    436c:	d903      	bls.n	4376 <xTaskResumeAll+0x6a>
    436e:	68fb      	ldr	r3, [r7, #12]
    4370:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4372:	4b29      	ldr	r3, [pc, #164]	; (4418 <xTaskResumeAll+0x10c>)
    4374:	601a      	str	r2, [r3, #0]
    4376:	68fb      	ldr	r3, [r7, #12]
    4378:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    437a:	0013      	movs	r3, r2
    437c:	009b      	lsls	r3, r3, #2
    437e:	189b      	adds	r3, r3, r2
    4380:	009b      	lsls	r3, r3, #2
    4382:	4a26      	ldr	r2, [pc, #152]	; (441c <xTaskResumeAll+0x110>)
    4384:	189a      	adds	r2, r3, r2
    4386:	68fb      	ldr	r3, [r7, #12]
    4388:	3304      	adds	r3, #4
    438a:	0019      	movs	r1, r3
    438c:	0010      	movs	r0, r2
    438e:	4b24      	ldr	r3, [pc, #144]	; (4420 <xTaskResumeAll+0x114>)
    4390:	4798      	blx	r3

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4392:	68fb      	ldr	r3, [r7, #12]
    4394:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4396:	4b23      	ldr	r3, [pc, #140]	; (4424 <xTaskResumeAll+0x118>)
    4398:	681b      	ldr	r3, [r3, #0]
    439a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    439c:	429a      	cmp	r2, r3
    439e:	d302      	bcc.n	43a6 <xTaskResumeAll+0x9a>
					{
						xYieldPending = pdTRUE;
    43a0:	4b21      	ldr	r3, [pc, #132]	; (4428 <xTaskResumeAll+0x11c>)
    43a2:	2201      	movs	r2, #1
    43a4:	601a      	str	r2, [r3, #0]
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    43a6:	4b1a      	ldr	r3, [pc, #104]	; (4410 <xTaskResumeAll+0x104>)
    43a8:	681b      	ldr	r3, [r3, #0]
    43aa:	2b00      	cmp	r3, #0
    43ac:	d1cb      	bne.n	4346 <xTaskResumeAll+0x3a>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    43ae:	68fb      	ldr	r3, [r7, #12]
    43b0:	2b00      	cmp	r3, #0
    43b2:	d001      	beq.n	43b8 <xTaskResumeAll+0xac>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    43b4:	4b1d      	ldr	r3, [pc, #116]	; (442c <xTaskResumeAll+0x120>)
    43b6:	4798      	blx	r3
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    43b8:	4b1d      	ldr	r3, [pc, #116]	; (4430 <xTaskResumeAll+0x124>)
    43ba:	681b      	ldr	r3, [r3, #0]
    43bc:	607b      	str	r3, [r7, #4]

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    43be:	687b      	ldr	r3, [r7, #4]
    43c0:	2b00      	cmp	r3, #0
    43c2:	d00f      	beq.n	43e4 <xTaskResumeAll+0xd8>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    43c4:	4b1b      	ldr	r3, [pc, #108]	; (4434 <xTaskResumeAll+0x128>)
    43c6:	4798      	blx	r3
    43c8:	1e03      	subs	r3, r0, #0
    43ca:	d002      	beq.n	43d2 <xTaskResumeAll+0xc6>
							{
								xYieldPending = pdTRUE;
    43cc:	4b16      	ldr	r3, [pc, #88]	; (4428 <xTaskResumeAll+0x11c>)
    43ce:	2201      	movs	r2, #1
    43d0:	601a      	str	r2, [r3, #0]
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    43d2:	687b      	ldr	r3, [r7, #4]
    43d4:	3b01      	subs	r3, #1
    43d6:	607b      	str	r3, [r7, #4]
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    43d8:	687b      	ldr	r3, [r7, #4]
    43da:	2b00      	cmp	r3, #0
    43dc:	d1f2      	bne.n	43c4 <xTaskResumeAll+0xb8>

						uxPendedTicks = 0;
    43de:	4b14      	ldr	r3, [pc, #80]	; (4430 <xTaskResumeAll+0x124>)
    43e0:	2200      	movs	r2, #0
    43e2:	601a      	str	r2, [r3, #0]
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    43e4:	4b10      	ldr	r3, [pc, #64]	; (4428 <xTaskResumeAll+0x11c>)
    43e6:	681b      	ldr	r3, [r3, #0]
    43e8:	2b00      	cmp	r3, #0
    43ea:	d003      	beq.n	43f4 <xTaskResumeAll+0xe8>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    43ec:	2301      	movs	r3, #1
    43ee:	60bb      	str	r3, [r7, #8]
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    43f0:	4b11      	ldr	r3, [pc, #68]	; (4438 <xTaskResumeAll+0x12c>)
    43f2:	4798      	blx	r3
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    43f4:	4b11      	ldr	r3, [pc, #68]	; (443c <xTaskResumeAll+0x130>)
    43f6:	4798      	blx	r3

	return xAlreadyYielded;
    43f8:	68bb      	ldr	r3, [r7, #8]
}
    43fa:	0018      	movs	r0, r3
    43fc:	46bd      	mov	sp, r7
    43fe:	b004      	add	sp, #16
    4400:	bd80      	pop	{r7, pc}
    4402:	46c0      	nop			; (mov r8, r8)
    4404:	20003298 	.word	0x20003298
    4408:	00003061 	.word	0x00003061
    440c:	20003270 	.word	0x20003270
    4410:	20003230 	.word	0x20003230
    4414:	00002ed7 	.word	0x00002ed7
    4418:	20003278 	.word	0x20003278
    441c:	2000319c 	.word	0x2000319c
    4420:	00002e27 	.word	0x00002e27
    4424:	20003198 	.word	0x20003198
    4428:	20003284 	.word	0x20003284
    442c:	00004a65 	.word	0x00004a65
    4430:	20003280 	.word	0x20003280
    4434:	0000445d 	.word	0x0000445d
    4438:	00003041 	.word	0x00003041
    443c:	00003085 	.word	0x00003085

00004440 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    4440:	b580      	push	{r7, lr}
    4442:	b082      	sub	sp, #8
    4444:	af00      	add	r7, sp, #0
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
	{
		xTicks = xTickCount;
    4446:	4b04      	ldr	r3, [pc, #16]	; (4458 <xTaskGetTickCount+0x18>)
    4448:	681b      	ldr	r3, [r3, #0]
    444a:	607b      	str	r3, [r7, #4]
	}
	portTICK_TYPE_EXIT_CRITICAL();

	return xTicks;
    444c:	687b      	ldr	r3, [r7, #4]
}
    444e:	0018      	movs	r0, r3
    4450:	46bd      	mov	sp, r7
    4452:	b002      	add	sp, #8
    4454:	bd80      	pop	{r7, pc}
    4456:	46c0      	nop			; (mov r8, r8)
    4458:	20003274 	.word	0x20003274

0000445c <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    445c:	b580      	push	{r7, lr}
    445e:	b086      	sub	sp, #24
    4460:	af00      	add	r7, sp, #0
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    4462:	2300      	movs	r3, #0
    4464:	617b      	str	r3, [r7, #20]

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4466:	4b50      	ldr	r3, [pc, #320]	; (45a8 <xTaskIncrementTick+0x14c>)
    4468:	681b      	ldr	r3, [r3, #0]
    446a:	2b00      	cmp	r3, #0
    446c:	d000      	beq.n	4470 <xTaskIncrementTick+0x14>
    446e:	e089      	b.n	4584 <xTaskIncrementTick+0x128>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    4470:	4b4e      	ldr	r3, [pc, #312]	; (45ac <xTaskIncrementTick+0x150>)
    4472:	681b      	ldr	r3, [r3, #0]
    4474:	3301      	adds	r3, #1
    4476:	613b      	str	r3, [r7, #16]

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    4478:	4b4c      	ldr	r3, [pc, #304]	; (45ac <xTaskIncrementTick+0x150>)
    447a:	693a      	ldr	r2, [r7, #16]
    447c:	601a      	str	r2, [r3, #0]

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    447e:	693b      	ldr	r3, [r7, #16]
    4480:	2b00      	cmp	r3, #0
    4482:	d117      	bne.n	44b4 <xTaskIncrementTick+0x58>
		{
			taskSWITCH_DELAYED_LISTS();
    4484:	4b4a      	ldr	r3, [pc, #296]	; (45b0 <xTaskIncrementTick+0x154>)
    4486:	681b      	ldr	r3, [r3, #0]
    4488:	681b      	ldr	r3, [r3, #0]
    448a:	2b00      	cmp	r3, #0
    448c:	d001      	beq.n	4492 <xTaskIncrementTick+0x36>
    448e:	b672      	cpsid	i
    4490:	e7fe      	b.n	4490 <xTaskIncrementTick+0x34>
    4492:	4b47      	ldr	r3, [pc, #284]	; (45b0 <xTaskIncrementTick+0x154>)
    4494:	681b      	ldr	r3, [r3, #0]
    4496:	60fb      	str	r3, [r7, #12]
    4498:	4b46      	ldr	r3, [pc, #280]	; (45b4 <xTaskIncrementTick+0x158>)
    449a:	681a      	ldr	r2, [r3, #0]
    449c:	4b44      	ldr	r3, [pc, #272]	; (45b0 <xTaskIncrementTick+0x154>)
    449e:	601a      	str	r2, [r3, #0]
    44a0:	4b44      	ldr	r3, [pc, #272]	; (45b4 <xTaskIncrementTick+0x158>)
    44a2:	68fa      	ldr	r2, [r7, #12]
    44a4:	601a      	str	r2, [r3, #0]
    44a6:	4b44      	ldr	r3, [pc, #272]	; (45b8 <xTaskIncrementTick+0x15c>)
    44a8:	681b      	ldr	r3, [r3, #0]
    44aa:	1c5a      	adds	r2, r3, #1
    44ac:	4b42      	ldr	r3, [pc, #264]	; (45b8 <xTaskIncrementTick+0x15c>)
    44ae:	601a      	str	r2, [r3, #0]
    44b0:	4b42      	ldr	r3, [pc, #264]	; (45bc <xTaskIncrementTick+0x160>)
    44b2:	4798      	blx	r3

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    44b4:	4b42      	ldr	r3, [pc, #264]	; (45c0 <xTaskIncrementTick+0x164>)
    44b6:	681b      	ldr	r3, [r3, #0]
    44b8:	693a      	ldr	r2, [r7, #16]
    44ba:	429a      	cmp	r2, r3
    44bc:	d34e      	bcc.n	455c <xTaskIncrementTick+0x100>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    44be:	4b3c      	ldr	r3, [pc, #240]	; (45b0 <xTaskIncrementTick+0x154>)
    44c0:	681b      	ldr	r3, [r3, #0]
    44c2:	681b      	ldr	r3, [r3, #0]
    44c4:	2b00      	cmp	r3, #0
    44c6:	d101      	bne.n	44cc <xTaskIncrementTick+0x70>
    44c8:	2301      	movs	r3, #1
    44ca:	e000      	b.n	44ce <xTaskIncrementTick+0x72>
    44cc:	2300      	movs	r3, #0
    44ce:	2b00      	cmp	r3, #0
    44d0:	d004      	beq.n	44dc <xTaskIncrementTick+0x80>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    44d2:	4b3b      	ldr	r3, [pc, #236]	; (45c0 <xTaskIncrementTick+0x164>)
    44d4:	2201      	movs	r2, #1
    44d6:	4252      	negs	r2, r2
    44d8:	601a      	str	r2, [r3, #0]
					break;
    44da:	e03f      	b.n	455c <xTaskIncrementTick+0x100>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    44dc:	4b34      	ldr	r3, [pc, #208]	; (45b0 <xTaskIncrementTick+0x154>)
    44de:	681b      	ldr	r3, [r3, #0]
    44e0:	68db      	ldr	r3, [r3, #12]
    44e2:	68db      	ldr	r3, [r3, #12]
    44e4:	60bb      	str	r3, [r7, #8]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    44e6:	68bb      	ldr	r3, [r7, #8]
    44e8:	685b      	ldr	r3, [r3, #4]
    44ea:	607b      	str	r3, [r7, #4]

					if( xConstTickCount < xItemValue )
    44ec:	693a      	ldr	r2, [r7, #16]
    44ee:	687b      	ldr	r3, [r7, #4]
    44f0:	429a      	cmp	r2, r3
    44f2:	d203      	bcs.n	44fc <xTaskIncrementTick+0xa0>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    44f4:	4b32      	ldr	r3, [pc, #200]	; (45c0 <xTaskIncrementTick+0x164>)
    44f6:	687a      	ldr	r2, [r7, #4]
    44f8:	601a      	str	r2, [r3, #0]
						break;
    44fa:	e02f      	b.n	455c <xTaskIncrementTick+0x100>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    44fc:	68bb      	ldr	r3, [r7, #8]
    44fe:	3304      	adds	r3, #4
    4500:	0018      	movs	r0, r3
    4502:	4b30      	ldr	r3, [pc, #192]	; (45c4 <xTaskIncrementTick+0x168>)
    4504:	4798      	blx	r3

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    4506:	68bb      	ldr	r3, [r7, #8]
    4508:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    450a:	2b00      	cmp	r3, #0
    450c:	d004      	beq.n	4518 <xTaskIncrementTick+0xbc>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    450e:	68bb      	ldr	r3, [r7, #8]
    4510:	3318      	adds	r3, #24
    4512:	0018      	movs	r0, r3
    4514:	4b2b      	ldr	r3, [pc, #172]	; (45c4 <xTaskIncrementTick+0x168>)
    4516:	4798      	blx	r3
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    4518:	68bb      	ldr	r3, [r7, #8]
    451a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    451c:	4b2a      	ldr	r3, [pc, #168]	; (45c8 <xTaskIncrementTick+0x16c>)
    451e:	681b      	ldr	r3, [r3, #0]
    4520:	429a      	cmp	r2, r3
    4522:	d903      	bls.n	452c <xTaskIncrementTick+0xd0>
    4524:	68bb      	ldr	r3, [r7, #8]
    4526:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4528:	4b27      	ldr	r3, [pc, #156]	; (45c8 <xTaskIncrementTick+0x16c>)
    452a:	601a      	str	r2, [r3, #0]
    452c:	68bb      	ldr	r3, [r7, #8]
    452e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4530:	0013      	movs	r3, r2
    4532:	009b      	lsls	r3, r3, #2
    4534:	189b      	adds	r3, r3, r2
    4536:	009b      	lsls	r3, r3, #2
    4538:	4a24      	ldr	r2, [pc, #144]	; (45cc <xTaskIncrementTick+0x170>)
    453a:	189a      	adds	r2, r3, r2
    453c:	68bb      	ldr	r3, [r7, #8]
    453e:	3304      	adds	r3, #4
    4540:	0019      	movs	r1, r3
    4542:	0010      	movs	r0, r2
    4544:	4b22      	ldr	r3, [pc, #136]	; (45d0 <xTaskIncrementTick+0x174>)
    4546:	4798      	blx	r3
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4548:	68bb      	ldr	r3, [r7, #8]
    454a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    454c:	4b21      	ldr	r3, [pc, #132]	; (45d4 <xTaskIncrementTick+0x178>)
    454e:	681b      	ldr	r3, [r3, #0]
    4550:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    4552:	429a      	cmp	r2, r3
    4554:	d3b3      	bcc.n	44be <xTaskIncrementTick+0x62>
						{
							xSwitchRequired = pdTRUE;
    4556:	2301      	movs	r3, #1
    4558:	617b      	str	r3, [r7, #20]
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    455a:	e7b0      	b.n	44be <xTaskIncrementTick+0x62>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    455c:	4b1d      	ldr	r3, [pc, #116]	; (45d4 <xTaskIncrementTick+0x178>)
    455e:	681b      	ldr	r3, [r3, #0]
    4560:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4562:	491a      	ldr	r1, [pc, #104]	; (45cc <xTaskIncrementTick+0x170>)
    4564:	0013      	movs	r3, r2
    4566:	009b      	lsls	r3, r3, #2
    4568:	189b      	adds	r3, r3, r2
    456a:	009b      	lsls	r3, r3, #2
    456c:	585b      	ldr	r3, [r3, r1]
    456e:	2b01      	cmp	r3, #1
    4570:	d901      	bls.n	4576 <xTaskIncrementTick+0x11a>
			{
				xSwitchRequired = pdTRUE;
    4572:	2301      	movs	r3, #1
    4574:	617b      	str	r3, [r7, #20]

		#if ( configUSE_TICK_HOOK == 1 )
		{
			/* Guard against the tick hook being called when the pended tick
			count is being unwound (when the scheduler is being unlocked). */
			if( uxPendedTicks == ( UBaseType_t ) 0U )
    4576:	4b18      	ldr	r3, [pc, #96]	; (45d8 <xTaskIncrementTick+0x17c>)
    4578:	681b      	ldr	r3, [r3, #0]
    457a:	2b00      	cmp	r3, #0
    457c:	d109      	bne.n	4592 <xTaskIncrementTick+0x136>
			{
				vApplicationTickHook();
    457e:	4b17      	ldr	r3, [pc, #92]	; (45dc <xTaskIncrementTick+0x180>)
    4580:	4798      	blx	r3
    4582:	e006      	b.n	4592 <xTaskIncrementTick+0x136>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    4584:	4b14      	ldr	r3, [pc, #80]	; (45d8 <xTaskIncrementTick+0x17c>)
    4586:	681b      	ldr	r3, [r3, #0]
    4588:	1c5a      	adds	r2, r3, #1
    458a:	4b13      	ldr	r3, [pc, #76]	; (45d8 <xTaskIncrementTick+0x17c>)
    458c:	601a      	str	r2, [r3, #0]

		/* The tick hook gets called at regular intervals, even if the
		scheduler is locked. */
		#if ( configUSE_TICK_HOOK == 1 )
		{
			vApplicationTickHook();
    458e:	4b13      	ldr	r3, [pc, #76]	; (45dc <xTaskIncrementTick+0x180>)
    4590:	4798      	blx	r3
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    4592:	4b13      	ldr	r3, [pc, #76]	; (45e0 <xTaskIncrementTick+0x184>)
    4594:	681b      	ldr	r3, [r3, #0]
    4596:	2b00      	cmp	r3, #0
    4598:	d001      	beq.n	459e <xTaskIncrementTick+0x142>
		{
			xSwitchRequired = pdTRUE;
    459a:	2301      	movs	r3, #1
    459c:	617b      	str	r3, [r7, #20]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    459e:	697b      	ldr	r3, [r7, #20]
}
    45a0:	0018      	movs	r0, r3
    45a2:	46bd      	mov	sp, r7
    45a4:	b006      	add	sp, #24
    45a6:	bd80      	pop	{r7, pc}
    45a8:	20003298 	.word	0x20003298
    45ac:	20003274 	.word	0x20003274
    45b0:	20003228 	.word	0x20003228
    45b4:	2000322c 	.word	0x2000322c
    45b8:	20003288 	.word	0x20003288
    45bc:	00004a65 	.word	0x00004a65
    45c0:	20003290 	.word	0x20003290
    45c4:	00002ed7 	.word	0x00002ed7
    45c8:	20003278 	.word	0x20003278
    45cc:	2000319c 	.word	0x2000319c
    45d0:	00002e27 	.word	0x00002e27
    45d4:	20003198 	.word	0x20003198
    45d8:	20003280 	.word	0x20003280
    45dc:	000060a5 	.word	0x000060a5
    45e0:	20003284 	.word	0x20003284

000045e4 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    45e4:	b580      	push	{r7, lr}
    45e6:	b084      	sub	sp, #16
    45e8:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    45ea:	4b35      	ldr	r3, [pc, #212]	; (46c0 <vTaskSwitchContext+0xdc>)
    45ec:	681b      	ldr	r3, [r3, #0]
    45ee:	2b00      	cmp	r3, #0
    45f0:	d003      	beq.n	45fa <vTaskSwitchContext+0x16>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    45f2:	4b34      	ldr	r3, [pc, #208]	; (46c4 <vTaskSwitchContext+0xe0>)
    45f4:	2201      	movs	r2, #1
    45f6:	601a      	str	r2, [r3, #0]
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    45f8:	e05d      	b.n	46b6 <vTaskSwitchContext+0xd2>
		xYieldPending = pdFALSE;
    45fa:	4b32      	ldr	r3, [pc, #200]	; (46c4 <vTaskSwitchContext+0xe0>)
    45fc:	2200      	movs	r2, #0
    45fe:	601a      	str	r2, [r3, #0]
		taskCHECK_FOR_STACK_OVERFLOW();
    4600:	4b31      	ldr	r3, [pc, #196]	; (46c8 <vTaskSwitchContext+0xe4>)
    4602:	681b      	ldr	r3, [r3, #0]
    4604:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    4606:	60bb      	str	r3, [r7, #8]
    4608:	4b30      	ldr	r3, [pc, #192]	; (46cc <vTaskSwitchContext+0xe8>)
    460a:	607b      	str	r3, [r7, #4]
    460c:	68bb      	ldr	r3, [r7, #8]
    460e:	681a      	ldr	r2, [r3, #0]
    4610:	687b      	ldr	r3, [r7, #4]
    4612:	429a      	cmp	r2, r3
    4614:	d111      	bne.n	463a <vTaskSwitchContext+0x56>
    4616:	68bb      	ldr	r3, [r7, #8]
    4618:	3304      	adds	r3, #4
    461a:	681a      	ldr	r2, [r3, #0]
    461c:	687b      	ldr	r3, [r7, #4]
    461e:	429a      	cmp	r2, r3
    4620:	d10b      	bne.n	463a <vTaskSwitchContext+0x56>
    4622:	68bb      	ldr	r3, [r7, #8]
    4624:	3308      	adds	r3, #8
    4626:	681a      	ldr	r2, [r3, #0]
    4628:	687b      	ldr	r3, [r7, #4]
    462a:	429a      	cmp	r2, r3
    462c:	d105      	bne.n	463a <vTaskSwitchContext+0x56>
    462e:	68bb      	ldr	r3, [r7, #8]
    4630:	330c      	adds	r3, #12
    4632:	681a      	ldr	r2, [r3, #0]
    4634:	687b      	ldr	r3, [r7, #4]
    4636:	429a      	cmp	r2, r3
    4638:	d008      	beq.n	464c <vTaskSwitchContext+0x68>
    463a:	4b23      	ldr	r3, [pc, #140]	; (46c8 <vTaskSwitchContext+0xe4>)
    463c:	681a      	ldr	r2, [r3, #0]
    463e:	4b22      	ldr	r3, [pc, #136]	; (46c8 <vTaskSwitchContext+0xe4>)
    4640:	681b      	ldr	r3, [r3, #0]
    4642:	3334      	adds	r3, #52	; 0x34
    4644:	0019      	movs	r1, r3
    4646:	0010      	movs	r0, r2
    4648:	4b21      	ldr	r3, [pc, #132]	; (46d0 <vTaskSwitchContext+0xec>)
    464a:	4798      	blx	r3
		taskSELECT_HIGHEST_PRIORITY_TASK();
    464c:	4b21      	ldr	r3, [pc, #132]	; (46d4 <vTaskSwitchContext+0xf0>)
    464e:	681b      	ldr	r3, [r3, #0]
    4650:	60fb      	str	r3, [r7, #12]
    4652:	e007      	b.n	4664 <vTaskSwitchContext+0x80>
    4654:	68fb      	ldr	r3, [r7, #12]
    4656:	2b00      	cmp	r3, #0
    4658:	d101      	bne.n	465e <vTaskSwitchContext+0x7a>
    465a:	b672      	cpsid	i
    465c:	e7fe      	b.n	465c <vTaskSwitchContext+0x78>
    465e:	68fb      	ldr	r3, [r7, #12]
    4660:	3b01      	subs	r3, #1
    4662:	60fb      	str	r3, [r7, #12]
    4664:	491c      	ldr	r1, [pc, #112]	; (46d8 <vTaskSwitchContext+0xf4>)
    4666:	68fa      	ldr	r2, [r7, #12]
    4668:	0013      	movs	r3, r2
    466a:	009b      	lsls	r3, r3, #2
    466c:	189b      	adds	r3, r3, r2
    466e:	009b      	lsls	r3, r3, #2
    4670:	585b      	ldr	r3, [r3, r1]
    4672:	2b00      	cmp	r3, #0
    4674:	d0ee      	beq.n	4654 <vTaskSwitchContext+0x70>
    4676:	68fa      	ldr	r2, [r7, #12]
    4678:	0013      	movs	r3, r2
    467a:	009b      	lsls	r3, r3, #2
    467c:	189b      	adds	r3, r3, r2
    467e:	009b      	lsls	r3, r3, #2
    4680:	4a15      	ldr	r2, [pc, #84]	; (46d8 <vTaskSwitchContext+0xf4>)
    4682:	189b      	adds	r3, r3, r2
    4684:	603b      	str	r3, [r7, #0]
    4686:	683b      	ldr	r3, [r7, #0]
    4688:	685b      	ldr	r3, [r3, #4]
    468a:	685a      	ldr	r2, [r3, #4]
    468c:	683b      	ldr	r3, [r7, #0]
    468e:	605a      	str	r2, [r3, #4]
    4690:	683b      	ldr	r3, [r7, #0]
    4692:	685a      	ldr	r2, [r3, #4]
    4694:	683b      	ldr	r3, [r7, #0]
    4696:	3308      	adds	r3, #8
    4698:	429a      	cmp	r2, r3
    469a:	d104      	bne.n	46a6 <vTaskSwitchContext+0xc2>
    469c:	683b      	ldr	r3, [r7, #0]
    469e:	685b      	ldr	r3, [r3, #4]
    46a0:	685a      	ldr	r2, [r3, #4]
    46a2:	683b      	ldr	r3, [r7, #0]
    46a4:	605a      	str	r2, [r3, #4]
    46a6:	683b      	ldr	r3, [r7, #0]
    46a8:	685b      	ldr	r3, [r3, #4]
    46aa:	68da      	ldr	r2, [r3, #12]
    46ac:	4b06      	ldr	r3, [pc, #24]	; (46c8 <vTaskSwitchContext+0xe4>)
    46ae:	601a      	str	r2, [r3, #0]
    46b0:	4b08      	ldr	r3, [pc, #32]	; (46d4 <vTaskSwitchContext+0xf0>)
    46b2:	68fa      	ldr	r2, [r7, #12]
    46b4:	601a      	str	r2, [r3, #0]
}
    46b6:	46c0      	nop			; (mov r8, r8)
    46b8:	46bd      	mov	sp, r7
    46ba:	b004      	add	sp, #16
    46bc:	bd80      	pop	{r7, pc}
    46be:	46c0      	nop			; (mov r8, r8)
    46c0:	20003298 	.word	0x20003298
    46c4:	20003284 	.word	0x20003284
    46c8:	20003198 	.word	0x20003198
    46cc:	a5a5a5a5 	.word	0xa5a5a5a5
    46d0:	00006095 	.word	0x00006095
    46d4:	20003278 	.word	0x20003278
    46d8:	2000319c 	.word	0x2000319c

000046dc <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    46dc:	b580      	push	{r7, lr}
    46de:	b082      	sub	sp, #8
    46e0:	af00      	add	r7, sp, #0
    46e2:	6078      	str	r0, [r7, #4]
    46e4:	6039      	str	r1, [r7, #0]
	configASSERT( pxEventList );
    46e6:	687b      	ldr	r3, [r7, #4]
    46e8:	2b00      	cmp	r3, #0
    46ea:	d101      	bne.n	46f0 <vTaskPlaceOnEventList+0x14>
    46ec:	b672      	cpsid	i
    46ee:	e7fe      	b.n	46ee <vTaskPlaceOnEventList+0x12>

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    46f0:	4b08      	ldr	r3, [pc, #32]	; (4714 <vTaskPlaceOnEventList+0x38>)
    46f2:	681b      	ldr	r3, [r3, #0]
    46f4:	3318      	adds	r3, #24
    46f6:	001a      	movs	r2, r3
    46f8:	687b      	ldr	r3, [r7, #4]
    46fa:	0011      	movs	r1, r2
    46fc:	0018      	movs	r0, r3
    46fe:	4b06      	ldr	r3, [pc, #24]	; (4718 <vTaskPlaceOnEventList+0x3c>)
    4700:	4798      	blx	r3

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4702:	683b      	ldr	r3, [r7, #0]
    4704:	2101      	movs	r1, #1
    4706:	0018      	movs	r0, r3
    4708:	4b04      	ldr	r3, [pc, #16]	; (471c <vTaskPlaceOnEventList+0x40>)
    470a:	4798      	blx	r3
}
    470c:	46c0      	nop			; (mov r8, r8)
    470e:	46bd      	mov	sp, r7
    4710:	b002      	add	sp, #8
    4712:	bd80      	pop	{r7, pc}
    4714:	20003198 	.word	0x20003198
    4718:	00002e6b 	.word	0x00002e6b
    471c:	00004f35 	.word	0x00004f35

00004720 <vTaskPlaceOnEventListRestricted>:
/*-----------------------------------------------------------*/

#if( configUSE_TIMERS == 1 )

	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
    4720:	b580      	push	{r7, lr}
    4722:	b084      	sub	sp, #16
    4724:	af00      	add	r7, sp, #0
    4726:	60f8      	str	r0, [r7, #12]
    4728:	60b9      	str	r1, [r7, #8]
    472a:	607a      	str	r2, [r7, #4]
		configASSERT( pxEventList );
    472c:	68fb      	ldr	r3, [r7, #12]
    472e:	2b00      	cmp	r3, #0
    4730:	d101      	bne.n	4736 <vTaskPlaceOnEventListRestricted+0x16>
    4732:	b672      	cpsid	i
    4734:	e7fe      	b.n	4734 <vTaskPlaceOnEventListRestricted+0x14>

		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    4736:	4b0c      	ldr	r3, [pc, #48]	; (4768 <vTaskPlaceOnEventListRestricted+0x48>)
    4738:	681b      	ldr	r3, [r3, #0]
    473a:	3318      	adds	r3, #24
    473c:	001a      	movs	r2, r3
    473e:	68fb      	ldr	r3, [r7, #12]
    4740:	0011      	movs	r1, r2
    4742:	0018      	movs	r0, r3
    4744:	4b09      	ldr	r3, [pc, #36]	; (476c <vTaskPlaceOnEventListRestricted+0x4c>)
    4746:	4798      	blx	r3

		/* If the task should block indefinitely then set the block time to a
		value that will be recognised as an indefinite delay inside the
		prvAddCurrentTaskToDelayedList() function. */
		if( xWaitIndefinitely != pdFALSE )
    4748:	687b      	ldr	r3, [r7, #4]
    474a:	2b00      	cmp	r3, #0
    474c:	d002      	beq.n	4754 <vTaskPlaceOnEventListRestricted+0x34>
		{
			xTicksToWait = portMAX_DELAY;
    474e:	2301      	movs	r3, #1
    4750:	425b      	negs	r3, r3
    4752:	60bb      	str	r3, [r7, #8]
		}

		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
    4754:	687a      	ldr	r2, [r7, #4]
    4756:	68bb      	ldr	r3, [r7, #8]
    4758:	0011      	movs	r1, r2
    475a:	0018      	movs	r0, r3
    475c:	4b04      	ldr	r3, [pc, #16]	; (4770 <vTaskPlaceOnEventListRestricted+0x50>)
    475e:	4798      	blx	r3
	}
    4760:	46c0      	nop			; (mov r8, r8)
    4762:	46bd      	mov	sp, r7
    4764:	b004      	add	sp, #16
    4766:	bd80      	pop	{r7, pc}
    4768:	20003198 	.word	0x20003198
    476c:	00002e27 	.word	0x00002e27
    4770:	00004f35 	.word	0x00004f35

00004774 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    4774:	b580      	push	{r7, lr}
    4776:	b084      	sub	sp, #16
    4778:	af00      	add	r7, sp, #0
    477a:	6078      	str	r0, [r7, #4]
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    477c:	687b      	ldr	r3, [r7, #4]
    477e:	68db      	ldr	r3, [r3, #12]
    4780:	68db      	ldr	r3, [r3, #12]
    4782:	60bb      	str	r3, [r7, #8]
	configASSERT( pxUnblockedTCB );
    4784:	68bb      	ldr	r3, [r7, #8]
    4786:	2b00      	cmp	r3, #0
    4788:	d101      	bne.n	478e <xTaskRemoveFromEventList+0x1a>
    478a:	b672      	cpsid	i
    478c:	e7fe      	b.n	478c <xTaskRemoveFromEventList+0x18>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    478e:	68bb      	ldr	r3, [r7, #8]
    4790:	3318      	adds	r3, #24
    4792:	0018      	movs	r0, r3
    4794:	4b1f      	ldr	r3, [pc, #124]	; (4814 <xTaskRemoveFromEventList+0xa0>)
    4796:	4798      	blx	r3

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4798:	4b1f      	ldr	r3, [pc, #124]	; (4818 <xTaskRemoveFromEventList+0xa4>)
    479a:	681b      	ldr	r3, [r3, #0]
    479c:	2b00      	cmp	r3, #0
    479e:	d11d      	bne.n	47dc <xTaskRemoveFromEventList+0x68>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    47a0:	68bb      	ldr	r3, [r7, #8]
    47a2:	3304      	adds	r3, #4
    47a4:	0018      	movs	r0, r3
    47a6:	4b1b      	ldr	r3, [pc, #108]	; (4814 <xTaskRemoveFromEventList+0xa0>)
    47a8:	4798      	blx	r3
		prvAddTaskToReadyList( pxUnblockedTCB );
    47aa:	68bb      	ldr	r3, [r7, #8]
    47ac:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    47ae:	4b1b      	ldr	r3, [pc, #108]	; (481c <xTaskRemoveFromEventList+0xa8>)
    47b0:	681b      	ldr	r3, [r3, #0]
    47b2:	429a      	cmp	r2, r3
    47b4:	d903      	bls.n	47be <xTaskRemoveFromEventList+0x4a>
    47b6:	68bb      	ldr	r3, [r7, #8]
    47b8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    47ba:	4b18      	ldr	r3, [pc, #96]	; (481c <xTaskRemoveFromEventList+0xa8>)
    47bc:	601a      	str	r2, [r3, #0]
    47be:	68bb      	ldr	r3, [r7, #8]
    47c0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    47c2:	0013      	movs	r3, r2
    47c4:	009b      	lsls	r3, r3, #2
    47c6:	189b      	adds	r3, r3, r2
    47c8:	009b      	lsls	r3, r3, #2
    47ca:	4a15      	ldr	r2, [pc, #84]	; (4820 <xTaskRemoveFromEventList+0xac>)
    47cc:	189a      	adds	r2, r3, r2
    47ce:	68bb      	ldr	r3, [r7, #8]
    47d0:	3304      	adds	r3, #4
    47d2:	0019      	movs	r1, r3
    47d4:	0010      	movs	r0, r2
    47d6:	4b13      	ldr	r3, [pc, #76]	; (4824 <xTaskRemoveFromEventList+0xb0>)
    47d8:	4798      	blx	r3
    47da:	e007      	b.n	47ec <xTaskRemoveFromEventList+0x78>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    47dc:	68bb      	ldr	r3, [r7, #8]
    47de:	3318      	adds	r3, #24
    47e0:	001a      	movs	r2, r3
    47e2:	4b11      	ldr	r3, [pc, #68]	; (4828 <xTaskRemoveFromEventList+0xb4>)
    47e4:	0011      	movs	r1, r2
    47e6:	0018      	movs	r0, r3
    47e8:	4b0e      	ldr	r3, [pc, #56]	; (4824 <xTaskRemoveFromEventList+0xb0>)
    47ea:	4798      	blx	r3
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    47ec:	68bb      	ldr	r3, [r7, #8]
    47ee:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    47f0:	4b0e      	ldr	r3, [pc, #56]	; (482c <xTaskRemoveFromEventList+0xb8>)
    47f2:	681b      	ldr	r3, [r3, #0]
    47f4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    47f6:	429a      	cmp	r2, r3
    47f8:	d905      	bls.n	4806 <xTaskRemoveFromEventList+0x92>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    47fa:	2301      	movs	r3, #1
    47fc:	60fb      	str	r3, [r7, #12]

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    47fe:	4b0c      	ldr	r3, [pc, #48]	; (4830 <xTaskRemoveFromEventList+0xbc>)
    4800:	2201      	movs	r2, #1
    4802:	601a      	str	r2, [r3, #0]
    4804:	e001      	b.n	480a <xTaskRemoveFromEventList+0x96>
	}
	else
	{
		xReturn = pdFALSE;
    4806:	2300      	movs	r3, #0
    4808:	60fb      	str	r3, [r7, #12]
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
    480a:	68fb      	ldr	r3, [r7, #12]
}
    480c:	0018      	movs	r0, r3
    480e:	46bd      	mov	sp, r7
    4810:	b004      	add	sp, #16
    4812:	bd80      	pop	{r7, pc}
    4814:	00002ed7 	.word	0x00002ed7
    4818:	20003298 	.word	0x20003298
    481c:	20003278 	.word	0x20003278
    4820:	2000319c 	.word	0x2000319c
    4824:	00002e27 	.word	0x00002e27
    4828:	20003230 	.word	0x20003230
    482c:	20003198 	.word	0x20003198
    4830:	20003284 	.word	0x20003284

00004834 <vTaskInternalSetTimeOutState>:
	taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4834:	b580      	push	{r7, lr}
    4836:	b082      	sub	sp, #8
    4838:	af00      	add	r7, sp, #0
    483a:	6078      	str	r0, [r7, #4]
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    483c:	4b05      	ldr	r3, [pc, #20]	; (4854 <vTaskInternalSetTimeOutState+0x20>)
    483e:	681a      	ldr	r2, [r3, #0]
    4840:	687b      	ldr	r3, [r7, #4]
    4842:	601a      	str	r2, [r3, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
    4844:	4b04      	ldr	r3, [pc, #16]	; (4858 <vTaskInternalSetTimeOutState+0x24>)
    4846:	681a      	ldr	r2, [r3, #0]
    4848:	687b      	ldr	r3, [r7, #4]
    484a:	605a      	str	r2, [r3, #4]
}
    484c:	46c0      	nop			; (mov r8, r8)
    484e:	46bd      	mov	sp, r7
    4850:	b002      	add	sp, #8
    4852:	bd80      	pop	{r7, pc}
    4854:	20003288 	.word	0x20003288
    4858:	20003274 	.word	0x20003274

0000485c <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    485c:	b580      	push	{r7, lr}
    485e:	b086      	sub	sp, #24
    4860:	af00      	add	r7, sp, #0
    4862:	6078      	str	r0, [r7, #4]
    4864:	6039      	str	r1, [r7, #0]
BaseType_t xReturn;

	configASSERT( pxTimeOut );
    4866:	687b      	ldr	r3, [r7, #4]
    4868:	2b00      	cmp	r3, #0
    486a:	d101      	bne.n	4870 <xTaskCheckForTimeOut+0x14>
    486c:	b672      	cpsid	i
    486e:	e7fe      	b.n	486e <xTaskCheckForTimeOut+0x12>
	configASSERT( pxTicksToWait );
    4870:	683b      	ldr	r3, [r7, #0]
    4872:	2b00      	cmp	r3, #0
    4874:	d101      	bne.n	487a <xTaskCheckForTimeOut+0x1e>
    4876:	b672      	cpsid	i
    4878:	e7fe      	b.n	4878 <xTaskCheckForTimeOut+0x1c>

	taskENTER_CRITICAL();
    487a:	4b1e      	ldr	r3, [pc, #120]	; (48f4 <xTaskCheckForTimeOut+0x98>)
    487c:	4798      	blx	r3
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    487e:	4b1e      	ldr	r3, [pc, #120]	; (48f8 <xTaskCheckForTimeOut+0x9c>)
    4880:	681b      	ldr	r3, [r3, #0]
    4882:	613b      	str	r3, [r7, #16]
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    4884:	687b      	ldr	r3, [r7, #4]
    4886:	685b      	ldr	r3, [r3, #4]
    4888:	693a      	ldr	r2, [r7, #16]
    488a:	1ad3      	subs	r3, r2, r3
    488c:	60fb      	str	r3, [r7, #12]
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    488e:	683b      	ldr	r3, [r7, #0]
    4890:	681b      	ldr	r3, [r3, #0]
    4892:	3301      	adds	r3, #1
    4894:	d102      	bne.n	489c <xTaskCheckForTimeOut+0x40>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    4896:	2300      	movs	r3, #0
    4898:	617b      	str	r3, [r7, #20]
    489a:	e024      	b.n	48e6 <xTaskCheckForTimeOut+0x8a>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    489c:	687b      	ldr	r3, [r7, #4]
    489e:	681a      	ldr	r2, [r3, #0]
    48a0:	4b16      	ldr	r3, [pc, #88]	; (48fc <xTaskCheckForTimeOut+0xa0>)
    48a2:	681b      	ldr	r3, [r3, #0]
    48a4:	429a      	cmp	r2, r3
    48a6:	d007      	beq.n	48b8 <xTaskCheckForTimeOut+0x5c>
    48a8:	687b      	ldr	r3, [r7, #4]
    48aa:	685a      	ldr	r2, [r3, #4]
    48ac:	693b      	ldr	r3, [r7, #16]
    48ae:	429a      	cmp	r2, r3
    48b0:	d802      	bhi.n	48b8 <xTaskCheckForTimeOut+0x5c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    48b2:	2301      	movs	r3, #1
    48b4:	617b      	str	r3, [r7, #20]
    48b6:	e016      	b.n	48e6 <xTaskCheckForTimeOut+0x8a>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    48b8:	683b      	ldr	r3, [r7, #0]
    48ba:	681a      	ldr	r2, [r3, #0]
    48bc:	68fb      	ldr	r3, [r7, #12]
    48be:	429a      	cmp	r2, r3
    48c0:	d90c      	bls.n	48dc <xTaskCheckForTimeOut+0x80>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    48c2:	683b      	ldr	r3, [r7, #0]
    48c4:	681a      	ldr	r2, [r3, #0]
    48c6:	68fb      	ldr	r3, [r7, #12]
    48c8:	1ad2      	subs	r2, r2, r3
    48ca:	683b      	ldr	r3, [r7, #0]
    48cc:	601a      	str	r2, [r3, #0]
			vTaskInternalSetTimeOutState( pxTimeOut );
    48ce:	687b      	ldr	r3, [r7, #4]
    48d0:	0018      	movs	r0, r3
    48d2:	4b0b      	ldr	r3, [pc, #44]	; (4900 <xTaskCheckForTimeOut+0xa4>)
    48d4:	4798      	blx	r3
			xReturn = pdFALSE;
    48d6:	2300      	movs	r3, #0
    48d8:	617b      	str	r3, [r7, #20]
    48da:	e004      	b.n	48e6 <xTaskCheckForTimeOut+0x8a>
		}
		else
		{
			*pxTicksToWait = 0;
    48dc:	683b      	ldr	r3, [r7, #0]
    48de:	2200      	movs	r2, #0
    48e0:	601a      	str	r2, [r3, #0]
			xReturn = pdTRUE;
    48e2:	2301      	movs	r3, #1
    48e4:	617b      	str	r3, [r7, #20]
		}
	}
	taskEXIT_CRITICAL();
    48e6:	4b07      	ldr	r3, [pc, #28]	; (4904 <xTaskCheckForTimeOut+0xa8>)
    48e8:	4798      	blx	r3

	return xReturn;
    48ea:	697b      	ldr	r3, [r7, #20]
}
    48ec:	0018      	movs	r0, r3
    48ee:	46bd      	mov	sp, r7
    48f0:	b006      	add	sp, #24
    48f2:	bd80      	pop	{r7, pc}
    48f4:	00003061 	.word	0x00003061
    48f8:	20003274 	.word	0x20003274
    48fc:	20003288 	.word	0x20003288
    4900:	00004835 	.word	0x00004835
    4904:	00003085 	.word	0x00003085

00004908 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    4908:	b580      	push	{r7, lr}
    490a:	af00      	add	r7, sp, #0
	xYieldPending = pdTRUE;
    490c:	4b02      	ldr	r3, [pc, #8]	; (4918 <vTaskMissedYield+0x10>)
    490e:	2201      	movs	r2, #1
    4910:	601a      	str	r2, [r3, #0]
}
    4912:	46c0      	nop			; (mov r8, r8)
    4914:	46bd      	mov	sp, r7
    4916:	bd80      	pop	{r7, pc}
    4918:	20003284 	.word	0x20003284

0000491c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    491c:	b580      	push	{r7, lr}
    491e:	b082      	sub	sp, #8
    4920:	af00      	add	r7, sp, #0
    4922:	6078      	str	r0, [r7, #4]

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    4924:	4b04      	ldr	r3, [pc, #16]	; (4938 <prvIdleTask+0x1c>)
    4926:	4798      	blx	r3

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    4928:	4b04      	ldr	r3, [pc, #16]	; (493c <prvIdleTask+0x20>)
    492a:	681b      	ldr	r3, [r3, #0]
    492c:	2b01      	cmp	r3, #1
    492e:	d9f9      	bls.n	4924 <prvIdleTask+0x8>
			{
				taskYIELD();
    4930:	4b03      	ldr	r3, [pc, #12]	; (4940 <prvIdleTask+0x24>)
    4932:	4798      	blx	r3
		prvCheckTasksWaitingTermination();
    4934:	e7f6      	b.n	4924 <prvIdleTask+0x8>
    4936:	46c0      	nop			; (mov r8, r8)
    4938:	000049d1 	.word	0x000049d1
    493c:	2000319c 	.word	0x2000319c
    4940:	00003041 	.word	0x00003041

00004944 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    4944:	b580      	push	{r7, lr}
    4946:	b082      	sub	sp, #8
    4948:	af00      	add	r7, sp, #0
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    494a:	2300      	movs	r3, #0
    494c:	607b      	str	r3, [r7, #4]
    494e:	e00c      	b.n	496a <prvInitialiseTaskLists+0x26>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    4950:	687a      	ldr	r2, [r7, #4]
    4952:	0013      	movs	r3, r2
    4954:	009b      	lsls	r3, r3, #2
    4956:	189b      	adds	r3, r3, r2
    4958:	009b      	lsls	r3, r3, #2
    495a:	4a14      	ldr	r2, [pc, #80]	; (49ac <prvInitialiseTaskLists+0x68>)
    495c:	189b      	adds	r3, r3, r2
    495e:	0018      	movs	r0, r3
    4960:	4b13      	ldr	r3, [pc, #76]	; (49b0 <prvInitialiseTaskLists+0x6c>)
    4962:	4798      	blx	r3
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4964:	687b      	ldr	r3, [r7, #4]
    4966:	3301      	adds	r3, #1
    4968:	607b      	str	r3, [r7, #4]
    496a:	687b      	ldr	r3, [r7, #4]
    496c:	2b04      	cmp	r3, #4
    496e:	d9ef      	bls.n	4950 <prvInitialiseTaskLists+0xc>
	}

	vListInitialise( &xDelayedTaskList1 );
    4970:	4b10      	ldr	r3, [pc, #64]	; (49b4 <prvInitialiseTaskLists+0x70>)
    4972:	0018      	movs	r0, r3
    4974:	4b0e      	ldr	r3, [pc, #56]	; (49b0 <prvInitialiseTaskLists+0x6c>)
    4976:	4798      	blx	r3
	vListInitialise( &xDelayedTaskList2 );
    4978:	4b0f      	ldr	r3, [pc, #60]	; (49b8 <prvInitialiseTaskLists+0x74>)
    497a:	0018      	movs	r0, r3
    497c:	4b0c      	ldr	r3, [pc, #48]	; (49b0 <prvInitialiseTaskLists+0x6c>)
    497e:	4798      	blx	r3
	vListInitialise( &xPendingReadyList );
    4980:	4b0e      	ldr	r3, [pc, #56]	; (49bc <prvInitialiseTaskLists+0x78>)
    4982:	0018      	movs	r0, r3
    4984:	4b0a      	ldr	r3, [pc, #40]	; (49b0 <prvInitialiseTaskLists+0x6c>)
    4986:	4798      	blx	r3

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    4988:	4b0d      	ldr	r3, [pc, #52]	; (49c0 <prvInitialiseTaskLists+0x7c>)
    498a:	0018      	movs	r0, r3
    498c:	4b08      	ldr	r3, [pc, #32]	; (49b0 <prvInitialiseTaskLists+0x6c>)
    498e:	4798      	blx	r3
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    4990:	4b0c      	ldr	r3, [pc, #48]	; (49c4 <prvInitialiseTaskLists+0x80>)
    4992:	0018      	movs	r0, r3
    4994:	4b06      	ldr	r3, [pc, #24]	; (49b0 <prvInitialiseTaskLists+0x6c>)
    4996:	4798      	blx	r3
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    4998:	4b0b      	ldr	r3, [pc, #44]	; (49c8 <prvInitialiseTaskLists+0x84>)
    499a:	4a06      	ldr	r2, [pc, #24]	; (49b4 <prvInitialiseTaskLists+0x70>)
    499c:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    499e:	4b0b      	ldr	r3, [pc, #44]	; (49cc <prvInitialiseTaskLists+0x88>)
    49a0:	4a05      	ldr	r2, [pc, #20]	; (49b8 <prvInitialiseTaskLists+0x74>)
    49a2:	601a      	str	r2, [r3, #0]
}
    49a4:	46c0      	nop			; (mov r8, r8)
    49a6:	46bd      	mov	sp, r7
    49a8:	b002      	add	sp, #8
    49aa:	bd80      	pop	{r7, pc}
    49ac:	2000319c 	.word	0x2000319c
    49b0:	00002dd5 	.word	0x00002dd5
    49b4:	20003200 	.word	0x20003200
    49b8:	20003214 	.word	0x20003214
    49bc:	20003230 	.word	0x20003230
    49c0:	20003244 	.word	0x20003244
    49c4:	2000325c 	.word	0x2000325c
    49c8:	20003228 	.word	0x20003228
    49cc:	2000322c 	.word	0x2000322c

000049d0 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    49d0:	b580      	push	{r7, lr}
    49d2:	b082      	sub	sp, #8
    49d4:	af00      	add	r7, sp, #0
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent vTaskSuspendAll()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    49d6:	e01a      	b.n	4a0e <prvCheckTasksWaitingTermination+0x3e>
		{
			taskENTER_CRITICAL();
    49d8:	4b11      	ldr	r3, [pc, #68]	; (4a20 <prvCheckTasksWaitingTermination+0x50>)
    49da:	4798      	blx	r3
			{
				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    49dc:	4b11      	ldr	r3, [pc, #68]	; (4a24 <prvCheckTasksWaitingTermination+0x54>)
    49de:	68db      	ldr	r3, [r3, #12]
    49e0:	68db      	ldr	r3, [r3, #12]
    49e2:	607b      	str	r3, [r7, #4]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    49e4:	687b      	ldr	r3, [r7, #4]
    49e6:	3304      	adds	r3, #4
    49e8:	0018      	movs	r0, r3
    49ea:	4b0f      	ldr	r3, [pc, #60]	; (4a28 <prvCheckTasksWaitingTermination+0x58>)
    49ec:	4798      	blx	r3
				--uxCurrentNumberOfTasks;
    49ee:	4b0f      	ldr	r3, [pc, #60]	; (4a2c <prvCheckTasksWaitingTermination+0x5c>)
    49f0:	681b      	ldr	r3, [r3, #0]
    49f2:	1e5a      	subs	r2, r3, #1
    49f4:	4b0d      	ldr	r3, [pc, #52]	; (4a2c <prvCheckTasksWaitingTermination+0x5c>)
    49f6:	601a      	str	r2, [r3, #0]
				--uxDeletedTasksWaitingCleanUp;
    49f8:	4b0d      	ldr	r3, [pc, #52]	; (4a30 <prvCheckTasksWaitingTermination+0x60>)
    49fa:	681b      	ldr	r3, [r3, #0]
    49fc:	1e5a      	subs	r2, r3, #1
    49fe:	4b0c      	ldr	r3, [pc, #48]	; (4a30 <prvCheckTasksWaitingTermination+0x60>)
    4a00:	601a      	str	r2, [r3, #0]
			}
			taskEXIT_CRITICAL();
    4a02:	4b0c      	ldr	r3, [pc, #48]	; (4a34 <prvCheckTasksWaitingTermination+0x64>)
    4a04:	4798      	blx	r3

			prvDeleteTCB( pxTCB );
    4a06:	687b      	ldr	r3, [r7, #4]
    4a08:	0018      	movs	r0, r3
    4a0a:	4b0b      	ldr	r3, [pc, #44]	; (4a38 <prvCheckTasksWaitingTermination+0x68>)
    4a0c:	4798      	blx	r3
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    4a0e:	4b08      	ldr	r3, [pc, #32]	; (4a30 <prvCheckTasksWaitingTermination+0x60>)
    4a10:	681b      	ldr	r3, [r3, #0]
    4a12:	2b00      	cmp	r3, #0
    4a14:	d1e0      	bne.n	49d8 <prvCheckTasksWaitingTermination+0x8>
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    4a16:	46c0      	nop			; (mov r8, r8)
    4a18:	46bd      	mov	sp, r7
    4a1a:	b002      	add	sp, #8
    4a1c:	bd80      	pop	{r7, pc}
    4a1e:	46c0      	nop			; (mov r8, r8)
    4a20:	00003061 	.word	0x00003061
    4a24:	20003244 	.word	0x20003244
    4a28:	00002ed7 	.word	0x00002ed7
    4a2c:	20003270 	.word	0x20003270
    4a30:	20003258 	.word	0x20003258
    4a34:	00003085 	.word	0x00003085
    4a38:	00004a3d 	.word	0x00004a3d

00004a3c <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    4a3c:	b580      	push	{r7, lr}
    4a3e:	b082      	sub	sp, #8
    4a40:	af00      	add	r7, sp, #0
    4a42:	6078      	str	r0, [r7, #4]

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    4a44:	687b      	ldr	r3, [r7, #4]
    4a46:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    4a48:	0018      	movs	r0, r3
    4a4a:	4b05      	ldr	r3, [pc, #20]	; (4a60 <prvDeleteTCB+0x24>)
    4a4c:	4798      	blx	r3
			vPortFree( pxTCB );
    4a4e:	687b      	ldr	r3, [r7, #4]
    4a50:	0018      	movs	r0, r3
    4a52:	4b03      	ldr	r3, [pc, #12]	; (4a60 <prvDeleteTCB+0x24>)
    4a54:	4798      	blx	r3
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    4a56:	46c0      	nop			; (mov r8, r8)
    4a58:	46bd      	mov	sp, r7
    4a5a:	b002      	add	sp, #8
    4a5c:	bd80      	pop	{r7, pc}
    4a5e:	46c0      	nop			; (mov r8, r8)
    4a60:	0000322d 	.word	0x0000322d

00004a64 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    4a64:	b580      	push	{r7, lr}
    4a66:	b082      	sub	sp, #8
    4a68:	af00      	add	r7, sp, #0
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4a6a:	4b0e      	ldr	r3, [pc, #56]	; (4aa4 <prvResetNextTaskUnblockTime+0x40>)
    4a6c:	681b      	ldr	r3, [r3, #0]
    4a6e:	681b      	ldr	r3, [r3, #0]
    4a70:	2b00      	cmp	r3, #0
    4a72:	d101      	bne.n	4a78 <prvResetNextTaskUnblockTime+0x14>
    4a74:	2301      	movs	r3, #1
    4a76:	e000      	b.n	4a7a <prvResetNextTaskUnblockTime+0x16>
    4a78:	2300      	movs	r3, #0
    4a7a:	2b00      	cmp	r3, #0
    4a7c:	d004      	beq.n	4a88 <prvResetNextTaskUnblockTime+0x24>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    4a7e:	4b0a      	ldr	r3, [pc, #40]	; (4aa8 <prvResetNextTaskUnblockTime+0x44>)
    4a80:	2201      	movs	r2, #1
    4a82:	4252      	negs	r2, r2
    4a84:	601a      	str	r2, [r3, #0]
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
	}
}
    4a86:	e008      	b.n	4a9a <prvResetNextTaskUnblockTime+0x36>
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    4a88:	4b06      	ldr	r3, [pc, #24]	; (4aa4 <prvResetNextTaskUnblockTime+0x40>)
    4a8a:	681b      	ldr	r3, [r3, #0]
    4a8c:	68db      	ldr	r3, [r3, #12]
    4a8e:	68db      	ldr	r3, [r3, #12]
    4a90:	607b      	str	r3, [r7, #4]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    4a92:	687b      	ldr	r3, [r7, #4]
    4a94:	685a      	ldr	r2, [r3, #4]
    4a96:	4b04      	ldr	r3, [pc, #16]	; (4aa8 <prvResetNextTaskUnblockTime+0x44>)
    4a98:	601a      	str	r2, [r3, #0]
}
    4a9a:	46c0      	nop			; (mov r8, r8)
    4a9c:	46bd      	mov	sp, r7
    4a9e:	b002      	add	sp, #8
    4aa0:	bd80      	pop	{r7, pc}
    4aa2:	46c0      	nop			; (mov r8, r8)
    4aa4:	20003228 	.word	0x20003228
    4aa8:	20003290 	.word	0x20003290

00004aac <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

	BaseType_t xTaskGetSchedulerState( void )
	{
    4aac:	b580      	push	{r7, lr}
    4aae:	b082      	sub	sp, #8
    4ab0:	af00      	add	r7, sp, #0
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
    4ab2:	4b0a      	ldr	r3, [pc, #40]	; (4adc <xTaskGetSchedulerState+0x30>)
    4ab4:	681b      	ldr	r3, [r3, #0]
    4ab6:	2b00      	cmp	r3, #0
    4ab8:	d102      	bne.n	4ac0 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    4aba:	2301      	movs	r3, #1
    4abc:	607b      	str	r3, [r7, #4]
    4abe:	e008      	b.n	4ad2 <xTaskGetSchedulerState+0x26>
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4ac0:	4b07      	ldr	r3, [pc, #28]	; (4ae0 <xTaskGetSchedulerState+0x34>)
    4ac2:	681b      	ldr	r3, [r3, #0]
    4ac4:	2b00      	cmp	r3, #0
    4ac6:	d102      	bne.n	4ace <xTaskGetSchedulerState+0x22>
			{
				xReturn = taskSCHEDULER_RUNNING;
    4ac8:	2302      	movs	r3, #2
    4aca:	607b      	str	r3, [r7, #4]
    4acc:	e001      	b.n	4ad2 <xTaskGetSchedulerState+0x26>
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    4ace:	2300      	movs	r3, #0
    4ad0:	607b      	str	r3, [r7, #4]
			}
		}

		return xReturn;
    4ad2:	687b      	ldr	r3, [r7, #4]
	}
    4ad4:	0018      	movs	r0, r3
    4ad6:	46bd      	mov	sp, r7
    4ad8:	b002      	add	sp, #8
    4ada:	bd80      	pop	{r7, pc}
    4adc:	2000327c 	.word	0x2000327c
    4ae0:	20003298 	.word	0x20003298

00004ae4 <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    4ae4:	b580      	push	{r7, lr}
    4ae6:	b084      	sub	sp, #16
    4ae8:	af00      	add	r7, sp, #0
    4aea:	6078      	str	r0, [r7, #4]
	TCB_t * const pxMutexHolderTCB = ( TCB_t * ) pxMutexHolder;
    4aec:	687b      	ldr	r3, [r7, #4]
    4aee:	60bb      	str	r3, [r7, #8]
	BaseType_t xReturn = pdFALSE;
    4af0:	2300      	movs	r3, #0
    4af2:	60fb      	str	r3, [r7, #12]

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL.  _RB_ Is this still
		needed as interrupts can no longer use mutexes? */
		if( pxMutexHolder != NULL )
    4af4:	687b      	ldr	r3, [r7, #4]
    4af6:	2b00      	cmp	r3, #0
    4af8:	d056      	beq.n	4ba8 <xTaskPriorityInherit+0xc4>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
    4afa:	68bb      	ldr	r3, [r7, #8]
    4afc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4afe:	4b2d      	ldr	r3, [pc, #180]	; (4bb4 <xTaskPriorityInherit+0xd0>)
    4b00:	681b      	ldr	r3, [r3, #0]
    4b02:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    4b04:	429a      	cmp	r2, r3
    4b06:	d246      	bcs.n	4b96 <xTaskPriorityInherit+0xb2>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    4b08:	68bb      	ldr	r3, [r7, #8]
    4b0a:	699b      	ldr	r3, [r3, #24]
    4b0c:	2b00      	cmp	r3, #0
    4b0e:	db06      	blt.n	4b1e <xTaskPriorityInherit+0x3a>
				{
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4b10:	4b28      	ldr	r3, [pc, #160]	; (4bb4 <xTaskPriorityInherit+0xd0>)
    4b12:	681b      	ldr	r3, [r3, #0]
    4b14:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    4b16:	2205      	movs	r2, #5
    4b18:	1ad2      	subs	r2, r2, r3
    4b1a:	68bb      	ldr	r3, [r7, #8]
    4b1c:	619a      	str	r2, [r3, #24]
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
    4b1e:	68bb      	ldr	r3, [r7, #8]
    4b20:	6959      	ldr	r1, [r3, #20]
    4b22:	68bb      	ldr	r3, [r7, #8]
    4b24:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4b26:	0013      	movs	r3, r2
    4b28:	009b      	lsls	r3, r3, #2
    4b2a:	189b      	adds	r3, r3, r2
    4b2c:	009b      	lsls	r3, r3, #2
    4b2e:	4a22      	ldr	r2, [pc, #136]	; (4bb8 <xTaskPriorityInherit+0xd4>)
    4b30:	189b      	adds	r3, r3, r2
    4b32:	4299      	cmp	r1, r3
    4b34:	d101      	bne.n	4b3a <xTaskPriorityInherit+0x56>
    4b36:	2301      	movs	r3, #1
    4b38:	e000      	b.n	4b3c <xTaskPriorityInherit+0x58>
    4b3a:	2300      	movs	r3, #0
    4b3c:	2b00      	cmp	r3, #0
    4b3e:	d022      	beq.n	4b86 <xTaskPriorityInherit+0xa2>
				{
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    4b40:	68bb      	ldr	r3, [r7, #8]
    4b42:	3304      	adds	r3, #4
    4b44:	0018      	movs	r0, r3
    4b46:	4b1d      	ldr	r3, [pc, #116]	; (4bbc <xTaskPriorityInherit+0xd8>)
    4b48:	4798      	blx	r3
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    4b4a:	4b1a      	ldr	r3, [pc, #104]	; (4bb4 <xTaskPriorityInherit+0xd0>)
    4b4c:	681b      	ldr	r3, [r3, #0]
    4b4e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4b50:	68bb      	ldr	r3, [r7, #8]
    4b52:	62da      	str	r2, [r3, #44]	; 0x2c
					prvAddTaskToReadyList( pxMutexHolderTCB );
    4b54:	68bb      	ldr	r3, [r7, #8]
    4b56:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4b58:	4b19      	ldr	r3, [pc, #100]	; (4bc0 <xTaskPriorityInherit+0xdc>)
    4b5a:	681b      	ldr	r3, [r3, #0]
    4b5c:	429a      	cmp	r2, r3
    4b5e:	d903      	bls.n	4b68 <xTaskPriorityInherit+0x84>
    4b60:	68bb      	ldr	r3, [r7, #8]
    4b62:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4b64:	4b16      	ldr	r3, [pc, #88]	; (4bc0 <xTaskPriorityInherit+0xdc>)
    4b66:	601a      	str	r2, [r3, #0]
    4b68:	68bb      	ldr	r3, [r7, #8]
    4b6a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4b6c:	0013      	movs	r3, r2
    4b6e:	009b      	lsls	r3, r3, #2
    4b70:	189b      	adds	r3, r3, r2
    4b72:	009b      	lsls	r3, r3, #2
    4b74:	4a10      	ldr	r2, [pc, #64]	; (4bb8 <xTaskPriorityInherit+0xd4>)
    4b76:	189a      	adds	r2, r3, r2
    4b78:	68bb      	ldr	r3, [r7, #8]
    4b7a:	3304      	adds	r3, #4
    4b7c:	0019      	movs	r1, r3
    4b7e:	0010      	movs	r0, r2
    4b80:	4b10      	ldr	r3, [pc, #64]	; (4bc4 <xTaskPriorityInherit+0xe0>)
    4b82:	4798      	blx	r3
    4b84:	e004      	b.n	4b90 <xTaskPriorityInherit+0xac>
				}
				else
				{
					/* Just inherit the priority. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    4b86:	4b0b      	ldr	r3, [pc, #44]	; (4bb4 <xTaskPriorityInherit+0xd0>)
    4b88:	681b      	ldr	r3, [r3, #0]
    4b8a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4b8c:	68bb      	ldr	r3, [r7, #8]
    4b8e:	62da      	str	r2, [r3, #44]	; 0x2c
				}

				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

				/* Inheritance occurred. */
				xReturn = pdTRUE;
    4b90:	2301      	movs	r3, #1
    4b92:	60fb      	str	r3, [r7, #12]
    4b94:	e008      	b.n	4ba8 <xTaskPriorityInherit+0xc4>
			}
			else
			{
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
    4b96:	68bb      	ldr	r3, [r7, #8]
    4b98:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    4b9a:	4b06      	ldr	r3, [pc, #24]	; (4bb4 <xTaskPriorityInherit+0xd0>)
    4b9c:	681b      	ldr	r3, [r3, #0]
    4b9e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    4ba0:	429a      	cmp	r2, r3
    4ba2:	d201      	bcs.n	4ba8 <xTaskPriorityInherit+0xc4>
					current priority of the mutex holder is not lower than the
					priority of the task attempting to take the mutex.
					Therefore the mutex holder must have already inherited a
					priority, but inheritance would have occurred if that had
					not been the case. */
					xReturn = pdTRUE;
    4ba4:	2301      	movs	r3, #1
    4ba6:	60fb      	str	r3, [r7, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    4ba8:	68fb      	ldr	r3, [r7, #12]
	}
    4baa:	0018      	movs	r0, r3
    4bac:	46bd      	mov	sp, r7
    4bae:	b004      	add	sp, #16
    4bb0:	bd80      	pop	{r7, pc}
    4bb2:	46c0      	nop			; (mov r8, r8)
    4bb4:	20003198 	.word	0x20003198
    4bb8:	2000319c 	.word	0x2000319c
    4bbc:	00002ed7 	.word	0x00002ed7
    4bc0:	20003278 	.word	0x20003278
    4bc4:	00002e27 	.word	0x00002e27

00004bc8 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    4bc8:	b580      	push	{r7, lr}
    4bca:	b084      	sub	sp, #16
    4bcc:	af00      	add	r7, sp, #0
    4bce:	6078      	str	r0, [r7, #4]
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
    4bd0:	687b      	ldr	r3, [r7, #4]
    4bd2:	60bb      	str	r3, [r7, #8]
	BaseType_t xReturn = pdFALSE;
    4bd4:	2300      	movs	r3, #0
    4bd6:	60fb      	str	r3, [r7, #12]

		if( pxMutexHolder != NULL )
    4bd8:	687b      	ldr	r3, [r7, #4]
    4bda:	2b00      	cmp	r3, #0
    4bdc:	d044      	beq.n	4c68 <xTaskPriorityDisinherit+0xa0>
		{
			/* A task can only have an inherited priority if it holds the mutex.
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
    4bde:	4b25      	ldr	r3, [pc, #148]	; (4c74 <xTaskPriorityDisinherit+0xac>)
    4be0:	681b      	ldr	r3, [r3, #0]
    4be2:	68ba      	ldr	r2, [r7, #8]
    4be4:	429a      	cmp	r2, r3
    4be6:	d001      	beq.n	4bec <xTaskPriorityDisinherit+0x24>
    4be8:	b672      	cpsid	i
    4bea:	e7fe      	b.n	4bea <xTaskPriorityDisinherit+0x22>
			configASSERT( pxTCB->uxMutexesHeld );
    4bec:	68bb      	ldr	r3, [r7, #8]
    4bee:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    4bf0:	2b00      	cmp	r3, #0
    4bf2:	d101      	bne.n	4bf8 <xTaskPriorityDisinherit+0x30>
    4bf4:	b672      	cpsid	i
    4bf6:	e7fe      	b.n	4bf6 <xTaskPriorityDisinherit+0x2e>
			( pxTCB->uxMutexesHeld )--;
    4bf8:	68bb      	ldr	r3, [r7, #8]
    4bfa:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    4bfc:	1e5a      	subs	r2, r3, #1
    4bfe:	68bb      	ldr	r3, [r7, #8]
    4c00:	64da      	str	r2, [r3, #76]	; 0x4c

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    4c02:	68bb      	ldr	r3, [r7, #8]
    4c04:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4c06:	68bb      	ldr	r3, [r7, #8]
    4c08:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    4c0a:	429a      	cmp	r2, r3
    4c0c:	d02c      	beq.n	4c68 <xTaskPriorityDisinherit+0xa0>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    4c0e:	68bb      	ldr	r3, [r7, #8]
    4c10:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    4c12:	2b00      	cmp	r3, #0
    4c14:	d128      	bne.n	4c68 <xTaskPriorityDisinherit+0xa0>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    4c16:	68bb      	ldr	r3, [r7, #8]
    4c18:	3304      	adds	r3, #4
    4c1a:	0018      	movs	r0, r3
    4c1c:	4b16      	ldr	r3, [pc, #88]	; (4c78 <xTaskPriorityDisinherit+0xb0>)
    4c1e:	4798      	blx	r3
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    4c20:	68bb      	ldr	r3, [r7, #8]
    4c22:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    4c24:	68bb      	ldr	r3, [r7, #8]
    4c26:	62da      	str	r2, [r3, #44]	; 0x2c

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4c28:	68bb      	ldr	r3, [r7, #8]
    4c2a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    4c2c:	2205      	movs	r2, #5
    4c2e:	1ad2      	subs	r2, r2, r3
    4c30:	68bb      	ldr	r3, [r7, #8]
    4c32:	619a      	str	r2, [r3, #24]
					prvAddTaskToReadyList( pxTCB );
    4c34:	68bb      	ldr	r3, [r7, #8]
    4c36:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4c38:	4b10      	ldr	r3, [pc, #64]	; (4c7c <xTaskPriorityDisinherit+0xb4>)
    4c3a:	681b      	ldr	r3, [r3, #0]
    4c3c:	429a      	cmp	r2, r3
    4c3e:	d903      	bls.n	4c48 <xTaskPriorityDisinherit+0x80>
    4c40:	68bb      	ldr	r3, [r7, #8]
    4c42:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4c44:	4b0d      	ldr	r3, [pc, #52]	; (4c7c <xTaskPriorityDisinherit+0xb4>)
    4c46:	601a      	str	r2, [r3, #0]
    4c48:	68bb      	ldr	r3, [r7, #8]
    4c4a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4c4c:	0013      	movs	r3, r2
    4c4e:	009b      	lsls	r3, r3, #2
    4c50:	189b      	adds	r3, r3, r2
    4c52:	009b      	lsls	r3, r3, #2
    4c54:	4a0a      	ldr	r2, [pc, #40]	; (4c80 <xTaskPriorityDisinherit+0xb8>)
    4c56:	189a      	adds	r2, r3, r2
    4c58:	68bb      	ldr	r3, [r7, #8]
    4c5a:	3304      	adds	r3, #4
    4c5c:	0019      	movs	r1, r3
    4c5e:	0010      	movs	r0, r2
    4c60:	4b08      	ldr	r3, [pc, #32]	; (4c84 <xTaskPriorityDisinherit+0xbc>)
    4c62:	4798      	blx	r3
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    4c64:	2301      	movs	r3, #1
    4c66:	60fb      	str	r3, [r7, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    4c68:	68fb      	ldr	r3, [r7, #12]
	}
    4c6a:	0018      	movs	r0, r3
    4c6c:	46bd      	mov	sp, r7
    4c6e:	b004      	add	sp, #16
    4c70:	bd80      	pop	{r7, pc}
    4c72:	46c0      	nop			; (mov r8, r8)
    4c74:	20003198 	.word	0x20003198
    4c78:	00002ed7 	.word	0x00002ed7
    4c7c:	20003278 	.word	0x20003278
    4c80:	2000319c 	.word	0x2000319c
    4c84:	00002e27 	.word	0x00002e27

00004c88 <vTaskPriorityDisinheritAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
	{
    4c88:	b580      	push	{r7, lr}
    4c8a:	b086      	sub	sp, #24
    4c8c:	af00      	add	r7, sp, #0
    4c8e:	6078      	str	r0, [r7, #4]
    4c90:	6039      	str	r1, [r7, #0]
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
    4c92:	687b      	ldr	r3, [r7, #4]
    4c94:	613b      	str	r3, [r7, #16]
	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
    4c96:	2301      	movs	r3, #1
    4c98:	60fb      	str	r3, [r7, #12]

		if( pxMutexHolder != NULL )
    4c9a:	687b      	ldr	r3, [r7, #4]
    4c9c:	2b00      	cmp	r3, #0
    4c9e:	d05d      	beq.n	4d5c <vTaskPriorityDisinheritAfterTimeout+0xd4>
		{
			/* If pxMutexHolder is not NULL then the holder must hold at least
			one mutex. */
			configASSERT( pxTCB->uxMutexesHeld );
    4ca0:	693b      	ldr	r3, [r7, #16]
    4ca2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    4ca4:	2b00      	cmp	r3, #0
    4ca6:	d101      	bne.n	4cac <vTaskPriorityDisinheritAfterTimeout+0x24>
    4ca8:	b672      	cpsid	i
    4caa:	e7fe      	b.n	4caa <vTaskPriorityDisinheritAfterTimeout+0x22>

			/* Determine the priority to which the priority of the task that
			holds the mutex should be set.  This will be the greater of the
			holding task's base priority and the priority of the highest
			priority task that is waiting to obtain the mutex. */
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
    4cac:	693b      	ldr	r3, [r7, #16]
    4cae:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    4cb0:	683b      	ldr	r3, [r7, #0]
    4cb2:	429a      	cmp	r2, r3
    4cb4:	d202      	bcs.n	4cbc <vTaskPriorityDisinheritAfterTimeout+0x34>
			{
				uxPriorityToUse = uxHighestPriorityWaitingTask;
    4cb6:	683b      	ldr	r3, [r7, #0]
    4cb8:	617b      	str	r3, [r7, #20]
    4cba:	e002      	b.n	4cc2 <vTaskPriorityDisinheritAfterTimeout+0x3a>
			}
			else
			{
				uxPriorityToUse = pxTCB->uxBasePriority;
    4cbc:	693b      	ldr	r3, [r7, #16]
    4cbe:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    4cc0:	617b      	str	r3, [r7, #20]
			}

			/* Does the priority need to change? */
			if( pxTCB->uxPriority != uxPriorityToUse )
    4cc2:	693b      	ldr	r3, [r7, #16]
    4cc4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4cc6:	697b      	ldr	r3, [r7, #20]
    4cc8:	429a      	cmp	r2, r3
    4cca:	d047      	beq.n	4d5c <vTaskPriorityDisinheritAfterTimeout+0xd4>
			{
				/* Only disinherit if no other mutexes are held.  This is a
				simplification in the priority inheritance implementation.  If
				the task that holds the mutex is also holding other mutexes then
				the other mutexes may have caused the priority inheritance. */
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
    4ccc:	693b      	ldr	r3, [r7, #16]
    4cce:	6cda      	ldr	r2, [r3, #76]	; 0x4c
    4cd0:	68fb      	ldr	r3, [r7, #12]
    4cd2:	429a      	cmp	r2, r3
    4cd4:	d142      	bne.n	4d5c <vTaskPriorityDisinheritAfterTimeout+0xd4>
				{
					/* If a task has timed out because it already holds the
					mutex it was trying to obtain then it cannot of inherited
					its own priority. */
					configASSERT( pxTCB != pxCurrentTCB );
    4cd6:	4b23      	ldr	r3, [pc, #140]	; (4d64 <vTaskPriorityDisinheritAfterTimeout+0xdc>)
    4cd8:	681b      	ldr	r3, [r3, #0]
    4cda:	693a      	ldr	r2, [r7, #16]
    4cdc:	429a      	cmp	r2, r3
    4cde:	d101      	bne.n	4ce4 <vTaskPriorityDisinheritAfterTimeout+0x5c>
    4ce0:	b672      	cpsid	i
    4ce2:	e7fe      	b.n	4ce2 <vTaskPriorityDisinheritAfterTimeout+0x5a>

					/* Disinherit the priority, remembering the previous
					priority to facilitate determining the subject task's
					state. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					uxPriorityUsedOnEntry = pxTCB->uxPriority;
    4ce4:	693b      	ldr	r3, [r7, #16]
    4ce6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    4ce8:	60bb      	str	r3, [r7, #8]
					pxTCB->uxPriority = uxPriorityToUse;
    4cea:	693b      	ldr	r3, [r7, #16]
    4cec:	697a      	ldr	r2, [r7, #20]
    4cee:	62da      	str	r2, [r3, #44]	; 0x2c

					/* Only reset the event list item value if the value is not
					being used for anything else. */
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    4cf0:	693b      	ldr	r3, [r7, #16]
    4cf2:	699b      	ldr	r3, [r3, #24]
    4cf4:	2b00      	cmp	r3, #0
    4cf6:	db04      	blt.n	4d02 <vTaskPriorityDisinheritAfterTimeout+0x7a>
					{
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4cf8:	697b      	ldr	r3, [r7, #20]
    4cfa:	2205      	movs	r2, #5
    4cfc:	1ad2      	subs	r2, r2, r3
    4cfe:	693b      	ldr	r3, [r7, #16]
    4d00:	619a      	str	r2, [r3, #24]
					then the task that holds the mutex could be in either the
					Ready, Blocked or Suspended states.  Only remove the task
					from its current state list if it is in the Ready state as
					the task's priority is going to change and there is one
					Ready list per priority. */
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    4d02:	693b      	ldr	r3, [r7, #16]
    4d04:	6959      	ldr	r1, [r3, #20]
    4d06:	68ba      	ldr	r2, [r7, #8]
    4d08:	0013      	movs	r3, r2
    4d0a:	009b      	lsls	r3, r3, #2
    4d0c:	189b      	adds	r3, r3, r2
    4d0e:	009b      	lsls	r3, r3, #2
    4d10:	4a15      	ldr	r2, [pc, #84]	; (4d68 <vTaskPriorityDisinheritAfterTimeout+0xe0>)
    4d12:	189b      	adds	r3, r3, r2
    4d14:	4299      	cmp	r1, r3
    4d16:	d101      	bne.n	4d1c <vTaskPriorityDisinheritAfterTimeout+0x94>
    4d18:	2301      	movs	r3, #1
    4d1a:	e000      	b.n	4d1e <vTaskPriorityDisinheritAfterTimeout+0x96>
    4d1c:	2300      	movs	r3, #0
    4d1e:	2b00      	cmp	r3, #0
    4d20:	d01c      	beq.n	4d5c <vTaskPriorityDisinheritAfterTimeout+0xd4>
					{
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    4d22:	693b      	ldr	r3, [r7, #16]
    4d24:	3304      	adds	r3, #4
    4d26:	0018      	movs	r0, r3
    4d28:	4b10      	ldr	r3, [pc, #64]	; (4d6c <vTaskPriorityDisinheritAfterTimeout+0xe4>)
    4d2a:	4798      	blx	r3
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}

						prvAddTaskToReadyList( pxTCB );
    4d2c:	693b      	ldr	r3, [r7, #16]
    4d2e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4d30:	4b0f      	ldr	r3, [pc, #60]	; (4d70 <vTaskPriorityDisinheritAfterTimeout+0xe8>)
    4d32:	681b      	ldr	r3, [r3, #0]
    4d34:	429a      	cmp	r2, r3
    4d36:	d903      	bls.n	4d40 <vTaskPriorityDisinheritAfterTimeout+0xb8>
    4d38:	693b      	ldr	r3, [r7, #16]
    4d3a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4d3c:	4b0c      	ldr	r3, [pc, #48]	; (4d70 <vTaskPriorityDisinheritAfterTimeout+0xe8>)
    4d3e:	601a      	str	r2, [r3, #0]
    4d40:	693b      	ldr	r3, [r7, #16]
    4d42:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4d44:	0013      	movs	r3, r2
    4d46:	009b      	lsls	r3, r3, #2
    4d48:	189b      	adds	r3, r3, r2
    4d4a:	009b      	lsls	r3, r3, #2
    4d4c:	4a06      	ldr	r2, [pc, #24]	; (4d68 <vTaskPriorityDisinheritAfterTimeout+0xe0>)
    4d4e:	189a      	adds	r2, r3, r2
    4d50:	693b      	ldr	r3, [r7, #16]
    4d52:	3304      	adds	r3, #4
    4d54:	0019      	movs	r1, r3
    4d56:	0010      	movs	r0, r2
    4d58:	4b06      	ldr	r3, [pc, #24]	; (4d74 <vTaskPriorityDisinheritAfterTimeout+0xec>)
    4d5a:	4798      	blx	r3
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    4d5c:	46c0      	nop			; (mov r8, r8)
    4d5e:	46bd      	mov	sp, r7
    4d60:	b006      	add	sp, #24
    4d62:	bd80      	pop	{r7, pc}
    4d64:	20003198 	.word	0x20003198
    4d68:	2000319c 	.word	0x2000319c
    4d6c:	00002ed7 	.word	0x00002ed7
    4d70:	20003278 	.word	0x20003278
    4d74:	00002e27 	.word	0x00002e27

00004d78 <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void *pvTaskIncrementMutexHeldCount( void )
	{
    4d78:	b580      	push	{r7, lr}
    4d7a:	af00      	add	r7, sp, #0
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    4d7c:	4b06      	ldr	r3, [pc, #24]	; (4d98 <pvTaskIncrementMutexHeldCount+0x20>)
    4d7e:	681b      	ldr	r3, [r3, #0]
    4d80:	2b00      	cmp	r3, #0
    4d82:	d004      	beq.n	4d8e <pvTaskIncrementMutexHeldCount+0x16>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    4d84:	4b04      	ldr	r3, [pc, #16]	; (4d98 <pvTaskIncrementMutexHeldCount+0x20>)
    4d86:	681b      	ldr	r3, [r3, #0]
    4d88:	6cda      	ldr	r2, [r3, #76]	; 0x4c
    4d8a:	3201      	adds	r2, #1
    4d8c:	64da      	str	r2, [r3, #76]	; 0x4c
		}

		return pxCurrentTCB;
    4d8e:	4b02      	ldr	r3, [pc, #8]	; (4d98 <pvTaskIncrementMutexHeldCount+0x20>)
    4d90:	681b      	ldr	r3, [r3, #0]
	}
    4d92:	0018      	movs	r0, r3
    4d94:	46bd      	mov	sp, r7
    4d96:	bd80      	pop	{r7, pc}
    4d98:	20003198 	.word	0x20003198

00004d9c <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    4d9c:	b580      	push	{r7, lr}
    4d9e:	b084      	sub	sp, #16
    4da0:	af00      	add	r7, sp, #0
    4da2:	6078      	str	r0, [r7, #4]
    4da4:	6039      	str	r1, [r7, #0]
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    4da6:	4b1d      	ldr	r3, [pc, #116]	; (4e1c <ulTaskNotifyTake+0x80>)
    4da8:	4798      	blx	r3
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    4daa:	4b1d      	ldr	r3, [pc, #116]	; (4e20 <ulTaskNotifyTake+0x84>)
    4dac:	681b      	ldr	r3, [r3, #0]
    4dae:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    4db0:	2b00      	cmp	r3, #0
    4db2:	d10e      	bne.n	4dd2 <ulTaskNotifyTake+0x36>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    4db4:	4b1a      	ldr	r3, [pc, #104]	; (4e20 <ulTaskNotifyTake+0x84>)
    4db6:	681b      	ldr	r3, [r3, #0]
    4db8:	2254      	movs	r2, #84	; 0x54
    4dba:	2101      	movs	r1, #1
    4dbc:	5499      	strb	r1, [r3, r2]

				if( xTicksToWait > ( TickType_t ) 0 )
    4dbe:	683b      	ldr	r3, [r7, #0]
    4dc0:	2b00      	cmp	r3, #0
    4dc2:	d006      	beq.n	4dd2 <ulTaskNotifyTake+0x36>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4dc4:	683b      	ldr	r3, [r7, #0]
    4dc6:	2101      	movs	r1, #1
    4dc8:	0018      	movs	r0, r3
    4dca:	4b16      	ldr	r3, [pc, #88]	; (4e24 <ulTaskNotifyTake+0x88>)
    4dcc:	4798      	blx	r3

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    4dce:	4b16      	ldr	r3, [pc, #88]	; (4e28 <ulTaskNotifyTake+0x8c>)
    4dd0:	4798      	blx	r3
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4dd2:	4b16      	ldr	r3, [pc, #88]	; (4e2c <ulTaskNotifyTake+0x90>)
    4dd4:	4798      	blx	r3

		taskENTER_CRITICAL();
    4dd6:	4b11      	ldr	r3, [pc, #68]	; (4e1c <ulTaskNotifyTake+0x80>)
    4dd8:	4798      	blx	r3
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    4dda:	4b11      	ldr	r3, [pc, #68]	; (4e20 <ulTaskNotifyTake+0x84>)
    4ddc:	681b      	ldr	r3, [r3, #0]
    4dde:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    4de0:	60fb      	str	r3, [r7, #12]

			if( ulReturn != 0UL )
    4de2:	68fb      	ldr	r3, [r7, #12]
    4de4:	2b00      	cmp	r3, #0
    4de6:	d00c      	beq.n	4e02 <ulTaskNotifyTake+0x66>
			{
				if( xClearCountOnExit != pdFALSE )
    4de8:	687b      	ldr	r3, [r7, #4]
    4dea:	2b00      	cmp	r3, #0
    4dec:	d004      	beq.n	4df8 <ulTaskNotifyTake+0x5c>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    4dee:	4b0c      	ldr	r3, [pc, #48]	; (4e20 <ulTaskNotifyTake+0x84>)
    4df0:	681b      	ldr	r3, [r3, #0]
    4df2:	2200      	movs	r2, #0
    4df4:	651a      	str	r2, [r3, #80]	; 0x50
    4df6:	e004      	b.n	4e02 <ulTaskNotifyTake+0x66>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    4df8:	4b09      	ldr	r3, [pc, #36]	; (4e20 <ulTaskNotifyTake+0x84>)
    4dfa:	681b      	ldr	r3, [r3, #0]
    4dfc:	68fa      	ldr	r2, [r7, #12]
    4dfe:	3a01      	subs	r2, #1
    4e00:	651a      	str	r2, [r3, #80]	; 0x50
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4e02:	4b07      	ldr	r3, [pc, #28]	; (4e20 <ulTaskNotifyTake+0x84>)
    4e04:	681b      	ldr	r3, [r3, #0]
    4e06:	2254      	movs	r2, #84	; 0x54
    4e08:	2100      	movs	r1, #0
    4e0a:	5499      	strb	r1, [r3, r2]
		}
		taskEXIT_CRITICAL();
    4e0c:	4b07      	ldr	r3, [pc, #28]	; (4e2c <ulTaskNotifyTake+0x90>)
    4e0e:	4798      	blx	r3

		return ulReturn;
    4e10:	68fb      	ldr	r3, [r7, #12]
	}
    4e12:	0018      	movs	r0, r3
    4e14:	46bd      	mov	sp, r7
    4e16:	b004      	add	sp, #16
    4e18:	bd80      	pop	{r7, pc}
    4e1a:	46c0      	nop			; (mov r8, r8)
    4e1c:	00003061 	.word	0x00003061
    4e20:	20003198 	.word	0x20003198
    4e24:	00004f35 	.word	0x00004f35
    4e28:	00003041 	.word	0x00003041
    4e2c:	00003085 	.word	0x00003085

00004e30 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    4e30:	b580      	push	{r7, lr}
    4e32:	b086      	sub	sp, #24
    4e34:	af00      	add	r7, sp, #0
    4e36:	6078      	str	r0, [r7, #4]
    4e38:	6039      	str	r1, [r7, #0]
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	UBaseType_t uxSavedInterruptStatus;

		configASSERT( xTaskToNotify );
    4e3a:	687b      	ldr	r3, [r7, #4]
    4e3c:	2b00      	cmp	r3, #0
    4e3e:	d101      	bne.n	4e44 <vTaskNotifyGiveFromISR+0x14>
    4e40:	b672      	cpsid	i
    4e42:	e7fe      	b.n	4e42 <vTaskNotifyGiveFromISR+0x12>
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
    4e44:	687b      	ldr	r3, [r7, #4]
    4e46:	617b      	str	r3, [r7, #20]

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4e48:	4b30      	ldr	r3, [pc, #192]	; (4f0c <vTaskNotifyGiveFromISR+0xdc>)
    4e4a:	4798      	blx	r3
    4e4c:	0003      	movs	r3, r0
    4e4e:	613b      	str	r3, [r7, #16]
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    4e50:	230f      	movs	r3, #15
    4e52:	18fb      	adds	r3, r7, r3
    4e54:	697a      	ldr	r2, [r7, #20]
    4e56:	2154      	movs	r1, #84	; 0x54
    4e58:	5c52      	ldrb	r2, [r2, r1]
    4e5a:	701a      	strb	r2, [r3, #0]
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    4e5c:	697b      	ldr	r3, [r7, #20]
    4e5e:	2254      	movs	r2, #84	; 0x54
    4e60:	2102      	movs	r1, #2
    4e62:	5499      	strb	r1, [r3, r2]

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    4e64:	697b      	ldr	r3, [r7, #20]
    4e66:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    4e68:	1c5a      	adds	r2, r3, #1
    4e6a:	697b      	ldr	r3, [r7, #20]
    4e6c:	651a      	str	r2, [r3, #80]	; 0x50

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4e6e:	230f      	movs	r3, #15
    4e70:	18fb      	adds	r3, r7, r3
    4e72:	781b      	ldrb	r3, [r3, #0]
    4e74:	2b01      	cmp	r3, #1
    4e76:	d140      	bne.n	4efa <vTaskNotifyGiveFromISR+0xca>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
    4e78:	697b      	ldr	r3, [r7, #20]
    4e7a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    4e7c:	2b00      	cmp	r3, #0
    4e7e:	d001      	beq.n	4e84 <vTaskNotifyGiveFromISR+0x54>
    4e80:	b672      	cpsid	i
    4e82:	e7fe      	b.n	4e82 <vTaskNotifyGiveFromISR+0x52>

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4e84:	4b22      	ldr	r3, [pc, #136]	; (4f10 <vTaskNotifyGiveFromISR+0xe0>)
    4e86:	681b      	ldr	r3, [r3, #0]
    4e88:	2b00      	cmp	r3, #0
    4e8a:	d11d      	bne.n	4ec8 <vTaskNotifyGiveFromISR+0x98>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4e8c:	697b      	ldr	r3, [r7, #20]
    4e8e:	3304      	adds	r3, #4
    4e90:	0018      	movs	r0, r3
    4e92:	4b20      	ldr	r3, [pc, #128]	; (4f14 <vTaskNotifyGiveFromISR+0xe4>)
    4e94:	4798      	blx	r3
					prvAddTaskToReadyList( pxTCB );
    4e96:	697b      	ldr	r3, [r7, #20]
    4e98:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4e9a:	4b1f      	ldr	r3, [pc, #124]	; (4f18 <vTaskNotifyGiveFromISR+0xe8>)
    4e9c:	681b      	ldr	r3, [r3, #0]
    4e9e:	429a      	cmp	r2, r3
    4ea0:	d903      	bls.n	4eaa <vTaskNotifyGiveFromISR+0x7a>
    4ea2:	697b      	ldr	r3, [r7, #20]
    4ea4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4ea6:	4b1c      	ldr	r3, [pc, #112]	; (4f18 <vTaskNotifyGiveFromISR+0xe8>)
    4ea8:	601a      	str	r2, [r3, #0]
    4eaa:	697b      	ldr	r3, [r7, #20]
    4eac:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4eae:	0013      	movs	r3, r2
    4eb0:	009b      	lsls	r3, r3, #2
    4eb2:	189b      	adds	r3, r3, r2
    4eb4:	009b      	lsls	r3, r3, #2
    4eb6:	4a19      	ldr	r2, [pc, #100]	; (4f1c <vTaskNotifyGiveFromISR+0xec>)
    4eb8:	189a      	adds	r2, r3, r2
    4eba:	697b      	ldr	r3, [r7, #20]
    4ebc:	3304      	adds	r3, #4
    4ebe:	0019      	movs	r1, r3
    4ec0:	0010      	movs	r0, r2
    4ec2:	4b17      	ldr	r3, [pc, #92]	; (4f20 <vTaskNotifyGiveFromISR+0xf0>)
    4ec4:	4798      	blx	r3
    4ec6:	e007      	b.n	4ed8 <vTaskNotifyGiveFromISR+0xa8>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    4ec8:	697b      	ldr	r3, [r7, #20]
    4eca:	3318      	adds	r3, #24
    4ecc:	001a      	movs	r2, r3
    4ece:	4b15      	ldr	r3, [pc, #84]	; (4f24 <vTaskNotifyGiveFromISR+0xf4>)
    4ed0:	0011      	movs	r1, r2
    4ed2:	0018      	movs	r0, r3
    4ed4:	4b12      	ldr	r3, [pc, #72]	; (4f20 <vTaskNotifyGiveFromISR+0xf0>)
    4ed6:	4798      	blx	r3
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4ed8:	697b      	ldr	r3, [r7, #20]
    4eda:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4edc:	4b12      	ldr	r3, [pc, #72]	; (4f28 <vTaskNotifyGiveFromISR+0xf8>)
    4ede:	681b      	ldr	r3, [r3, #0]
    4ee0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    4ee2:	429a      	cmp	r2, r3
    4ee4:	d909      	bls.n	4efa <vTaskNotifyGiveFromISR+0xca>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    4ee6:	683b      	ldr	r3, [r7, #0]
    4ee8:	2b00      	cmp	r3, #0
    4eea:	d003      	beq.n	4ef4 <vTaskNotifyGiveFromISR+0xc4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    4eec:	683b      	ldr	r3, [r7, #0]
    4eee:	2201      	movs	r2, #1
    4ef0:	601a      	str	r2, [r3, #0]
    4ef2:	e002      	b.n	4efa <vTaskNotifyGiveFromISR+0xca>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter in an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    4ef4:	4b0d      	ldr	r3, [pc, #52]	; (4f2c <vTaskNotifyGiveFromISR+0xfc>)
    4ef6:	2201      	movs	r2, #1
    4ef8:	601a      	str	r2, [r3, #0]
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    4efa:	693b      	ldr	r3, [r7, #16]
    4efc:	0018      	movs	r0, r3
    4efe:	4b0c      	ldr	r3, [pc, #48]	; (4f30 <vTaskNotifyGiveFromISR+0x100>)
    4f00:	4798      	blx	r3
	}
    4f02:	46c0      	nop			; (mov r8, r8)
    4f04:	46bd      	mov	sp, r7
    4f06:	b006      	add	sp, #24
    4f08:	bd80      	pop	{r7, pc}
    4f0a:	46c0      	nop			; (mov r8, r8)
    4f0c:	000030b5 	.word	0x000030b5
    4f10:	20003298 	.word	0x20003298
    4f14:	00002ed7 	.word	0x00002ed7
    4f18:	20003278 	.word	0x20003278
    4f1c:	2000319c 	.word	0x2000319c
    4f20:	00002e27 	.word	0x00002e27
    4f24:	20003230 	.word	0x20003230
    4f28:	20003198 	.word	0x20003198
    4f2c:	20003284 	.word	0x20003284
    4f30:	000030c1 	.word	0x000030c1

00004f34 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    4f34:	b580      	push	{r7, lr}
    4f36:	b084      	sub	sp, #16
    4f38:	af00      	add	r7, sp, #0
    4f3a:	6078      	str	r0, [r7, #4]
    4f3c:	6039      	str	r1, [r7, #0]
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    4f3e:	4b21      	ldr	r3, [pc, #132]	; (4fc4 <prvAddCurrentTaskToDelayedList+0x90>)
    4f40:	681b      	ldr	r3, [r3, #0]
    4f42:	60fb      	str	r3, [r7, #12]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    4f44:	4b20      	ldr	r3, [pc, #128]	; (4fc8 <prvAddCurrentTaskToDelayedList+0x94>)
    4f46:	681b      	ldr	r3, [r3, #0]
    4f48:	3304      	adds	r3, #4
    4f4a:	0018      	movs	r0, r3
    4f4c:	4b1f      	ldr	r3, [pc, #124]	; (4fcc <prvAddCurrentTaskToDelayedList+0x98>)
    4f4e:	4798      	blx	r3
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    4f50:	687b      	ldr	r3, [r7, #4]
    4f52:	3301      	adds	r3, #1
    4f54:	d10b      	bne.n	4f6e <prvAddCurrentTaskToDelayedList+0x3a>
    4f56:	683b      	ldr	r3, [r7, #0]
    4f58:	2b00      	cmp	r3, #0
    4f5a:	d008      	beq.n	4f6e <prvAddCurrentTaskToDelayedList+0x3a>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    4f5c:	4b1a      	ldr	r3, [pc, #104]	; (4fc8 <prvAddCurrentTaskToDelayedList+0x94>)
    4f5e:	681b      	ldr	r3, [r3, #0]
    4f60:	1d1a      	adds	r2, r3, #4
    4f62:	4b1b      	ldr	r3, [pc, #108]	; (4fd0 <prvAddCurrentTaskToDelayedList+0x9c>)
    4f64:	0011      	movs	r1, r2
    4f66:	0018      	movs	r0, r3
    4f68:	4b1a      	ldr	r3, [pc, #104]	; (4fd4 <prvAddCurrentTaskToDelayedList+0xa0>)
    4f6a:	4798      	blx	r3

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    4f6c:	e026      	b.n	4fbc <prvAddCurrentTaskToDelayedList+0x88>
			xTimeToWake = xConstTickCount + xTicksToWait;
    4f6e:	68fa      	ldr	r2, [r7, #12]
    4f70:	687b      	ldr	r3, [r7, #4]
    4f72:	18d3      	adds	r3, r2, r3
    4f74:	60bb      	str	r3, [r7, #8]
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    4f76:	4b14      	ldr	r3, [pc, #80]	; (4fc8 <prvAddCurrentTaskToDelayedList+0x94>)
    4f78:	681b      	ldr	r3, [r3, #0]
    4f7a:	68ba      	ldr	r2, [r7, #8]
    4f7c:	605a      	str	r2, [r3, #4]
			if( xTimeToWake < xConstTickCount )
    4f7e:	68ba      	ldr	r2, [r7, #8]
    4f80:	68fb      	ldr	r3, [r7, #12]
    4f82:	429a      	cmp	r2, r3
    4f84:	d209      	bcs.n	4f9a <prvAddCurrentTaskToDelayedList+0x66>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    4f86:	4b14      	ldr	r3, [pc, #80]	; (4fd8 <prvAddCurrentTaskToDelayedList+0xa4>)
    4f88:	681a      	ldr	r2, [r3, #0]
    4f8a:	4b0f      	ldr	r3, [pc, #60]	; (4fc8 <prvAddCurrentTaskToDelayedList+0x94>)
    4f8c:	681b      	ldr	r3, [r3, #0]
    4f8e:	3304      	adds	r3, #4
    4f90:	0019      	movs	r1, r3
    4f92:	0010      	movs	r0, r2
    4f94:	4b11      	ldr	r3, [pc, #68]	; (4fdc <prvAddCurrentTaskToDelayedList+0xa8>)
    4f96:	4798      	blx	r3
}
    4f98:	e010      	b.n	4fbc <prvAddCurrentTaskToDelayedList+0x88>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    4f9a:	4b11      	ldr	r3, [pc, #68]	; (4fe0 <prvAddCurrentTaskToDelayedList+0xac>)
    4f9c:	681a      	ldr	r2, [r3, #0]
    4f9e:	4b0a      	ldr	r3, [pc, #40]	; (4fc8 <prvAddCurrentTaskToDelayedList+0x94>)
    4fa0:	681b      	ldr	r3, [r3, #0]
    4fa2:	3304      	adds	r3, #4
    4fa4:	0019      	movs	r1, r3
    4fa6:	0010      	movs	r0, r2
    4fa8:	4b0c      	ldr	r3, [pc, #48]	; (4fdc <prvAddCurrentTaskToDelayedList+0xa8>)
    4faa:	4798      	blx	r3
				if( xTimeToWake < xNextTaskUnblockTime )
    4fac:	4b0d      	ldr	r3, [pc, #52]	; (4fe4 <prvAddCurrentTaskToDelayedList+0xb0>)
    4fae:	681b      	ldr	r3, [r3, #0]
    4fb0:	68ba      	ldr	r2, [r7, #8]
    4fb2:	429a      	cmp	r2, r3
    4fb4:	d202      	bcs.n	4fbc <prvAddCurrentTaskToDelayedList+0x88>
					xNextTaskUnblockTime = xTimeToWake;
    4fb6:	4b0b      	ldr	r3, [pc, #44]	; (4fe4 <prvAddCurrentTaskToDelayedList+0xb0>)
    4fb8:	68ba      	ldr	r2, [r7, #8]
    4fba:	601a      	str	r2, [r3, #0]
}
    4fbc:	46c0      	nop			; (mov r8, r8)
    4fbe:	46bd      	mov	sp, r7
    4fc0:	b004      	add	sp, #16
    4fc2:	bd80      	pop	{r7, pc}
    4fc4:	20003274 	.word	0x20003274
    4fc8:	20003198 	.word	0x20003198
    4fcc:	00002ed7 	.word	0x00002ed7
    4fd0:	2000325c 	.word	0x2000325c
    4fd4:	00002e27 	.word	0x00002e27
    4fd8:	2000322c 	.word	0x2000322c
    4fdc:	00002e6b 	.word	0x00002e6b
    4fe0:	20003228 	.word	0x20003228
    4fe4:	20003290 	.word	0x20003290

00004fe8 <xTimerCreateTimerTask>:
									TimerCallbackFunction_t pxCallbackFunction,
									Timer_t *pxNewTimer ) PRIVILEGED_FUNCTION;
/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
    4fe8:	b590      	push	{r4, r7, lr}
    4fea:	b085      	sub	sp, #20
    4fec:	af02      	add	r7, sp, #8
BaseType_t xReturn = pdFAIL;
    4fee:	2300      	movs	r3, #0
    4ff0:	607b      	str	r3, [r7, #4]

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
    4ff2:	4b0e      	ldr	r3, [pc, #56]	; (502c <xTimerCreateTimerTask+0x44>)
    4ff4:	4798      	blx	r3

	if( xTimerQueue != NULL )
    4ff6:	4b0e      	ldr	r3, [pc, #56]	; (5030 <xTimerCreateTimerTask+0x48>)
    4ff8:	681b      	ldr	r3, [r3, #0]
    4ffa:	2b00      	cmp	r3, #0
    4ffc:	d00c      	beq.n	5018 <xTimerCreateTimerTask+0x30>
				xReturn = pdPASS;
			}
		}
		#else
		{
			xReturn = xTaskCreate(	prvTimerTask,
    4ffe:	2382      	movs	r3, #130	; 0x82
    5000:	005a      	lsls	r2, r3, #1
    5002:	490c      	ldr	r1, [pc, #48]	; (5034 <xTimerCreateTimerTask+0x4c>)
    5004:	480c      	ldr	r0, [pc, #48]	; (5038 <xTimerCreateTimerTask+0x50>)
    5006:	4b0d      	ldr	r3, [pc, #52]	; (503c <xTimerCreateTimerTask+0x54>)
    5008:	9301      	str	r3, [sp, #4]
    500a:	2304      	movs	r3, #4
    500c:	9300      	str	r3, [sp, #0]
    500e:	2300      	movs	r3, #0
    5010:	4c0b      	ldr	r4, [pc, #44]	; (5040 <xTimerCreateTimerTask+0x58>)
    5012:	47a0      	blx	r4
    5014:	0003      	movs	r3, r0
    5016:	607b      	str	r3, [r7, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
    5018:	687b      	ldr	r3, [r7, #4]
    501a:	2b00      	cmp	r3, #0
    501c:	d101      	bne.n	5022 <xTimerCreateTimerTask+0x3a>
    501e:	b672      	cpsid	i
    5020:	e7fe      	b.n	5020 <xTimerCreateTimerTask+0x38>
	return xReturn;
    5022:	687b      	ldr	r3, [r7, #4]
}
    5024:	0018      	movs	r0, r3
    5026:	46bd      	mov	sp, r7
    5028:	b003      	add	sp, #12
    502a:	bd90      	pop	{r4, r7, pc}
    502c:	00005555 	.word	0x00005555
    5030:	200032cc 	.word	0x200032cc
    5034:	00007358 	.word	0x00007358
    5038:	00005169 	.word	0x00005169
    503c:	200032d0 	.word	0x200032d0
    5040:	00003f81 	.word	0x00003f81

00005044 <xTimerGenericCommand>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    5044:	b590      	push	{r4, r7, lr}
    5046:	b08b      	sub	sp, #44	; 0x2c
    5048:	af00      	add	r7, sp, #0
    504a:	60f8      	str	r0, [r7, #12]
    504c:	60b9      	str	r1, [r7, #8]
    504e:	607a      	str	r2, [r7, #4]
    5050:	603b      	str	r3, [r7, #0]
BaseType_t xReturn = pdFAIL;
    5052:	2300      	movs	r3, #0
    5054:	627b      	str	r3, [r7, #36]	; 0x24
DaemonTaskMessage_t xMessage;

	configASSERT( xTimer );
    5056:	68fb      	ldr	r3, [r7, #12]
    5058:	2b00      	cmp	r3, #0
    505a:	d101      	bne.n	5060 <xTimerGenericCommand+0x1c>
    505c:	b672      	cpsid	i
    505e:	e7fe      	b.n	505e <xTimerGenericCommand+0x1a>

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
    5060:	4b1e      	ldr	r3, [pc, #120]	; (50dc <xTimerGenericCommand+0x98>)
    5062:	681b      	ldr	r3, [r3, #0]
    5064:	2b00      	cmp	r3, #0
    5066:	d033      	beq.n	50d0 <xTimerGenericCommand+0x8c>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
    5068:	2314      	movs	r3, #20
    506a:	18fb      	adds	r3, r7, r3
    506c:	68ba      	ldr	r2, [r7, #8]
    506e:	601a      	str	r2, [r3, #0]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    5070:	2314      	movs	r3, #20
    5072:	18fb      	adds	r3, r7, r3
    5074:	687a      	ldr	r2, [r7, #4]
    5076:	605a      	str	r2, [r3, #4]
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    5078:	2314      	movs	r3, #20
    507a:	18fb      	adds	r3, r7, r3
    507c:	68fa      	ldr	r2, [r7, #12]
    507e:	609a      	str	r2, [r3, #8]

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    5080:	68bb      	ldr	r3, [r7, #8]
    5082:	2b05      	cmp	r3, #5
    5084:	dc1a      	bgt.n	50bc <xTimerGenericCommand+0x78>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    5086:	4b16      	ldr	r3, [pc, #88]	; (50e0 <xTimerGenericCommand+0x9c>)
    5088:	4798      	blx	r3
    508a:	0003      	movs	r3, r0
    508c:	2b02      	cmp	r3, #2
    508e:	d10a      	bne.n	50a6 <xTimerGenericCommand+0x62>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    5090:	4b12      	ldr	r3, [pc, #72]	; (50dc <xTimerGenericCommand+0x98>)
    5092:	6818      	ldr	r0, [r3, #0]
    5094:	6bba      	ldr	r2, [r7, #56]	; 0x38
    5096:	2314      	movs	r3, #20
    5098:	18f9      	adds	r1, r7, r3
    509a:	2300      	movs	r3, #0
    509c:	4c11      	ldr	r4, [pc, #68]	; (50e4 <xTimerGenericCommand+0xa0>)
    509e:	47a0      	blx	r4
    50a0:	0003      	movs	r3, r0
    50a2:	627b      	str	r3, [r7, #36]	; 0x24
    50a4:	e014      	b.n	50d0 <xTimerGenericCommand+0x8c>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    50a6:	4b0d      	ldr	r3, [pc, #52]	; (50dc <xTimerGenericCommand+0x98>)
    50a8:	6818      	ldr	r0, [r3, #0]
    50aa:	2314      	movs	r3, #20
    50ac:	18f9      	adds	r1, r7, r3
    50ae:	2300      	movs	r3, #0
    50b0:	2200      	movs	r2, #0
    50b2:	4c0c      	ldr	r4, [pc, #48]	; (50e4 <xTimerGenericCommand+0xa0>)
    50b4:	47a0      	blx	r4
    50b6:	0003      	movs	r3, r0
    50b8:	627b      	str	r3, [r7, #36]	; 0x24
    50ba:	e009      	b.n	50d0 <xTimerGenericCommand+0x8c>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    50bc:	4b07      	ldr	r3, [pc, #28]	; (50dc <xTimerGenericCommand+0x98>)
    50be:	6818      	ldr	r0, [r3, #0]
    50c0:	683a      	ldr	r2, [r7, #0]
    50c2:	2314      	movs	r3, #20
    50c4:	18f9      	adds	r1, r7, r3
    50c6:	2300      	movs	r3, #0
    50c8:	4c07      	ldr	r4, [pc, #28]	; (50e8 <xTimerGenericCommand+0xa4>)
    50ca:	47a0      	blx	r4
    50cc:	0003      	movs	r3, r0
    50ce:	627b      	str	r3, [r7, #36]	; 0x24
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
    50d0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
    50d2:	0018      	movs	r0, r3
    50d4:	46bd      	mov	sp, r7
    50d6:	b00b      	add	sp, #44	; 0x2c
    50d8:	bd90      	pop	{r4, r7, pc}
    50da:	46c0      	nop			; (mov r8, r8)
    50dc:	200032cc 	.word	0x200032cc
    50e0:	00004aad 	.word	0x00004aad
    50e4:	000033c9 	.word	0x000033c9
    50e8:	000035a9 	.word	0x000035a9

000050ec <prvProcessExpiredTimer>:
	return pxTimer->pcTimerName;
}
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
    50ec:	b590      	push	{r4, r7, lr}
    50ee:	b087      	sub	sp, #28
    50f0:	af02      	add	r7, sp, #8
    50f2:	6078      	str	r0, [r7, #4]
    50f4:	6039      	str	r1, [r7, #0]
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    50f6:	4b18      	ldr	r3, [pc, #96]	; (5158 <prvProcessExpiredTimer+0x6c>)
    50f8:	681b      	ldr	r3, [r3, #0]
    50fa:	68db      	ldr	r3, [r3, #12]
    50fc:	68db      	ldr	r3, [r3, #12]
    50fe:	60fb      	str	r3, [r7, #12]

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    5100:	68fb      	ldr	r3, [r7, #12]
    5102:	3304      	adds	r3, #4
    5104:	0018      	movs	r0, r3
    5106:	4b15      	ldr	r3, [pc, #84]	; (515c <prvProcessExpiredTimer+0x70>)
    5108:	4798      	blx	r3
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    510a:	68fb      	ldr	r3, [r7, #12]
    510c:	69db      	ldr	r3, [r3, #28]
    510e:	2b01      	cmp	r3, #1
    5110:	d119      	bne.n	5146 <prvProcessExpiredTimer+0x5a>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    5112:	68fb      	ldr	r3, [r7, #12]
    5114:	699a      	ldr	r2, [r3, #24]
    5116:	687b      	ldr	r3, [r7, #4]
    5118:	18d1      	adds	r1, r2, r3
    511a:	687b      	ldr	r3, [r7, #4]
    511c:	683a      	ldr	r2, [r7, #0]
    511e:	68f8      	ldr	r0, [r7, #12]
    5120:	4c0f      	ldr	r4, [pc, #60]	; (5160 <prvProcessExpiredTimer+0x74>)
    5122:	47a0      	blx	r4
    5124:	1e03      	subs	r3, r0, #0
    5126:	d00e      	beq.n	5146 <prvProcessExpiredTimer+0x5a>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    5128:	687a      	ldr	r2, [r7, #4]
    512a:	68f8      	ldr	r0, [r7, #12]
    512c:	2300      	movs	r3, #0
    512e:	9300      	str	r3, [sp, #0]
    5130:	2300      	movs	r3, #0
    5132:	2100      	movs	r1, #0
    5134:	4c0b      	ldr	r4, [pc, #44]	; (5164 <prvProcessExpiredTimer+0x78>)
    5136:	47a0      	blx	r4
    5138:	0003      	movs	r3, r0
    513a:	60bb      	str	r3, [r7, #8]
			configASSERT( xResult );
    513c:	68bb      	ldr	r3, [r7, #8]
    513e:	2b00      	cmp	r3, #0
    5140:	d101      	bne.n	5146 <prvProcessExpiredTimer+0x5a>
    5142:	b672      	cpsid	i
    5144:	e7fe      	b.n	5144 <prvProcessExpiredTimer+0x58>
	{
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    5146:	68fb      	ldr	r3, [r7, #12]
    5148:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    514a:	68fa      	ldr	r2, [r7, #12]
    514c:	0010      	movs	r0, r2
    514e:	4798      	blx	r3
}
    5150:	46c0      	nop			; (mov r8, r8)
    5152:	46bd      	mov	sp, r7
    5154:	b005      	add	sp, #20
    5156:	bd90      	pop	{r4, r7, pc}
    5158:	200032c4 	.word	0x200032c4
    515c:	00002ed7 	.word	0x00002ed7
    5160:	000052c9 	.word	0x000052c9
    5164:	00005045 	.word	0x00005045

00005168 <prvTimerTask>:
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    5168:	b580      	push	{r7, lr}
    516a:	b084      	sub	sp, #16
    516c:	af00      	add	r7, sp, #0
    516e:	6078      	str	r0, [r7, #4]

	for( ;; )
	{
		/* Query the timers list to see if it contains any timers, and if so,
		obtain the time at which the next timer will expire. */
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
    5170:	2308      	movs	r3, #8
    5172:	18fb      	adds	r3, r7, r3
    5174:	0018      	movs	r0, r3
    5176:	4b06      	ldr	r3, [pc, #24]	; (5190 <prvTimerTask+0x28>)
    5178:	4798      	blx	r3
    517a:	0003      	movs	r3, r0
    517c:	60fb      	str	r3, [r7, #12]

		/* If a timer has expired, process it.  Otherwise, block this task
		until either a timer does expire, or a command is received. */
		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
    517e:	68ba      	ldr	r2, [r7, #8]
    5180:	68fb      	ldr	r3, [r7, #12]
    5182:	0011      	movs	r1, r2
    5184:	0018      	movs	r0, r3
    5186:	4b03      	ldr	r3, [pc, #12]	; (5194 <prvTimerTask+0x2c>)
    5188:	4798      	blx	r3

		/* Empty the command queue. */
		prvProcessReceivedCommands();
    518a:	4b03      	ldr	r3, [pc, #12]	; (5198 <prvTimerTask+0x30>)
    518c:	4798      	blx	r3
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
    518e:	e7ef      	b.n	5170 <prvTimerTask+0x8>
    5190:	00005241 	.word	0x00005241
    5194:	0000519d 	.word	0x0000519d
    5198:	00005351 	.word	0x00005351

0000519c <prvProcessTimerOrBlockTask>:
	}
}
/*-----------------------------------------------------------*/

static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
    519c:	b580      	push	{r7, lr}
    519e:	b084      	sub	sp, #16
    51a0:	af00      	add	r7, sp, #0
    51a2:	6078      	str	r0, [r7, #4]
    51a4:	6039      	str	r1, [r7, #0]
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    51a6:	4b1e      	ldr	r3, [pc, #120]	; (5220 <prvProcessTimerOrBlockTask+0x84>)
    51a8:	4798      	blx	r3
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    51aa:	2308      	movs	r3, #8
    51ac:	18fb      	adds	r3, r7, r3
    51ae:	0018      	movs	r0, r3
    51b0:	4b1c      	ldr	r3, [pc, #112]	; (5224 <prvProcessTimerOrBlockTask+0x88>)
    51b2:	4798      	blx	r3
    51b4:	0003      	movs	r3, r0
    51b6:	60fb      	str	r3, [r7, #12]
		if( xTimerListsWereSwitched == pdFALSE )
    51b8:	68bb      	ldr	r3, [r7, #8]
    51ba:	2b00      	cmp	r3, #0
    51bc:	d129      	bne.n	5212 <prvProcessTimerOrBlockTask+0x76>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    51be:	683b      	ldr	r3, [r7, #0]
    51c0:	2b00      	cmp	r3, #0
    51c2:	d10c      	bne.n	51de <prvProcessTimerOrBlockTask+0x42>
    51c4:	687a      	ldr	r2, [r7, #4]
    51c6:	68fb      	ldr	r3, [r7, #12]
    51c8:	429a      	cmp	r2, r3
    51ca:	d808      	bhi.n	51de <prvProcessTimerOrBlockTask+0x42>
			{
				( void ) xTaskResumeAll();
    51cc:	4b16      	ldr	r3, [pc, #88]	; (5228 <prvProcessTimerOrBlockTask+0x8c>)
    51ce:	4798      	blx	r3
				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
    51d0:	68fa      	ldr	r2, [r7, #12]
    51d2:	687b      	ldr	r3, [r7, #4]
    51d4:	0011      	movs	r1, r2
    51d6:	0018      	movs	r0, r3
    51d8:	4b14      	ldr	r3, [pc, #80]	; (522c <prvProcessTimerOrBlockTask+0x90>)
    51da:	4798      	blx	r3
		else
		{
			( void ) xTaskResumeAll();
		}
	}
}
    51dc:	e01b      	b.n	5216 <prvProcessTimerOrBlockTask+0x7a>
				if( xListWasEmpty != pdFALSE )
    51de:	683b      	ldr	r3, [r7, #0]
    51e0:	2b00      	cmp	r3, #0
    51e2:	d006      	beq.n	51f2 <prvProcessTimerOrBlockTask+0x56>
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    51e4:	4b12      	ldr	r3, [pc, #72]	; (5230 <prvProcessTimerOrBlockTask+0x94>)
    51e6:	681b      	ldr	r3, [r3, #0]
    51e8:	681b      	ldr	r3, [r3, #0]
    51ea:	425a      	negs	r2, r3
    51ec:	4153      	adcs	r3, r2
    51ee:	b2db      	uxtb	r3, r3
    51f0:	603b      	str	r3, [r7, #0]
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    51f2:	4b10      	ldr	r3, [pc, #64]	; (5234 <prvProcessTimerOrBlockTask+0x98>)
    51f4:	6818      	ldr	r0, [r3, #0]
    51f6:	687a      	ldr	r2, [r7, #4]
    51f8:	68fb      	ldr	r3, [r7, #12]
    51fa:	1ad3      	subs	r3, r2, r3
    51fc:	683a      	ldr	r2, [r7, #0]
    51fe:	0019      	movs	r1, r3
    5200:	4b0d      	ldr	r3, [pc, #52]	; (5238 <prvProcessTimerOrBlockTask+0x9c>)
    5202:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
    5204:	4b08      	ldr	r3, [pc, #32]	; (5228 <prvProcessTimerOrBlockTask+0x8c>)
    5206:	4798      	blx	r3
    5208:	1e03      	subs	r3, r0, #0
    520a:	d104      	bne.n	5216 <prvProcessTimerOrBlockTask+0x7a>
					portYIELD_WITHIN_API();
    520c:	4b0b      	ldr	r3, [pc, #44]	; (523c <prvProcessTimerOrBlockTask+0xa0>)
    520e:	4798      	blx	r3
}
    5210:	e001      	b.n	5216 <prvProcessTimerOrBlockTask+0x7a>
			( void ) xTaskResumeAll();
    5212:	4b05      	ldr	r3, [pc, #20]	; (5228 <prvProcessTimerOrBlockTask+0x8c>)
    5214:	4798      	blx	r3
}
    5216:	46c0      	nop			; (mov r8, r8)
    5218:	46bd      	mov	sp, r7
    521a:	b004      	add	sp, #16
    521c:	bd80      	pop	{r7, pc}
    521e:	46c0      	nop			; (mov r8, r8)
    5220:	000042f5 	.word	0x000042f5
    5224:	00005281 	.word	0x00005281
    5228:	0000430d 	.word	0x0000430d
    522c:	000050ed 	.word	0x000050ed
    5230:	200032c8 	.word	0x200032c8
    5234:	200032cc 	.word	0x200032cc
    5238:	00003e65 	.word	0x00003e65
    523c:	00003041 	.word	0x00003041

00005240 <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
{
    5240:	b580      	push	{r7, lr}
    5242:	b084      	sub	sp, #16
    5244:	af00      	add	r7, sp, #0
    5246:	6078      	str	r0, [r7, #4]
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    5248:	4b0c      	ldr	r3, [pc, #48]	; (527c <prvGetNextExpireTime+0x3c>)
    524a:	681b      	ldr	r3, [r3, #0]
    524c:	681b      	ldr	r3, [r3, #0]
    524e:	425a      	negs	r2, r3
    5250:	4153      	adcs	r3, r2
    5252:	b2db      	uxtb	r3, r3
    5254:	001a      	movs	r2, r3
    5256:	687b      	ldr	r3, [r7, #4]
    5258:	601a      	str	r2, [r3, #0]
	if( *pxListWasEmpty == pdFALSE )
    525a:	687b      	ldr	r3, [r7, #4]
    525c:	681b      	ldr	r3, [r3, #0]
    525e:	2b00      	cmp	r3, #0
    5260:	d105      	bne.n	526e <prvGetNextExpireTime+0x2e>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    5262:	4b06      	ldr	r3, [pc, #24]	; (527c <prvGetNextExpireTime+0x3c>)
    5264:	681b      	ldr	r3, [r3, #0]
    5266:	68db      	ldr	r3, [r3, #12]
    5268:	681b      	ldr	r3, [r3, #0]
    526a:	60fb      	str	r3, [r7, #12]
    526c:	e001      	b.n	5272 <prvGetNextExpireTime+0x32>
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    526e:	2300      	movs	r3, #0
    5270:	60fb      	str	r3, [r7, #12]
	}

	return xNextExpireTime;
    5272:	68fb      	ldr	r3, [r7, #12]
}
    5274:	0018      	movs	r0, r3
    5276:	46bd      	mov	sp, r7
    5278:	b004      	add	sp, #16
    527a:	bd80      	pop	{r7, pc}
    527c:	200032c4 	.word	0x200032c4

00005280 <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    5280:	b580      	push	{r7, lr}
    5282:	b084      	sub	sp, #16
    5284:	af00      	add	r7, sp, #0
    5286:	6078      	str	r0, [r7, #4]
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
    5288:	4b0c      	ldr	r3, [pc, #48]	; (52bc <prvSampleTimeNow+0x3c>)
    528a:	4798      	blx	r3
    528c:	0003      	movs	r3, r0
    528e:	60fb      	str	r3, [r7, #12]

	if( xTimeNow < xLastTime )
    5290:	4b0b      	ldr	r3, [pc, #44]	; (52c0 <prvSampleTimeNow+0x40>)
    5292:	681b      	ldr	r3, [r3, #0]
    5294:	68fa      	ldr	r2, [r7, #12]
    5296:	429a      	cmp	r2, r3
    5298:	d205      	bcs.n	52a6 <prvSampleTimeNow+0x26>
	{
		prvSwitchTimerLists();
    529a:	4b0a      	ldr	r3, [pc, #40]	; (52c4 <prvSampleTimeNow+0x44>)
    529c:	4798      	blx	r3
		*pxTimerListsWereSwitched = pdTRUE;
    529e:	687b      	ldr	r3, [r7, #4]
    52a0:	2201      	movs	r2, #1
    52a2:	601a      	str	r2, [r3, #0]
    52a4:	e002      	b.n	52ac <prvSampleTimeNow+0x2c>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    52a6:	687b      	ldr	r3, [r7, #4]
    52a8:	2200      	movs	r2, #0
    52aa:	601a      	str	r2, [r3, #0]
	}

	xLastTime = xTimeNow;
    52ac:	4b04      	ldr	r3, [pc, #16]	; (52c0 <prvSampleTimeNow+0x40>)
    52ae:	68fa      	ldr	r2, [r7, #12]
    52b0:	601a      	str	r2, [r3, #0]

	return xTimeNow;
    52b2:	68fb      	ldr	r3, [r7, #12]
}
    52b4:	0018      	movs	r0, r3
    52b6:	46bd      	mov	sp, r7
    52b8:	b004      	add	sp, #16
    52ba:	bd80      	pop	{r7, pc}
    52bc:	00004441 	.word	0x00004441
    52c0:	200032d4 	.word	0x200032d4
    52c4:	00005495 	.word	0x00005495

000052c8 <prvInsertTimerInActiveList>:
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
    52c8:	b580      	push	{r7, lr}
    52ca:	b086      	sub	sp, #24
    52cc:	af00      	add	r7, sp, #0
    52ce:	60f8      	str	r0, [r7, #12]
    52d0:	60b9      	str	r1, [r7, #8]
    52d2:	607a      	str	r2, [r7, #4]
    52d4:	603b      	str	r3, [r7, #0]
BaseType_t xProcessTimerNow = pdFALSE;
    52d6:	2300      	movs	r3, #0
    52d8:	617b      	str	r3, [r7, #20]

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    52da:	68fb      	ldr	r3, [r7, #12]
    52dc:	68ba      	ldr	r2, [r7, #8]
    52de:	605a      	str	r2, [r3, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    52e0:	68fb      	ldr	r3, [r7, #12]
    52e2:	68fa      	ldr	r2, [r7, #12]
    52e4:	611a      	str	r2, [r3, #16]

	if( xNextExpiryTime <= xTimeNow )
    52e6:	68ba      	ldr	r2, [r7, #8]
    52e8:	687b      	ldr	r3, [r7, #4]
    52ea:	429a      	cmp	r2, r3
    52ec:	d812      	bhi.n	5314 <prvInsertTimerInActiveList+0x4c>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    52ee:	687a      	ldr	r2, [r7, #4]
    52f0:	683b      	ldr	r3, [r7, #0]
    52f2:	1ad2      	subs	r2, r2, r3
    52f4:	68fb      	ldr	r3, [r7, #12]
    52f6:	699b      	ldr	r3, [r3, #24]
    52f8:	429a      	cmp	r2, r3
    52fa:	d302      	bcc.n	5302 <prvInsertTimerInActiveList+0x3a>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
    52fc:	2301      	movs	r3, #1
    52fe:	617b      	str	r3, [r7, #20]
    5300:	e01b      	b.n	533a <prvInsertTimerInActiveList+0x72>
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    5302:	4b10      	ldr	r3, [pc, #64]	; (5344 <prvInsertTimerInActiveList+0x7c>)
    5304:	681a      	ldr	r2, [r3, #0]
    5306:	68fb      	ldr	r3, [r7, #12]
    5308:	3304      	adds	r3, #4
    530a:	0019      	movs	r1, r3
    530c:	0010      	movs	r0, r2
    530e:	4b0e      	ldr	r3, [pc, #56]	; (5348 <prvInsertTimerInActiveList+0x80>)
    5310:	4798      	blx	r3
    5312:	e012      	b.n	533a <prvInsertTimerInActiveList+0x72>
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    5314:	687a      	ldr	r2, [r7, #4]
    5316:	683b      	ldr	r3, [r7, #0]
    5318:	429a      	cmp	r2, r3
    531a:	d206      	bcs.n	532a <prvInsertTimerInActiveList+0x62>
    531c:	68ba      	ldr	r2, [r7, #8]
    531e:	683b      	ldr	r3, [r7, #0]
    5320:	429a      	cmp	r2, r3
    5322:	d302      	bcc.n	532a <prvInsertTimerInActiveList+0x62>
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
    5324:	2301      	movs	r3, #1
    5326:	617b      	str	r3, [r7, #20]
    5328:	e007      	b.n	533a <prvInsertTimerInActiveList+0x72>
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    532a:	4b08      	ldr	r3, [pc, #32]	; (534c <prvInsertTimerInActiveList+0x84>)
    532c:	681a      	ldr	r2, [r3, #0]
    532e:	68fb      	ldr	r3, [r7, #12]
    5330:	3304      	adds	r3, #4
    5332:	0019      	movs	r1, r3
    5334:	0010      	movs	r0, r2
    5336:	4b04      	ldr	r3, [pc, #16]	; (5348 <prvInsertTimerInActiveList+0x80>)
    5338:	4798      	blx	r3
		}
	}

	return xProcessTimerNow;
    533a:	697b      	ldr	r3, [r7, #20]
}
    533c:	0018      	movs	r0, r3
    533e:	46bd      	mov	sp, r7
    5340:	b006      	add	sp, #24
    5342:	bd80      	pop	{r7, pc}
    5344:	200032c8 	.word	0x200032c8
    5348:	00002e6b 	.word	0x00002e6b
    534c:	200032c4 	.word	0x200032c4

00005350 <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

static void	prvProcessReceivedCommands( void )
{
    5350:	b590      	push	{r4, r7, lr}
    5352:	b08d      	sub	sp, #52	; 0x34
    5354:	af02      	add	r7, sp, #8
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    5356:	e07e      	b.n	5456 <prvProcessReceivedCommands+0x106>
	{
		#if ( INCLUDE_xTimerPendFunctionCall == 1 )
		{
			/* Negative commands are pended function calls rather than timer
			commands. */
			if( xMessage.xMessageID < ( BaseType_t ) 0 )
    5358:	2308      	movs	r3, #8
    535a:	18fb      	adds	r3, r7, r3
    535c:	681b      	ldr	r3, [r3, #0]
    535e:	2b00      	cmp	r3, #0
    5360:	da10      	bge.n	5384 <prvProcessReceivedCommands+0x34>
			{
				const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackParameters );
    5362:	2308      	movs	r3, #8
    5364:	18fb      	adds	r3, r7, r3
    5366:	3304      	adds	r3, #4
    5368:	627b      	str	r3, [r7, #36]	; 0x24

				/* The timer uses the xCallbackParameters member to request a
				callback be executed.  Check the callback is not NULL. */
				configASSERT( pxCallback );
    536a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    536c:	2b00      	cmp	r3, #0
    536e:	d101      	bne.n	5374 <prvProcessReceivedCommands+0x24>
    5370:	b672      	cpsid	i
    5372:	e7fe      	b.n	5372 <prvProcessReceivedCommands+0x22>

				/* Call the function. */
				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
    5374:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    5376:	681a      	ldr	r2, [r3, #0]
    5378:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    537a:	6858      	ldr	r0, [r3, #4]
    537c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    537e:	689b      	ldr	r3, [r3, #8]
    5380:	0019      	movs	r1, r3
    5382:	4790      	blx	r2
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    5384:	2308      	movs	r3, #8
    5386:	18fb      	adds	r3, r7, r3
    5388:	681b      	ldr	r3, [r3, #0]
    538a:	2b00      	cmp	r3, #0
    538c:	db63      	blt.n	5456 <prvProcessReceivedCommands+0x106>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    538e:	2308      	movs	r3, #8
    5390:	18fb      	adds	r3, r7, r3
    5392:	689b      	ldr	r3, [r3, #8]
    5394:	623b      	str	r3, [r7, #32]

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    5396:	6a3b      	ldr	r3, [r7, #32]
    5398:	695b      	ldr	r3, [r3, #20]
    539a:	2b00      	cmp	r3, #0
    539c:	d004      	beq.n	53a8 <prvProcessReceivedCommands+0x58>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    539e:	6a3b      	ldr	r3, [r7, #32]
    53a0:	3304      	adds	r3, #4
    53a2:	0018      	movs	r0, r3
    53a4:	4b33      	ldr	r3, [pc, #204]	; (5474 <prvProcessReceivedCommands+0x124>)
    53a6:	4798      	blx	r3
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    53a8:	1d3b      	adds	r3, r7, #4
    53aa:	0018      	movs	r0, r3
    53ac:	4b32      	ldr	r3, [pc, #200]	; (5478 <prvProcessReceivedCommands+0x128>)
    53ae:	4798      	blx	r3
    53b0:	0003      	movs	r3, r0
    53b2:	61fb      	str	r3, [r7, #28]

			switch( xMessage.xMessageID )
    53b4:	2308      	movs	r3, #8
    53b6:	18fb      	adds	r3, r7, r3
    53b8:	681b      	ldr	r3, [r3, #0]
    53ba:	2b09      	cmp	r3, #9
    53bc:	d84a      	bhi.n	5454 <prvProcessReceivedCommands+0x104>
    53be:	009a      	lsls	r2, r3, #2
    53c0:	4b2e      	ldr	r3, [pc, #184]	; (547c <prvProcessReceivedCommands+0x12c>)
    53c2:	18d3      	adds	r3, r2, r3
    53c4:	681b      	ldr	r3, [r3, #0]
    53c6:	469f      	mov	pc, r3
			    case tmrCOMMAND_START_FROM_ISR :
			    case tmrCOMMAND_RESET :
			    case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    53c8:	2308      	movs	r3, #8
    53ca:	18fb      	adds	r3, r7, r3
    53cc:	685a      	ldr	r2, [r3, #4]
    53ce:	6a3b      	ldr	r3, [r7, #32]
    53d0:	699b      	ldr	r3, [r3, #24]
    53d2:	18d1      	adds	r1, r2, r3
    53d4:	2308      	movs	r3, #8
    53d6:	18fb      	adds	r3, r7, r3
    53d8:	685b      	ldr	r3, [r3, #4]
    53da:	69fa      	ldr	r2, [r7, #28]
    53dc:	6a38      	ldr	r0, [r7, #32]
    53de:	4c28      	ldr	r4, [pc, #160]	; (5480 <prvProcessReceivedCommands+0x130>)
    53e0:	47a0      	blx	r4
    53e2:	1e03      	subs	r3, r0, #0
    53e4:	d037      	beq.n	5456 <prvProcessReceivedCommands+0x106>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    53e6:	6a3b      	ldr	r3, [r7, #32]
    53e8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    53ea:	6a3a      	ldr	r2, [r7, #32]
    53ec:	0010      	movs	r0, r2
    53ee:	4798      	blx	r3
						traceTIMER_EXPIRED( pxTimer );

						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    53f0:	6a3b      	ldr	r3, [r7, #32]
    53f2:	69db      	ldr	r3, [r3, #28]
    53f4:	2b01      	cmp	r3, #1
    53f6:	d12e      	bne.n	5456 <prvProcessReceivedCommands+0x106>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    53f8:	2308      	movs	r3, #8
    53fa:	18fb      	adds	r3, r7, r3
    53fc:	685a      	ldr	r2, [r3, #4]
    53fe:	6a3b      	ldr	r3, [r7, #32]
    5400:	699b      	ldr	r3, [r3, #24]
    5402:	18d2      	adds	r2, r2, r3
    5404:	6a38      	ldr	r0, [r7, #32]
    5406:	2300      	movs	r3, #0
    5408:	9300      	str	r3, [sp, #0]
    540a:	2300      	movs	r3, #0
    540c:	2100      	movs	r1, #0
    540e:	4c1d      	ldr	r4, [pc, #116]	; (5484 <prvProcessReceivedCommands+0x134>)
    5410:	47a0      	blx	r4
    5412:	0003      	movs	r3, r0
    5414:	61bb      	str	r3, [r7, #24]
							configASSERT( xResult );
    5416:	69bb      	ldr	r3, [r7, #24]
    5418:	2b00      	cmp	r3, #0
    541a:	d11c      	bne.n	5456 <prvProcessReceivedCommands+0x106>
    541c:	b672      	cpsid	i
    541e:	e7fe      	b.n	541e <prvProcessReceivedCommands+0xce>
					There is nothing to do here. */
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    5420:	2308      	movs	r3, #8
    5422:	18fb      	adds	r3, r7, r3
    5424:	685a      	ldr	r2, [r3, #4]
    5426:	6a3b      	ldr	r3, [r7, #32]
    5428:	619a      	str	r2, [r3, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
    542a:	6a3b      	ldr	r3, [r7, #32]
    542c:	699b      	ldr	r3, [r3, #24]
    542e:	2b00      	cmp	r3, #0
    5430:	d101      	bne.n	5436 <prvProcessReceivedCommands+0xe6>
    5432:	b672      	cpsid	i
    5434:	e7fe      	b.n	5434 <prvProcessReceivedCommands+0xe4>
					be longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot
					be zero the next expiry time can only be in the future,
					meaning (unlike for the xTimerStart() case above) there is
					no fail case that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    5436:	6a3b      	ldr	r3, [r7, #32]
    5438:	699a      	ldr	r2, [r3, #24]
    543a:	69fb      	ldr	r3, [r7, #28]
    543c:	18d1      	adds	r1, r2, r3
    543e:	69fb      	ldr	r3, [r7, #28]
    5440:	69fa      	ldr	r2, [r7, #28]
    5442:	6a38      	ldr	r0, [r7, #32]
    5444:	4c0e      	ldr	r4, [pc, #56]	; (5480 <prvProcessReceivedCommands+0x130>)
    5446:	47a0      	blx	r4
					break;
    5448:	e005      	b.n	5456 <prvProcessReceivedCommands+0x106>
					allocated. */
					#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
					{
						/* The timer can only have been allocated dynamically -
						free it again. */
						vPortFree( pxTimer );
    544a:	6a3b      	ldr	r3, [r7, #32]
    544c:	0018      	movs	r0, r3
    544e:	4b0e      	ldr	r3, [pc, #56]	; (5488 <prvProcessReceivedCommands+0x138>)
    5450:	4798      	blx	r3
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
					break;
    5452:	e000      	b.n	5456 <prvProcessReceivedCommands+0x106>

				default	:
					/* Don't expect to get here. */
					break;
    5454:	46c0      	nop			; (mov r8, r8)
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    5456:	4b0d      	ldr	r3, [pc, #52]	; (548c <prvProcessReceivedCommands+0x13c>)
    5458:	681b      	ldr	r3, [r3, #0]
    545a:	2208      	movs	r2, #8
    545c:	18b9      	adds	r1, r7, r2
    545e:	2200      	movs	r2, #0
    5460:	0018      	movs	r0, r3
    5462:	4b0b      	ldr	r3, [pc, #44]	; (5490 <prvProcessReceivedCommands+0x140>)
    5464:	4798      	blx	r3
    5466:	1e03      	subs	r3, r0, #0
    5468:	d000      	beq.n	546c <prvProcessReceivedCommands+0x11c>
    546a:	e775      	b.n	5358 <prvProcessReceivedCommands+0x8>
			}
		}
	}
}
    546c:	46c0      	nop			; (mov r8, r8)
    546e:	46bd      	mov	sp, r7
    5470:	b00b      	add	sp, #44	; 0x2c
    5472:	bd90      	pop	{r4, r7, pc}
    5474:	00002ed7 	.word	0x00002ed7
    5478:	00005281 	.word	0x00005281
    547c:	00007368 	.word	0x00007368
    5480:	000052c9 	.word	0x000052c9
    5484:	00005045 	.word	0x00005045
    5488:	0000322d 	.word	0x0000322d
    548c:	200032cc 	.word	0x200032cc
    5490:	000037c9 	.word	0x000037c9

00005494 <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( void )
{
    5494:	b590      	push	{r4, r7, lr}
    5496:	b089      	sub	sp, #36	; 0x24
    5498:	af02      	add	r7, sp, #8

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    549a:	e03e      	b.n	551a <prvSwitchTimerLists+0x86>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    549c:	4b28      	ldr	r3, [pc, #160]	; (5540 <prvSwitchTimerLists+0xac>)
    549e:	681b      	ldr	r3, [r3, #0]
    54a0:	68db      	ldr	r3, [r3, #12]
    54a2:	681b      	ldr	r3, [r3, #0]
    54a4:	617b      	str	r3, [r7, #20]

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    54a6:	4b26      	ldr	r3, [pc, #152]	; (5540 <prvSwitchTimerLists+0xac>)
    54a8:	681b      	ldr	r3, [r3, #0]
    54aa:	68db      	ldr	r3, [r3, #12]
    54ac:	68db      	ldr	r3, [r3, #12]
    54ae:	613b      	str	r3, [r7, #16]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    54b0:	693b      	ldr	r3, [r7, #16]
    54b2:	3304      	adds	r3, #4
    54b4:	0018      	movs	r0, r3
    54b6:	4b23      	ldr	r3, [pc, #140]	; (5544 <prvSwitchTimerLists+0xb0>)
    54b8:	4798      	blx	r3
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    54ba:	693b      	ldr	r3, [r7, #16]
    54bc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    54be:	693a      	ldr	r2, [r7, #16]
    54c0:	0010      	movs	r0, r2
    54c2:	4798      	blx	r3

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    54c4:	693b      	ldr	r3, [r7, #16]
    54c6:	69db      	ldr	r3, [r3, #28]
    54c8:	2b01      	cmp	r3, #1
    54ca:	d126      	bne.n	551a <prvSwitchTimerLists+0x86>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    54cc:	693b      	ldr	r3, [r7, #16]
    54ce:	699a      	ldr	r2, [r3, #24]
    54d0:	697b      	ldr	r3, [r7, #20]
    54d2:	18d3      	adds	r3, r2, r3
    54d4:	60fb      	str	r3, [r7, #12]
			if( xReloadTime > xNextExpireTime )
    54d6:	68fa      	ldr	r2, [r7, #12]
    54d8:	697b      	ldr	r3, [r7, #20]
    54da:	429a      	cmp	r2, r3
    54dc:	d90e      	bls.n	54fc <prvSwitchTimerLists+0x68>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    54de:	693b      	ldr	r3, [r7, #16]
    54e0:	68fa      	ldr	r2, [r7, #12]
    54e2:	605a      	str	r2, [r3, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    54e4:	693b      	ldr	r3, [r7, #16]
    54e6:	693a      	ldr	r2, [r7, #16]
    54e8:	611a      	str	r2, [r3, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    54ea:	4b15      	ldr	r3, [pc, #84]	; (5540 <prvSwitchTimerLists+0xac>)
    54ec:	681a      	ldr	r2, [r3, #0]
    54ee:	693b      	ldr	r3, [r7, #16]
    54f0:	3304      	adds	r3, #4
    54f2:	0019      	movs	r1, r3
    54f4:	0010      	movs	r0, r2
    54f6:	4b14      	ldr	r3, [pc, #80]	; (5548 <prvSwitchTimerLists+0xb4>)
    54f8:	4798      	blx	r3
    54fa:	e00e      	b.n	551a <prvSwitchTimerLists+0x86>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    54fc:	697a      	ldr	r2, [r7, #20]
    54fe:	6938      	ldr	r0, [r7, #16]
    5500:	2300      	movs	r3, #0
    5502:	9300      	str	r3, [sp, #0]
    5504:	2300      	movs	r3, #0
    5506:	2100      	movs	r1, #0
    5508:	4c10      	ldr	r4, [pc, #64]	; (554c <prvSwitchTimerLists+0xb8>)
    550a:	47a0      	blx	r4
    550c:	0003      	movs	r3, r0
    550e:	60bb      	str	r3, [r7, #8]
				configASSERT( xResult );
    5510:	68bb      	ldr	r3, [r7, #8]
    5512:	2b00      	cmp	r3, #0
    5514:	d101      	bne.n	551a <prvSwitchTimerLists+0x86>
    5516:	b672      	cpsid	i
    5518:	e7fe      	b.n	5518 <prvSwitchTimerLists+0x84>
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    551a:	4b09      	ldr	r3, [pc, #36]	; (5540 <prvSwitchTimerLists+0xac>)
    551c:	681b      	ldr	r3, [r3, #0]
    551e:	681b      	ldr	r3, [r3, #0]
    5520:	2b00      	cmp	r3, #0
    5522:	d1bb      	bne.n	549c <prvSwitchTimerLists+0x8>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
    5524:	4b06      	ldr	r3, [pc, #24]	; (5540 <prvSwitchTimerLists+0xac>)
    5526:	681b      	ldr	r3, [r3, #0]
    5528:	607b      	str	r3, [r7, #4]
	pxCurrentTimerList = pxOverflowTimerList;
    552a:	4b09      	ldr	r3, [pc, #36]	; (5550 <prvSwitchTimerLists+0xbc>)
    552c:	681a      	ldr	r2, [r3, #0]
    552e:	4b04      	ldr	r3, [pc, #16]	; (5540 <prvSwitchTimerLists+0xac>)
    5530:	601a      	str	r2, [r3, #0]
	pxOverflowTimerList = pxTemp;
    5532:	4b07      	ldr	r3, [pc, #28]	; (5550 <prvSwitchTimerLists+0xbc>)
    5534:	687a      	ldr	r2, [r7, #4]
    5536:	601a      	str	r2, [r3, #0]
}
    5538:	46c0      	nop			; (mov r8, r8)
    553a:	46bd      	mov	sp, r7
    553c:	b007      	add	sp, #28
    553e:	bd90      	pop	{r4, r7, pc}
    5540:	200032c4 	.word	0x200032c4
    5544:	00002ed7 	.word	0x00002ed7
    5548:	00002e6b 	.word	0x00002e6b
    554c:	00005045 	.word	0x00005045
    5550:	200032c8 	.word	0x200032c8

00005554 <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
    5554:	b580      	push	{r7, lr}
    5556:	af00      	add	r7, sp, #0
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
    5558:	4b15      	ldr	r3, [pc, #84]	; (55b0 <prvCheckForValidListAndQueue+0x5c>)
    555a:	4798      	blx	r3
	{
		if( xTimerQueue == NULL )
    555c:	4b15      	ldr	r3, [pc, #84]	; (55b4 <prvCheckForValidListAndQueue+0x60>)
    555e:	681b      	ldr	r3, [r3, #0]
    5560:	2b00      	cmp	r3, #0
    5562:	d120      	bne.n	55a6 <prvCheckForValidListAndQueue+0x52>
		{
			vListInitialise( &xActiveTimerList1 );
    5564:	4b14      	ldr	r3, [pc, #80]	; (55b8 <prvCheckForValidListAndQueue+0x64>)
    5566:	0018      	movs	r0, r3
    5568:	4b14      	ldr	r3, [pc, #80]	; (55bc <prvCheckForValidListAndQueue+0x68>)
    556a:	4798      	blx	r3
			vListInitialise( &xActiveTimerList2 );
    556c:	4b14      	ldr	r3, [pc, #80]	; (55c0 <prvCheckForValidListAndQueue+0x6c>)
    556e:	0018      	movs	r0, r3
    5570:	4b12      	ldr	r3, [pc, #72]	; (55bc <prvCheckForValidListAndQueue+0x68>)
    5572:	4798      	blx	r3
			pxCurrentTimerList = &xActiveTimerList1;
    5574:	4b13      	ldr	r3, [pc, #76]	; (55c4 <prvCheckForValidListAndQueue+0x70>)
    5576:	4a10      	ldr	r2, [pc, #64]	; (55b8 <prvCheckForValidListAndQueue+0x64>)
    5578:	601a      	str	r2, [r3, #0]
			pxOverflowTimerList = &xActiveTimerList2;
    557a:	4b13      	ldr	r3, [pc, #76]	; (55c8 <prvCheckForValidListAndQueue+0x74>)
    557c:	4a10      	ldr	r2, [pc, #64]	; (55c0 <prvCheckForValidListAndQueue+0x6c>)
    557e:	601a      	str	r2, [r3, #0]

				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
			}
			#else
			{
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    5580:	2200      	movs	r2, #0
    5582:	2110      	movs	r1, #16
    5584:	2005      	movs	r0, #5
    5586:	4b11      	ldr	r3, [pc, #68]	; (55cc <prvCheckForValidListAndQueue+0x78>)
    5588:	4798      	blx	r3
    558a:	0002      	movs	r2, r0
    558c:	4b09      	ldr	r3, [pc, #36]	; (55b4 <prvCheckForValidListAndQueue+0x60>)
    558e:	601a      	str	r2, [r3, #0]
			}
			#endif

			#if ( configQUEUE_REGISTRY_SIZE > 0 )
			{
				if( xTimerQueue != NULL )
    5590:	4b08      	ldr	r3, [pc, #32]	; (55b4 <prvCheckForValidListAndQueue+0x60>)
    5592:	681b      	ldr	r3, [r3, #0]
    5594:	2b00      	cmp	r3, #0
    5596:	d006      	beq.n	55a6 <prvCheckForValidListAndQueue+0x52>
				{
					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
    5598:	4b06      	ldr	r3, [pc, #24]	; (55b4 <prvCheckForValidListAndQueue+0x60>)
    559a:	681b      	ldr	r3, [r3, #0]
    559c:	4a0c      	ldr	r2, [pc, #48]	; (55d0 <prvCheckForValidListAndQueue+0x7c>)
    559e:	0011      	movs	r1, r2
    55a0:	0018      	movs	r0, r3
    55a2:	4b0c      	ldr	r3, [pc, #48]	; (55d4 <prvCheckForValidListAndQueue+0x80>)
    55a4:	4798      	blx	r3
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    55a6:	4b0c      	ldr	r3, [pc, #48]	; (55d8 <prvCheckForValidListAndQueue+0x84>)
    55a8:	4798      	blx	r3
}
    55aa:	46c0      	nop			; (mov r8, r8)
    55ac:	46bd      	mov	sp, r7
    55ae:	bd80      	pop	{r7, pc}
    55b0:	00003061 	.word	0x00003061
    55b4:	200032cc 	.word	0x200032cc
    55b8:	2000329c 	.word	0x2000329c
    55bc:	00002dd5 	.word	0x00002dd5
    55c0:	200032b0 	.word	0x200032b0
    55c4:	200032c4 	.word	0x200032c4
    55c8:	200032c8 	.word	0x200032c8
    55cc:	00003305 	.word	0x00003305
    55d0:	00007360 	.word	0x00007360
    55d4:	00003e15 	.word	0x00003e15
    55d8:	00003085 	.word	0x00003085

000055dc <system_pinmux_get_config_defaults>:
{
    55dc:	b580      	push	{r7, lr}
    55de:	b082      	sub	sp, #8
    55e0:	af00      	add	r7, sp, #0
    55e2:	6078      	str	r0, [r7, #4]
	config->mux_position = SYSTEM_PINMUX_GPIO;
    55e4:	687b      	ldr	r3, [r7, #4]
    55e6:	2280      	movs	r2, #128	; 0x80
    55e8:	701a      	strb	r2, [r3, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    55ea:	687b      	ldr	r3, [r7, #4]
    55ec:	2200      	movs	r2, #0
    55ee:	705a      	strb	r2, [r3, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
    55f0:	687b      	ldr	r3, [r7, #4]
    55f2:	2201      	movs	r2, #1
    55f4:	709a      	strb	r2, [r3, #2]
	config->powersave    = false;
    55f6:	687b      	ldr	r3, [r7, #4]
    55f8:	2200      	movs	r2, #0
    55fa:	70da      	strb	r2, [r3, #3]
}
    55fc:	46c0      	nop			; (mov r8, r8)
    55fe:	46bd      	mov	sp, r7
    5600:	b002      	add	sp, #8
    5602:	bd80      	pop	{r7, pc}

00005604 <can_get_config_defaults>:
{
    5604:	b580      	push	{r7, lr}
    5606:	b082      	sub	sp, #8
    5608:	af00      	add	r7, sp, #0
    560a:	6078      	str	r0, [r7, #4]
	config->clock_source = GCLK_GENERATOR_8;
    560c:	687b      	ldr	r3, [r7, #4]
    560e:	2208      	movs	r2, #8
    5610:	701a      	strb	r2, [r3, #0]
	config->run_in_standby = false;
    5612:	687b      	ldr	r3, [r7, #4]
    5614:	2200      	movs	r2, #0
    5616:	705a      	strb	r2, [r3, #1]
	config->watchdog_configuration = 0x00;
    5618:	687b      	ldr	r3, [r7, #4]
    561a:	2200      	movs	r2, #0
    561c:	709a      	strb	r2, [r3, #2]
	config->transmit_pause = true;
    561e:	687b      	ldr	r3, [r7, #4]
    5620:	2201      	movs	r2, #1
    5622:	70da      	strb	r2, [r3, #3]
	config->edge_filtering = true;
    5624:	687b      	ldr	r3, [r7, #4]
    5626:	2201      	movs	r2, #1
    5628:	711a      	strb	r2, [r3, #4]
	config->protocol_exception_handling = true;
    562a:	687b      	ldr	r3, [r7, #4]
    562c:	2201      	movs	r2, #1
    562e:	715a      	strb	r2, [r3, #5]
	config->automatic_retransmission = true;
    5630:	687b      	ldr	r3, [r7, #4]
    5632:	2201      	movs	r2, #1
    5634:	719a      	strb	r2, [r3, #6]
	config->clock_stop_request = false;
    5636:	687b      	ldr	r3, [r7, #4]
    5638:	2200      	movs	r2, #0
    563a:	71da      	strb	r2, [r3, #7]
	config->clock_stop_acknowledge = false;
    563c:	687b      	ldr	r3, [r7, #4]
    563e:	2200      	movs	r2, #0
    5640:	721a      	strb	r2, [r3, #8]
	config->timestamp_prescaler = 0;
    5642:	687b      	ldr	r3, [r7, #4]
    5644:	2200      	movs	r2, #0
    5646:	725a      	strb	r2, [r3, #9]
	config->timeout_period = 0xFFFF;
    5648:	687b      	ldr	r3, [r7, #4]
    564a:	2201      	movs	r2, #1
    564c:	4252      	negs	r2, r2
    564e:	815a      	strh	r2, [r3, #10]
	config->timeout_mode = CAN_TIMEOUT_CONTINUES;
    5650:	687b      	ldr	r3, [r7, #4]
    5652:	2200      	movs	r2, #0
    5654:	731a      	strb	r2, [r3, #12]
	config->timeout_enable = false;
    5656:	687b      	ldr	r3, [r7, #4]
    5658:	2200      	movs	r2, #0
    565a:	735a      	strb	r2, [r3, #13]
	config->tdc_enable = false;
    565c:	687b      	ldr	r3, [r7, #4]
    565e:	2200      	movs	r2, #0
    5660:	739a      	strb	r2, [r3, #14]
	config->delay_compensation_offset = 0;
    5662:	687b      	ldr	r3, [r7, #4]
    5664:	2200      	movs	r2, #0
    5666:	73da      	strb	r2, [r3, #15]
	config->delay_compensation_filter_window_length = 0;
    5668:	687b      	ldr	r3, [r7, #4]
    566a:	2200      	movs	r2, #0
    566c:	741a      	strb	r2, [r3, #16]
	config->nonmatching_frames_action_standard = CAN_NONMATCHING_FRAMES_REJECT;
    566e:	687b      	ldr	r3, [r7, #4]
    5670:	2202      	movs	r2, #2
    5672:	745a      	strb	r2, [r3, #17]
	config->nonmatching_frames_action_extended = CAN_NONMATCHING_FRAMES_REJECT;
    5674:	687b      	ldr	r3, [r7, #4]
    5676:	2202      	movs	r2, #2
    5678:	749a      	strb	r2, [r3, #18]
	config->remote_frames_standard_reject = true;
    567a:	687b      	ldr	r3, [r7, #4]
    567c:	2201      	movs	r2, #1
    567e:	74da      	strb	r2, [r3, #19]
	config->remote_frames_extended_reject = true;
    5680:	687b      	ldr	r3, [r7, #4]
    5682:	2201      	movs	r2, #1
    5684:	751a      	strb	r2, [r3, #20]
	config->extended_id_mask = 0x1FFFFFFF;
    5686:	687b      	ldr	r3, [r7, #4]
    5688:	4a0c      	ldr	r2, [pc, #48]	; (56bc <can_get_config_defaults+0xb8>)
    568a:	619a      	str	r2, [r3, #24]
	config->rx_fifo_0_overwrite = true;
    568c:	687b      	ldr	r3, [r7, #4]
    568e:	2201      	movs	r2, #1
    5690:	771a      	strb	r2, [r3, #28]
	config->rx_fifo_0_watermark = 0;
    5692:	687b      	ldr	r3, [r7, #4]
    5694:	2200      	movs	r2, #0
    5696:	775a      	strb	r2, [r3, #29]
	config->rx_fifo_1_overwrite = true;
    5698:	687b      	ldr	r3, [r7, #4]
    569a:	2201      	movs	r2, #1
    569c:	779a      	strb	r2, [r3, #30]
	config->rx_fifo_1_watermark = 0;
    569e:	687b      	ldr	r3, [r7, #4]
    56a0:	2200      	movs	r2, #0
    56a2:	77da      	strb	r2, [r3, #31]
	config->tx_queue_mode = false;
    56a4:	687b      	ldr	r3, [r7, #4]
    56a6:	2220      	movs	r2, #32
    56a8:	2100      	movs	r1, #0
    56aa:	5499      	strb	r1, [r3, r2]
	config->tx_event_fifo_watermark = 0;
    56ac:	687b      	ldr	r3, [r7, #4]
    56ae:	2221      	movs	r2, #33	; 0x21
    56b0:	2100      	movs	r1, #0
    56b2:	5499      	strb	r1, [r3, r2]
}
    56b4:	46c0      	nop			; (mov r8, r8)
    56b6:	46bd      	mov	sp, r7
    56b8:	b002      	add	sp, #8
    56ba:	bd80      	pop	{r7, pc}
    56bc:	1fffffff 	.word	0x1fffffff

000056c0 <can_rx_get_fifo_status>:
{
    56c0:	b580      	push	{r7, lr}
    56c2:	b082      	sub	sp, #8
    56c4:	af00      	add	r7, sp, #0
    56c6:	6078      	str	r0, [r7, #4]
    56c8:	000a      	movs	r2, r1
    56ca:	1cfb      	adds	r3, r7, #3
    56cc:	701a      	strb	r2, [r3, #0]
	if (!fifo_number) {
    56ce:	1cfb      	adds	r3, r7, #3
    56d0:	781b      	ldrb	r3, [r3, #0]
    56d2:	2201      	movs	r2, #1
    56d4:	4053      	eors	r3, r2
    56d6:	b2db      	uxtb	r3, r3
    56d8:	2b00      	cmp	r3, #0
    56da:	d004      	beq.n	56e6 <can_rx_get_fifo_status+0x26>
		return module_inst->hw->RXF0S.reg;
    56dc:	687b      	ldr	r3, [r7, #4]
    56de:	681b      	ldr	r3, [r3, #0]
    56e0:	22a4      	movs	r2, #164	; 0xa4
    56e2:	589b      	ldr	r3, [r3, r2]
    56e4:	e003      	b.n	56ee <can_rx_get_fifo_status+0x2e>
		return module_inst->hw->RXF1S.reg;
    56e6:	687b      	ldr	r3, [r7, #4]
    56e8:	681b      	ldr	r3, [r3, #0]
    56ea:	22b4      	movs	r2, #180	; 0xb4
    56ec:	589b      	ldr	r3, [r3, r2]
}
    56ee:	0018      	movs	r0, r3
    56f0:	46bd      	mov	sp, r7
    56f2:	b002      	add	sp, #8
    56f4:	bd80      	pop	{r7, pc}

000056f6 <can_tx_get_fifo_queue_status>:
 *
 * \return Tx FIFO/Queue status value.
 */
static inline uint32_t can_tx_get_fifo_queue_status(
		struct can_module *const module_inst)
{
    56f6:	b580      	push	{r7, lr}
    56f8:	b082      	sub	sp, #8
    56fa:	af00      	add	r7, sp, #0
    56fc:	6078      	str	r0, [r7, #4]
	return module_inst->hw->TXFQS.reg;
    56fe:	687b      	ldr	r3, [r7, #4]
    5700:	681b      	ldr	r3, [r3, #0]
    5702:	22c4      	movs	r2, #196	; 0xc4
    5704:	589b      	ldr	r3, [r3, r2]
}
    5706:	0018      	movs	r0, r3
    5708:	46bd      	mov	sp, r7
    570a:	b002      	add	sp, #8
    570c:	bd80      	pop	{r7, pc}

0000570e <can_tx_transfer_request>:
 *  \retval STATUS_OK   Set the transfer request.
 *  \retval STATUS_BUSY The module is in configuration.
 */
static inline enum status_code can_tx_transfer_request(
		struct can_module *const module_inst, uint32_t trig_mask)
{
    570e:	b580      	push	{r7, lr}
    5710:	b082      	sub	sp, #8
    5712:	af00      	add	r7, sp, #0
    5714:	6078      	str	r0, [r7, #4]
    5716:	6039      	str	r1, [r7, #0]
	if (module_inst->hw->CCCR.reg & CAN_CCCR_CCE) {
    5718:	687b      	ldr	r3, [r7, #4]
    571a:	681b      	ldr	r3, [r3, #0]
    571c:	699b      	ldr	r3, [r3, #24]
    571e:	2202      	movs	r2, #2
    5720:	4013      	ands	r3, r2
    5722:	d001      	beq.n	5728 <can_tx_transfer_request+0x1a>
		return STATUS_BUSY;
    5724:	2305      	movs	r3, #5
    5726:	e005      	b.n	5734 <can_tx_transfer_request+0x26>
	}
	module_inst->hw->TXBAR.reg = trig_mask;
    5728:	687b      	ldr	r3, [r7, #4]
    572a:	681b      	ldr	r3, [r3, #0]
    572c:	21d0      	movs	r1, #208	; 0xd0
    572e:	683a      	ldr	r2, [r7, #0]
    5730:	505a      	str	r2, [r3, r1]
	return STATUS_OK;
    5732:	2300      	movs	r3, #0
}
    5734:	0018      	movs	r0, r3
    5736:	46bd      	mov	sp, r7
    5738:	b002      	add	sp, #8
    573a:	bd80      	pop	{r7, pc}

0000573c <can_get_tx_buffer_element_defaults>:
 *
 * \param[out] tx_element  Pointer to transfer element struct to initialize to default values
 */
static inline void can_get_tx_buffer_element_defaults(
		struct can_tx_element *tx_element)
{
    573c:	b580      	push	{r7, lr}
    573e:	b082      	sub	sp, #8
    5740:	af00      	add	r7, sp, #0
    5742:	6078      	str	r0, [r7, #4]
	tx_element->T0.reg = 0;
    5744:	687b      	ldr	r3, [r7, #4]
    5746:	2200      	movs	r2, #0
    5748:	601a      	str	r2, [r3, #0]
	tx_element->T1.reg = CAN_TX_ELEMENT_T1_EFC |
    574a:	687b      	ldr	r3, [r7, #4]
    574c:	2288      	movs	r2, #136	; 0x88
    574e:	0412      	lsls	r2, r2, #16
    5750:	605a      	str	r2, [r3, #4]
			CAN_TX_ELEMENT_T1_DLC(CAN_TX_ELEMENT_T1_DLC_DATA8_Val);
}
    5752:	46c0      	nop			; (mov r8, r8)
    5754:	46bd      	mov	sp, r7
    5756:	b002      	add	sp, #8
    5758:	bd80      	pop	{r7, pc}

0000575a <can_enable_interrupt>:
 * \param[in] module_inst  Pointer to the CAN software instance struct
 * \param[in] source  Interrupt source type
 */
static inline void can_enable_interrupt(struct can_module *const module_inst,
		const enum can_interrupt_source source)
{
    575a:	b580      	push	{r7, lr}
    575c:	b082      	sub	sp, #8
    575e:	af00      	add	r7, sp, #0
    5760:	6078      	str	r0, [r7, #4]
    5762:	6039      	str	r1, [r7, #0]
	module_inst->hw->IE.reg |= source;
    5764:	687b      	ldr	r3, [r7, #4]
    5766:	681b      	ldr	r3, [r3, #0]
    5768:	687a      	ldr	r2, [r7, #4]
    576a:	6812      	ldr	r2, [r2, #0]
    576c:	6d51      	ldr	r1, [r2, #84]	; 0x54
    576e:	683a      	ldr	r2, [r7, #0]
    5770:	430a      	orrs	r2, r1
    5772:	655a      	str	r2, [r3, #84]	; 0x54
}
    5774:	46c0      	nop			; (mov r8, r8)
    5776:	46bd      	mov	sp, r7
    5778:	b002      	add	sp, #8
    577a:	bd80      	pop	{r7, pc}

0000577c <can_read_interrupt_status>:
 *
 * \param[in] module_inst  Pointer to the CAN software instance struct
 */
static inline uint32_t can_read_interrupt_status(
		struct can_module *const module_inst)
{
    577c:	b580      	push	{r7, lr}
    577e:	b082      	sub	sp, #8
    5780:	af00      	add	r7, sp, #0
    5782:	6078      	str	r0, [r7, #4]
	return module_inst->hw->IR.reg;
    5784:	687b      	ldr	r3, [r7, #4]
    5786:	681b      	ldr	r3, [r3, #0]
    5788:	6d1b      	ldr	r3, [r3, #80]	; 0x50
}
    578a:	0018      	movs	r0, r3
    578c:	46bd      	mov	sp, r7
    578e:	b002      	add	sp, #8
    5790:	bd80      	pop	{r7, pc}

00005792 <can_clear_interrupt_status>:
 * \return Bit mask of interrupt status value.
 */
static inline void can_clear_interrupt_status(
		struct can_module *const module_inst,
		const enum can_interrupt_source source)
{
    5792:	b580      	push	{r7, lr}
    5794:	b082      	sub	sp, #8
    5796:	af00      	add	r7, sp, #0
    5798:	6078      	str	r0, [r7, #4]
    579a:	6039      	str	r1, [r7, #0]
	module_inst->hw->IR.reg = source;
    579c:	687b      	ldr	r3, [r7, #4]
    579e:	681b      	ldr	r3, [r3, #0]
    57a0:	683a      	ldr	r2, [r7, #0]
    57a2:	651a      	str	r2, [r3, #80]	; 0x50
}
    57a4:	46c0      	nop			; (mov r8, r8)
    57a6:	46bd      	mov	sp, r7
    57a8:	b002      	add	sp, #8
    57aa:	bd80      	pop	{r7, pc}

000057ac <system_interrupt_enable>:
{
    57ac:	b580      	push	{r7, lr}
    57ae:	b082      	sub	sp, #8
    57b0:	af00      	add	r7, sp, #0
    57b2:	0002      	movs	r2, r0
    57b4:	1dfb      	adds	r3, r7, #7
    57b6:	701a      	strb	r2, [r3, #0]
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
    57b8:	4b06      	ldr	r3, [pc, #24]	; (57d4 <system_interrupt_enable+0x28>)
    57ba:	1dfa      	adds	r2, r7, #7
    57bc:	7812      	ldrb	r2, [r2, #0]
    57be:	0011      	movs	r1, r2
    57c0:	221f      	movs	r2, #31
    57c2:	400a      	ands	r2, r1
    57c4:	2101      	movs	r1, #1
    57c6:	4091      	lsls	r1, r2
    57c8:	000a      	movs	r2, r1
    57ca:	601a      	str	r2, [r3, #0]
}
    57cc:	46c0      	nop			; (mov r8, r8)
    57ce:	46bd      	mov	sp, r7
    57d0:	b002      	add	sp, #8
    57d2:	bd80      	pop	{r7, pc}
    57d4:	e000e100 	.word	0xe000e100

000057d8 <main_blinky>:

/*-----------------------------------------------------------*/

#define JIMMY_CANx
void main_blinky( void )
{
    57d8:	b580      	push	{r7, lr}
    57da:	af00      	add	r7, sp, #0
    /* Initialize "stdio" */
    debug_msg_init();
    57dc:	4b02      	ldr	r3, [pc, #8]	; (57e8 <main_blinky+0x10>)
    57de:	4798      	blx	r3

         /* Start the tasks and timer running. */
	 vTaskStartScheduler();
    }
#else / JIMMY Test!!! */
	 vTaskStartScheduler();
    57e0:	4b02      	ldr	r3, [pc, #8]	; (57ec <main_blinky+0x14>)
    57e2:	4798      	blx	r3
    line will never be reached.  If the following line does execute, then
    there was insufficient FreeRTOS heap memory available for the idle and/or
    timer tasks	to be created.  See the memory management section on the
    FreeRTOS web site for more details. */

    for(;;)
    57e4:	e7fe      	b.n	57e4 <main_blinky+0xc>
    57e6:	46c0      	nop			; (mov r8, r8)
    57e8:	0000139d 	.word	0x0000139d
    57ec:	00004271 	.word	0x00004271

000057f0 <do_can_pinmux>:
        ;
}

static void do_can_pinmux(void)
{
    57f0:	b580      	push	{r7, lr}
    57f2:	b082      	sub	sp, #8
    57f4:	af00      	add	r7, sp, #0
    struct system_pinmux_config pin_config;
    /* Set up I/O pins */
    system_pinmux_get_config_defaults(&pin_config);
    57f6:	1d3b      	adds	r3, r7, #4
    57f8:	0018      	movs	r0, r3
    57fa:	4b0b      	ldr	r3, [pc, #44]	; (5828 <do_can_pinmux+0x38>)
    57fc:	4798      	blx	r3
    pin_config.mux_position = CAN_TX_MUX_SETTING;
    57fe:	1d3b      	adds	r3, r7, #4
    5800:	2206      	movs	r2, #6
    5802:	701a      	strb	r2, [r3, #0]
    system_pinmux_pin_set_config(CAN_TX_PIN, &pin_config);
    5804:	1d3b      	adds	r3, r7, #4
    5806:	0019      	movs	r1, r3
    5808:	2018      	movs	r0, #24
    580a:	4b08      	ldr	r3, [pc, #32]	; (582c <do_can_pinmux+0x3c>)
    580c:	4798      	blx	r3
    pin_config.mux_position = CAN_RX_MUX_SETTING;
    580e:	1d3b      	adds	r3, r7, #4
    5810:	2206      	movs	r2, #6
    5812:	701a      	strb	r2, [r3, #0]
    system_pinmux_pin_set_config(CAN_RX_PIN, &pin_config);
    5814:	1d3b      	adds	r3, r7, #4
    5816:	0019      	movs	r1, r3
    5818:	2019      	movs	r0, #25
    581a:	4b04      	ldr	r3, [pc, #16]	; (582c <do_can_pinmux+0x3c>)
    581c:	4798      	blx	r3
}
    581e:	46c0      	nop			; (mov r8, r8)
    5820:	46bd      	mov	sp, r7
    5822:	b002      	add	sp, #8
    5824:	bd80      	pop	{r7, pc}
    5826:	46c0      	nop			; (mov r8, r8)
    5828:	000055dd 	.word	0x000055dd
    582c:	0000690d 	.word	0x0000690d

00005830 <do_can_init>:

static void do_can_init(void)
{
    5830:	b580      	push	{r7, lr}
    5832:	b08a      	sub	sp, #40	; 0x28
    5834:	af00      	add	r7, sp, #0
    struct can_config config_can;
    uint32_t temp;

    do_can_pinmux();
    5836:	4b21      	ldr	r3, [pc, #132]	; (58bc <do_can_init+0x8c>)
    5838:	4798      	blx	r3

    /* Initialize the CAN driver */
    /* Note:  the default CAN config uses GCLK 8, so be sure to turn it on in conf_clocks.h */
    can_get_config_defaults(&config_can);
    583a:	003b      	movs	r3, r7
    583c:	0018      	movs	r0, r3
    583e:	4b20      	ldr	r3, [pc, #128]	; (58c0 <do_can_init+0x90>)
    5840:	4798      	blx	r3
#define PROMISCUOUS_MODEx
#ifdef PROMISCUOUS_MODE
config_can.nonmatching_frames_action_standard = CAN_NONMATCHING_FRAMES_FIFO_0;
#endif

    can_init(pCAN, CAN0, &config_can);
    5842:	4b20      	ldr	r3, [pc, #128]	; (58c4 <do_can_init+0x94>)
    5844:	681b      	ldr	r3, [r3, #0]
    5846:	003a      	movs	r2, r7
    5848:	491f      	ldr	r1, [pc, #124]	; (58c8 <do_can_init+0x98>)
    584a:	0018      	movs	r0, r3
    584c:	4b1f      	ldr	r3, [pc, #124]	; (58cc <do_can_init+0x9c>)
    584e:	4798      	blx	r3

    /* Save the address of the TX FIFO */
    temp = pCAN->hw->TXBC.bit.TBSA;
    5850:	4b1c      	ldr	r3, [pc, #112]	; (58c4 <do_can_init+0x94>)
    5852:	681b      	ldr	r3, [r3, #0]
    5854:	681b      	ldr	r3, [r3, #0]
    5856:	22c0      	movs	r2, #192	; 0xc0
    5858:	589b      	ldr	r3, [r3, r2]
    585a:	b29b      	uxth	r3, r3
    585c:	627b      	str	r3, [r7, #36]	; 0x24
    pTxFIFO = (struct can_tx_element *) (temp | MEM_BASE);
    585e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    5860:	2280      	movs	r2, #128	; 0x80
    5862:	0592      	lsls	r2, r2, #22
    5864:	4313      	orrs	r3, r2
    5866:	001a      	movs	r2, r3
    5868:	4b19      	ldr	r3, [pc, #100]	; (58d0 <do_can_init+0xa0>)
    586a:	601a      	str	r2, [r3, #0]

    /* Save the address of the RX FIFO */
    temp = pCAN->hw->RXF0C.bit.F0SA;
    586c:	4b15      	ldr	r3, [pc, #84]	; (58c4 <do_can_init+0x94>)
    586e:	681b      	ldr	r3, [r3, #0]
    5870:	681b      	ldr	r3, [r3, #0]
    5872:	22a0      	movs	r2, #160	; 0xa0
    5874:	589b      	ldr	r3, [r3, r2]
    5876:	b29b      	uxth	r3, r3
    5878:	627b      	str	r3, [r7, #36]	; 0x24
    pRxFIFO = (struct can_rx_element_fifo_0 *) (temp | MEM_BASE);
    587a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    587c:	2280      	movs	r2, #128	; 0x80
    587e:	0592      	lsls	r2, r2, #22
    5880:	4313      	orrs	r3, r2
    5882:	001a      	movs	r2, r3
    5884:	4b13      	ldr	r3, [pc, #76]	; (58d4 <do_can_init+0xa4>)
    5886:	601a      	str	r2, [r3, #0]

    can_filters_init();
    5888:	4b13      	ldr	r3, [pc, #76]	; (58d8 <do_can_init+0xa8>)
    588a:	4798      	blx	r3
#ifdef CAN_LOOPBACK
    can_enable_test_mode(pCAN);
#endif
    /* Enable CAN0 interrupt in the NVIC */
    system_interrupt_enable(SYSTEM_INTERRUPT_MODULE_CAN0);
    588c:	200f      	movs	r0, #15
    588e:	4b13      	ldr	r3, [pc, #76]	; (58dc <do_can_init+0xac>)
    5890:	4798      	blx	r3

    /* Enable the particular interrupts we want */
    can_enable_interrupt(pCAN, CAN_TX_FIFO_EMPTY | CAN_RX_FIFO_0_NEW_MESSAGE);
    5892:	4b0c      	ldr	r3, [pc, #48]	; (58c4 <do_can_init+0x94>)
    5894:	681b      	ldr	r3, [r3, #0]
    5896:	4a12      	ldr	r2, [pc, #72]	; (58e0 <do_can_init+0xb0>)
    5898:	0011      	movs	r1, r2
    589a:	0018      	movs	r0, r3
    589c:	4b11      	ldr	r3, [pc, #68]	; (58e4 <do_can_init+0xb4>)
    589e:	4798      	blx	r3
    can_start(pCAN);
    58a0:	4b08      	ldr	r3, [pc, #32]	; (58c4 <do_can_init+0x94>)
    58a2:	681b      	ldr	r3, [r3, #0]
    58a4:	0018      	movs	r0, r3
    58a6:	4b10      	ldr	r3, [pc, #64]	; (58e8 <do_can_init+0xb8>)
    58a8:	4798      	blx	r3
    debug_msg("CAN started!\r\n");
    58aa:	4b10      	ldr	r3, [pc, #64]	; (58ec <do_can_init+0xbc>)
    58ac:	0018      	movs	r0, r3
    58ae:	4b10      	ldr	r3, [pc, #64]	; (58f0 <do_can_init+0xc0>)
    58b0:	4798      	blx	r3
}
    58b2:	46c0      	nop			; (mov r8, r8)
    58b4:	46bd      	mov	sp, r7
    58b6:	b00a      	add	sp, #40	; 0x28
    58b8:	bd80      	pop	{r7, pc}
    58ba:	46c0      	nop			; (mov r8, r8)
    58bc:	000057f1 	.word	0x000057f1
    58c0:	00005605 	.word	0x00005605
    58c4:	2000000c 	.word	0x2000000c
    58c8:	42001c00 	.word	0x42001c00
    58cc:	00000559 	.word	0x00000559
    58d0:	2000338c 	.word	0x2000338c
    58d4:	20003370 	.word	0x20003370
    58d8:	00000bfd 	.word	0x00000bfd
    58dc:	000057ad 	.word	0x000057ad
    58e0:	00000801 	.word	0x00000801
    58e4:	0000575b 	.word	0x0000575b
    58e8:	000006bd 	.word	0x000006bd
    58ec:	00007390 	.word	0x00007390
    58f0:	000013b9 	.word	0x000013b9

000058f4 <can_rx_task>:
 * For now it simply reads CAN messages and throws them away.
 * In a real application, it should perform some action based
 * on the ID of the CAN message.  
 */
static void can_rx_task(void *dummy)
{
    58f4:	b580      	push	{r7, lr}
    58f6:	b08a      	sub	sp, #40	; 0x28
    58f8:	af00      	add	r7, sp, #0
    58fa:	6078      	str	r0, [r7, #4]
    int i;
    unsigned int id;
    struct can_rx_element_fifo_0 *pMsg;
    CAN_HW_FILTER rx_filter;
    /* Add a 422 filter for testing */
    rx_filter.filter = 0x422;
    58fc:	230c      	movs	r3, #12
    58fe:	18fb      	adds	r3, r7, r3
    5900:	4a38      	ldr	r2, [pc, #224]	; (59e4 <can_rx_task+0xf0>)
    5902:	601a      	str	r2, [r3, #0]
    rx_filter.mask = MATCH_ALL;
    5904:	230c      	movs	r3, #12
    5906:	18fb      	adds	r3, r7, r3
    5908:	2201      	movs	r2, #1
    590a:	4252      	negs	r2, r2
    590c:	605a      	str	r2, [r3, #4]
    rx_filter.ext = 0;
    590e:	230c      	movs	r3, #12
    5910:	18fb      	adds	r3, r7, r3
    5912:	2200      	movs	r2, #0
    5914:	721a      	strb	r2, [r3, #8]
    can_filter_add(&rx_filter);
    5916:	230c      	movs	r3, #12
    5918:	18fb      	adds	r3, r7, r3
    591a:	0018      	movs	r0, r3
    591c:	4b32      	ldr	r3, [pc, #200]	; (59e8 <can_rx_task+0xf4>)
    591e:	4798      	blx	r3
    have_reader = 1;
    5920:	4b32      	ldr	r3, [pc, #200]	; (59ec <can_rx_task+0xf8>)
    5922:	2201      	movs	r2, #1
    5924:	601a      	str	r2, [r3, #0]
    while (1) {
        /* Get a packet */
        index = can_msg_get(portMAX_DELAY);
    5926:	2301      	movs	r3, #1
    5928:	425b      	negs	r3, r3
    592a:	0018      	movs	r0, r3
    592c:	4b30      	ldr	r3, [pc, #192]	; (59f0 <can_rx_task+0xfc>)
    592e:	4798      	blx	r3
    5930:	0003      	movs	r3, r0
    5932:	61fb      	str	r3, [r7, #28]
        if (index == -1) {
    5934:	69fb      	ldr	r3, [r7, #28]
    5936:	3301      	adds	r3, #1
    5938:	d104      	bne.n	5944 <can_rx_task+0x50>
            debug_msg("timeout or error in RX FIFO\r\n");
    593a:	4b2e      	ldr	r3, [pc, #184]	; (59f4 <can_rx_task+0x100>)
    593c:	0018      	movs	r0, r3
    593e:	4b2e      	ldr	r3, [pc, #184]	; (59f8 <can_rx_task+0x104>)
    5940:	4798      	blx	r3
            continue;
    5942:	e04e      	b.n	59e2 <can_rx_task+0xee>
        }

        pMsg = &pRxFIFO[index];
    5944:	4b2d      	ldr	r3, [pc, #180]	; (59fc <can_rx_task+0x108>)
    5946:	681a      	ldr	r2, [r3, #0]
    5948:	69fb      	ldr	r3, [r7, #28]
    594a:	011b      	lsls	r3, r3, #4
    594c:	18d3      	adds	r3, r2, r3
    594e:	61bb      	str	r3, [r7, #24]
        id = pMsg->R0.bit.ID;
    5950:	69bb      	ldr	r3, [r7, #24]
    5952:	681b      	ldr	r3, [r3, #0]
    5954:	00db      	lsls	r3, r3, #3
    5956:	08db      	lsrs	r3, r3, #3
    5958:	623b      	str	r3, [r7, #32]
        /* Right justify if not an extended ID */
        if (!pMsg->R0.bit.XTD)
    595a:	69bb      	ldr	r3, [r7, #24]
    595c:	681b      	ldr	r3, [r3, #0]
    595e:	005b      	lsls	r3, r3, #1
    5960:	0fdb      	lsrs	r3, r3, #31
    5962:	b2db      	uxtb	r3, r3
    5964:	2b00      	cmp	r3, #0
    5966:	d102      	bne.n	596e <can_rx_task+0x7a>
            id >>= 18;
    5968:	6a3b      	ldr	r3, [r7, #32]
    596a:	0c9b      	lsrs	r3, r3, #18
    596c:	623b      	str	r3, [r7, #32]

        /* Handle the message */
        switch (id) {
    596e:	6a3b      	ldr	r3, [r7, #32]
    5970:	4a1c      	ldr	r2, [pc, #112]	; (59e4 <can_rx_task+0xf0>)
    5972:	4293      	cmp	r3, r2
    5974:	d104      	bne.n	5980 <can_rx_task+0x8c>
            case 0x422:
                debug_msg("My favorite packet!\r\n");
    5976:	4b22      	ldr	r3, [pc, #136]	; (5a00 <can_rx_task+0x10c>)
    5978:	0018      	movs	r0, r3
    597a:	4b1f      	ldr	r3, [pc, #124]	; (59f8 <can_rx_task+0x104>)
    597c:	4798      	blx	r3
                break;
    597e:	e02c      	b.n	59da <can_rx_task+0xe6>
            default:
                debug_msg("RX! ID = ");
    5980:	4b20      	ldr	r3, [pc, #128]	; (5a04 <can_rx_task+0x110>)
    5982:	0018      	movs	r0, r3
    5984:	4b1c      	ldr	r3, [pc, #112]	; (59f8 <can_rx_task+0x104>)
    5986:	4798      	blx	r3
                printhex(id, 0);
    5988:	6a3b      	ldr	r3, [r7, #32]
    598a:	2100      	movs	r1, #0
    598c:	0018      	movs	r0, r3
    598e:	4b1e      	ldr	r3, [pc, #120]	; (5a08 <can_rx_task+0x114>)
    5990:	4798      	blx	r3
                if (verbose_rx_dump) {
    5992:	4b1e      	ldr	r3, [pc, #120]	; (5a0c <can_rx_task+0x118>)
    5994:	681b      	ldr	r3, [r3, #0]
    5996:	2b00      	cmp	r3, #0
    5998:	d01f      	beq.n	59da <can_rx_task+0xe6>
                    debug_msg(" : ");
    599a:	4b1d      	ldr	r3, [pc, #116]	; (5a10 <can_rx_task+0x11c>)
    599c:	0018      	movs	r0, r3
    599e:	4b16      	ldr	r3, [pc, #88]	; (59f8 <can_rx_task+0x104>)
    59a0:	4798      	blx	r3
                    for (i = 0; i < 7; i++) {
    59a2:	2300      	movs	r3, #0
    59a4:	627b      	str	r3, [r7, #36]	; 0x24
    59a6:	e00f      	b.n	59c8 <can_rx_task+0xd4>
                        printhex(pMsg->data[i], 0);
    59a8:	69ba      	ldr	r2, [r7, #24]
    59aa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    59ac:	18d3      	adds	r3, r2, r3
    59ae:	3308      	adds	r3, #8
    59b0:	781b      	ldrb	r3, [r3, #0]
    59b2:	2100      	movs	r1, #0
    59b4:	0018      	movs	r0, r3
    59b6:	4b14      	ldr	r3, [pc, #80]	; (5a08 <can_rx_task+0x114>)
    59b8:	4798      	blx	r3
                        debug_msg(" ");
    59ba:	4b16      	ldr	r3, [pc, #88]	; (5a14 <can_rx_task+0x120>)
    59bc:	0018      	movs	r0, r3
    59be:	4b0e      	ldr	r3, [pc, #56]	; (59f8 <can_rx_task+0x104>)
    59c0:	4798      	blx	r3
                    for (i = 0; i < 7; i++) {
    59c2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    59c4:	3301      	adds	r3, #1
    59c6:	627b      	str	r3, [r7, #36]	; 0x24
    59c8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    59ca:	2b06      	cmp	r3, #6
    59cc:	ddec      	ble.n	59a8 <can_rx_task+0xb4>
                    }
                    printhex(pMsg->data[7], 1);
    59ce:	69bb      	ldr	r3, [r7, #24]
    59d0:	7bdb      	ldrb	r3, [r3, #15]
    59d2:	2101      	movs	r1, #1
    59d4:	0018      	movs	r0, r3
    59d6:	4b0c      	ldr	r3, [pc, #48]	; (5a08 <can_rx_task+0x114>)
    59d8:	4798      	blx	r3
                }
        }
        can_msg_free(index);
    59da:	69fb      	ldr	r3, [r7, #28]
    59dc:	0018      	movs	r0, r3
    59de:	4b0e      	ldr	r3, [pc, #56]	; (5a18 <can_rx_task+0x124>)
    59e0:	4798      	blx	r3
        index = can_msg_get(portMAX_DELAY);
    59e2:	e7a0      	b.n	5926 <can_rx_task+0x32>
    59e4:	00000422 	.word	0x00000422
    59e8:	00000989 	.word	0x00000989
    59ec:	200032e4 	.word	0x200032e4
    59f0:	00000d1d 	.word	0x00000d1d
    59f4:	00007434 	.word	0x00007434
    59f8:	000013b9 	.word	0x000013b9
    59fc:	20003370 	.word	0x20003370
    5a00:	00007454 	.word	0x00007454
    5a04:	0000746c 	.word	0x0000746c
    5a08:	000013e9 	.word	0x000013e9
    5a0c:	20000008 	.word	0x20000008
    5a10:	00007478 	.word	0x00007478
    5a14:	0000747c 	.word	0x0000747c
    5a18:	00000d75 	.word	0x00000d75

00005a1c <CAN0_Handler>:
/*-----------------------------------------------------------*/

/* CAN Interrupts */

void CAN0_Handler(void)
{
    5a1c:	b580      	push	{r7, lr}
    5a1e:	b084      	sub	sp, #16
    5a20:	af00      	add	r7, sp, #0
    uint32_t status = can_read_interrupt_status(pCAN);
    5a22:	4b2b      	ldr	r3, [pc, #172]	; (5ad0 <CAN0_Handler+0xb4>)
    5a24:	681b      	ldr	r3, [r3, #0]
    5a26:	0018      	movs	r0, r3
    5a28:	4b2a      	ldr	r3, [pc, #168]	; (5ad4 <CAN0_Handler+0xb8>)
    5a2a:	4798      	blx	r3
    5a2c:	0003      	movs	r3, r0
    5a2e:	60fb      	str	r3, [r7, #12]
    uint32_t rx_fifo_status;
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    5a30:	2300      	movs	r3, #0
    5a32:	607b      	str	r3, [r7, #4]
   
    if (status & CAN_RX_FIFO_0_NEW_MESSAGE) {
    5a34:	68fb      	ldr	r3, [r7, #12]
    5a36:	2201      	movs	r2, #1
    5a38:	4013      	ands	r3, r2
    5a3a:	d022      	beq.n	5a82 <CAN0_Handler+0x66>
        can_clear_interrupt_status(pCAN, CAN_RX_FIFO_0_NEW_MESSAGE);
    5a3c:	4b24      	ldr	r3, [pc, #144]	; (5ad0 <CAN0_Handler+0xb4>)
    5a3e:	681b      	ldr	r3, [r3, #0]
    5a40:	2101      	movs	r1, #1
    5a42:	0018      	movs	r0, r3
    5a44:	4b24      	ldr	r3, [pc, #144]	; (5ad8 <CAN0_Handler+0xbc>)
    5a46:	4798      	blx	r3
        can_rx_count++;
    5a48:	4b24      	ldr	r3, [pc, #144]	; (5adc <CAN0_Handler+0xc0>)
    5a4a:	681b      	ldr	r3, [r3, #0]
    5a4c:	1c5a      	adds	r2, r3, #1
    5a4e:	4b23      	ldr	r3, [pc, #140]	; (5adc <CAN0_Handler+0xc0>)
    5a50:	601a      	str	r2, [r3, #0]
        rx_fifo_status = can_rx_get_fifo_status(pCAN, 0) & 0x7f;
    5a52:	4b1f      	ldr	r3, [pc, #124]	; (5ad0 <CAN0_Handler+0xb4>)
    5a54:	681b      	ldr	r3, [r3, #0]
    5a56:	2100      	movs	r1, #0
    5a58:	0018      	movs	r0, r3
    5a5a:	4b21      	ldr	r3, [pc, #132]	; (5ae0 <CAN0_Handler+0xc4>)
    5a5c:	4798      	blx	r3
    5a5e:	0002      	movs	r2, r0
    5a60:	237f      	movs	r3, #127	; 0x7f
    5a62:	4013      	ands	r3, r2
    5a64:	60bb      	str	r3, [r7, #8]
       
        /* Set the RX semaphore if this if the first msg in the FIFO */
        if (rx_fifo_status == 1 && have_reader)
    5a66:	68bb      	ldr	r3, [r7, #8]
    5a68:	2b01      	cmp	r3, #1
    5a6a:	d10a      	bne.n	5a82 <CAN0_Handler+0x66>
    5a6c:	4b1d      	ldr	r3, [pc, #116]	; (5ae4 <CAN0_Handler+0xc8>)
    5a6e:	681b      	ldr	r3, [r3, #0]
    5a70:	2b00      	cmp	r3, #0
    5a72:	d006      	beq.n	5a82 <CAN0_Handler+0x66>
            vTaskNotifyGiveFromISR(rxTaskHandle, &xHigherPriorityTaskWoken);
    5a74:	4b1c      	ldr	r3, [pc, #112]	; (5ae8 <CAN0_Handler+0xcc>)
    5a76:	681b      	ldr	r3, [r3, #0]
    5a78:	1d3a      	adds	r2, r7, #4
    5a7a:	0011      	movs	r1, r2
    5a7c:	0018      	movs	r0, r3
    5a7e:	4b1b      	ldr	r3, [pc, #108]	; (5aec <CAN0_Handler+0xd0>)
    5a80:	4798      	blx	r3
    }
    if (status & CAN_TX_FIFO_EMPTY) {
    5a82:	68fa      	ldr	r2, [r7, #12]
    5a84:	2380      	movs	r3, #128	; 0x80
    5a86:	011b      	lsls	r3, r3, #4
    5a88:	4013      	ands	r3, r2
    5a8a:	d013      	beq.n	5ab4 <CAN0_Handler+0x98>
        can_clear_interrupt_status(pCAN, CAN_TX_FIFO_EMPTY);
    5a8c:	4b10      	ldr	r3, [pc, #64]	; (5ad0 <CAN0_Handler+0xb4>)
    5a8e:	681a      	ldr	r2, [r3, #0]
    5a90:	2380      	movs	r3, #128	; 0x80
    5a92:	011b      	lsls	r3, r3, #4
    5a94:	0019      	movs	r1, r3
    5a96:	0010      	movs	r0, r2
    5a98:	4b0f      	ldr	r3, [pc, #60]	; (5ad8 <CAN0_Handler+0xbc>)
    5a9a:	4798      	blx	r3
        can_tx_count++;
    5a9c:	4b14      	ldr	r3, [pc, #80]	; (5af0 <CAN0_Handler+0xd4>)
    5a9e:	681b      	ldr	r3, [r3, #0]
    5aa0:	1c5a      	adds	r2, r3, #1
    5aa2:	4b13      	ldr	r3, [pc, #76]	; (5af0 <CAN0_Handler+0xd4>)
    5aa4:	601a      	str	r2, [r3, #0]
        /* This may be used when there's a can Tx task.  */
        vTaskNotifyGiveFromISR(txTaskHandle, &xHigherPriorityTaskWoken);
    5aa6:	4b13      	ldr	r3, [pc, #76]	; (5af4 <CAN0_Handler+0xd8>)
    5aa8:	681b      	ldr	r3, [r3, #0]
    5aaa:	1d3a      	adds	r2, r7, #4
    5aac:	0011      	movs	r1, r2
    5aae:	0018      	movs	r0, r3
    5ab0:	4b0e      	ldr	r3, [pc, #56]	; (5aec <CAN0_Handler+0xd0>)
    5ab2:	4798      	blx	r3
    }
    if (xHigherPriorityTaskWoken)
    5ab4:	687b      	ldr	r3, [r7, #4]
    5ab6:	2b00      	cmp	r3, #0
    5ab8:	d006      	beq.n	5ac8 <CAN0_Handler+0xac>
        portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    5aba:	687b      	ldr	r3, [r7, #4]
    5abc:	2b00      	cmp	r3, #0
    5abe:	d003      	beq.n	5ac8 <CAN0_Handler+0xac>
    5ac0:	4b0d      	ldr	r3, [pc, #52]	; (5af8 <CAN0_Handler+0xdc>)
    5ac2:	2280      	movs	r2, #128	; 0x80
    5ac4:	0552      	lsls	r2, r2, #21
    5ac6:	601a      	str	r2, [r3, #0]
}
    5ac8:	46c0      	nop			; (mov r8, r8)
    5aca:	46bd      	mov	sp, r7
    5acc:	b004      	add	sp, #16
    5ace:	bd80      	pop	{r7, pc}
    5ad0:	2000000c 	.word	0x2000000c
    5ad4:	0000577d 	.word	0x0000577d
    5ad8:	00005793 	.word	0x00005793
    5adc:	200032d8 	.word	0x200032d8
    5ae0:	000056c1 	.word	0x000056c1
    5ae4:	200032e4 	.word	0x200032e4
    5ae8:	200032e0 	.word	0x200032e0
    5aec:	00004e31 	.word	0x00004e31
    5af0:	200032dc 	.word	0x200032dc
    5af4:	2000336c 	.word	0x2000336c
    5af8:	e000ed04 	.word	0xe000ed04

00005afc <can_send>:

/* Add a message to the TX FIFO.  */
int can_send(uint32_t id, unsigned char *data)
{
    5afc:	b580      	push	{r7, lr}
    5afe:	b088      	sub	sp, #32
    5b00:	af00      	add	r7, sp, #0
    5b02:	6078      	str	r0, [r7, #4]
    5b04:	6039      	str	r1, [r7, #0]
    uint32_t val;
    struct can_tx_element *msg;
    uint16_t putindex;
    uint16_t i;
    int status;
    uint16_t count = 5;   /* Was 1 */
    5b06:	231c      	movs	r3, #28
    5b08:	18fb      	adds	r3, r7, r3
    5b0a:	2205      	movs	r2, #5
    5b0c:	801a      	strh	r2, [r3, #0]

    /* Make sure we're initialized */
    if (pCAN->hw->CCCR.reg & CAN_CCCR_CCE) 
    5b0e:	4b3e      	ldr	r3, [pc, #248]	; (5c08 <can_send+0x10c>)
    5b10:	681b      	ldr	r3, [r3, #0]
    5b12:	681b      	ldr	r3, [r3, #0]
    5b14:	699b      	ldr	r3, [r3, #24]
    5b16:	2202      	movs	r2, #2
    5b18:	4013      	ands	r3, r2
    5b1a:	d002      	beq.n	5b22 <can_send+0x26>
        return (-2);
    5b1c:	2302      	movs	r3, #2
    5b1e:	425b      	negs	r3, r3
    5b20:	e06e      	b.n	5c00 <can_send+0x104>

    /* If the number of available FIFO entries is 0, 
     * wait for 1 tick and try again.
     */
retry:
    val = can_tx_get_fifo_queue_status(pCAN);
    5b22:	4b39      	ldr	r3, [pc, #228]	; (5c08 <can_send+0x10c>)
    5b24:	681b      	ldr	r3, [r3, #0]
    5b26:	0018      	movs	r0, r3
    5b28:	4b38      	ldr	r3, [pc, #224]	; (5c0c <can_send+0x110>)
    5b2a:	4798      	blx	r3
    5b2c:	0003      	movs	r3, r0
    5b2e:	61bb      	str	r3, [r7, #24]
    if ((val & 0x1f) == 0) {   /* FIFO full */
    5b30:	69bb      	ldr	r3, [r7, #24]
    5b32:	221f      	movs	r2, #31
    5b34:	4013      	ands	r3, r2
    5b36:	d113      	bne.n	5b60 <can_send+0x64>
        if (count--) {
    5b38:	231c      	movs	r3, #28
    5b3a:	18fb      	adds	r3, r7, r3
    5b3c:	881b      	ldrh	r3, [r3, #0]
    5b3e:	221c      	movs	r2, #28
    5b40:	18ba      	adds	r2, r7, r2
    5b42:	1e59      	subs	r1, r3, #1
    5b44:	8011      	strh	r1, [r2, #0]
    5b46:	2b00      	cmp	r3, #0
    5b48:	d007      	beq.n	5b5a <can_send+0x5e>
debug_msg("Wait for FIFO!\r\n");
    5b4a:	4b31      	ldr	r3, [pc, #196]	; (5c10 <can_send+0x114>)
    5b4c:	0018      	movs	r0, r3
    5b4e:	4b31      	ldr	r3, [pc, #196]	; (5c14 <can_send+0x118>)
    5b50:	4798      	blx	r3
            vTaskDelay(1);    /* Delay 10 msec */
    5b52:	2001      	movs	r0, #1
    5b54:	4b30      	ldr	r3, [pc, #192]	; (5c18 <can_send+0x11c>)
    5b56:	4798      	blx	r3
            goto retry;
    5b58:	e7e3      	b.n	5b22 <can_send+0x26>
        }
        else
            return (-1);
    5b5a:	2301      	movs	r3, #1
    5b5c:	425b      	negs	r3, r3
    5b5e:	e04f      	b.n	5c00 <can_send+0x104>
    }

    putindex = (val >> 16) & 0x1f;
    5b60:	69bb      	ldr	r3, [r7, #24]
    5b62:	0c1b      	lsrs	r3, r3, #16
    5b64:	b29a      	uxth	r2, r3
    5b66:	2316      	movs	r3, #22
    5b68:	18fb      	adds	r3, r7, r3
    5b6a:	211f      	movs	r1, #31
    5b6c:	400a      	ands	r2, r1
    5b6e:	801a      	strh	r2, [r3, #0]
    msg = &pTxFIFO[putindex];
    5b70:	4b2a      	ldr	r3, [pc, #168]	; (5c1c <can_send+0x120>)
    5b72:	681a      	ldr	r2, [r3, #0]
    5b74:	2316      	movs	r3, #22
    5b76:	18fb      	adds	r3, r7, r3
    5b78:	881b      	ldrh	r3, [r3, #0]
    5b7a:	011b      	lsls	r3, r3, #4
    5b7c:	18d3      	adds	r3, r2, r3
    5b7e:	613b      	str	r3, [r7, #16]
    can_get_tx_buffer_element_defaults(msg);
    5b80:	693b      	ldr	r3, [r7, #16]
    5b82:	0018      	movs	r0, r3
    5b84:	4b26      	ldr	r3, [pc, #152]	; (5c20 <can_send+0x124>)
    5b86:	4798      	blx	r3
    msg->T0.reg = CAN_TX_ELEMENT_T0_STANDARD_ID(id); 
    5b88:	687b      	ldr	r3, [r7, #4]
    5b8a:	049b      	lsls	r3, r3, #18
    5b8c:	4a25      	ldr	r2, [pc, #148]	; (5c24 <can_send+0x128>)
    5b8e:	401a      	ands	r2, r3
    5b90:	693b      	ldr	r3, [r7, #16]
    5b92:	601a      	str	r2, [r3, #0]
    for (i = 0; i < 8; i++) {
    5b94:	231e      	movs	r3, #30
    5b96:	18fb      	adds	r3, r7, r3
    5b98:	2200      	movs	r2, #0
    5b9a:	801a      	strh	r2, [r3, #0]
    5b9c:	e013      	b.n	5bc6 <can_send+0xca>
        msg->data[i] = data[i];
    5b9e:	231e      	movs	r3, #30
    5ba0:	18fb      	adds	r3, r7, r3
    5ba2:	881b      	ldrh	r3, [r3, #0]
    5ba4:	221e      	movs	r2, #30
    5ba6:	18ba      	adds	r2, r7, r2
    5ba8:	8812      	ldrh	r2, [r2, #0]
    5baa:	6839      	ldr	r1, [r7, #0]
    5bac:	188a      	adds	r2, r1, r2
    5bae:	7811      	ldrb	r1, [r2, #0]
    5bb0:	693a      	ldr	r2, [r7, #16]
    5bb2:	18d3      	adds	r3, r2, r3
    5bb4:	1c0a      	adds	r2, r1, #0
    5bb6:	721a      	strb	r2, [r3, #8]
    for (i = 0; i < 8; i++) {
    5bb8:	231e      	movs	r3, #30
    5bba:	18fb      	adds	r3, r7, r3
    5bbc:	881a      	ldrh	r2, [r3, #0]
    5bbe:	231e      	movs	r3, #30
    5bc0:	18fb      	adds	r3, r7, r3
    5bc2:	3201      	adds	r2, #1
    5bc4:	801a      	strh	r2, [r3, #0]
    5bc6:	231e      	movs	r3, #30
    5bc8:	18fb      	adds	r3, r7, r3
    5bca:	881b      	ldrh	r3, [r3, #0]
    5bcc:	2b07      	cmp	r3, #7
    5bce:	d9e6      	bls.n	5b9e <can_send+0xa2>
    }
#if 0
debug_msg("putindex = ");
printhex(putindex, 1);
#endif
    can_set_tx_buffer_element(pCAN, msg, putindex);
    5bd0:	4b0d      	ldr	r3, [pc, #52]	; (5c08 <can_send+0x10c>)
    5bd2:	6818      	ldr	r0, [r3, #0]
    5bd4:	2316      	movs	r3, #22
    5bd6:	18fb      	adds	r3, r7, r3
    5bd8:	881a      	ldrh	r2, [r3, #0]
    5bda:	693b      	ldr	r3, [r7, #16]
    5bdc:	0019      	movs	r1, r3
    5bde:	4b12      	ldr	r3, [pc, #72]	; (5c28 <can_send+0x12c>)
    5be0:	4798      	blx	r3
    status = can_tx_transfer_request(pCAN, 1 << putindex); 
    5be2:	4b09      	ldr	r3, [pc, #36]	; (5c08 <can_send+0x10c>)
    5be4:	6818      	ldr	r0, [r3, #0]
    5be6:	2316      	movs	r3, #22
    5be8:	18fb      	adds	r3, r7, r3
    5bea:	881b      	ldrh	r3, [r3, #0]
    5bec:	2201      	movs	r2, #1
    5bee:	409a      	lsls	r2, r3
    5bf0:	0013      	movs	r3, r2
    5bf2:	0019      	movs	r1, r3
    5bf4:	4b0d      	ldr	r3, [pc, #52]	; (5c2c <can_send+0x130>)
    5bf6:	4798      	blx	r3
    5bf8:	0003      	movs	r3, r0
    5bfa:	60fb      	str	r3, [r7, #12]
    return (-status);   /* Status codes are positive in ASF */
    5bfc:	68fb      	ldr	r3, [r7, #12]
    5bfe:	425b      	negs	r3, r3
}
    5c00:	0018      	movs	r0, r3
    5c02:	46bd      	mov	sp, r7
    5c04:	b008      	add	sp, #32
    5c06:	bd80      	pop	{r7, pc}
    5c08:	2000000c 	.word	0x2000000c
    5c0c:	000056f7 	.word	0x000056f7
    5c10:	00007480 	.word	0x00007480
    5c14:	000013b9 	.word	0x000013b9
    5c18:	00004215 	.word	0x00004215
    5c1c:	2000338c 	.word	0x2000338c
    5c20:	0000573d 	.word	0x0000573d
    5c24:	1ffc0000 	.word	0x1ffc0000
    5c28:	000007f1 	.word	0x000007f1
    5c2c:	0000570f 	.word	0x0000570f

00005c30 <do_send_loop>:

/*
 *  Send 'n' CAN messages
 */
int do_send_loop(uint32_t n)
{
    5c30:	b580      	push	{r7, lr}
    5c32:	b086      	sub	sp, #24
    5c34:	af00      	add	r7, sp, #0
    5c36:	6078      	str	r0, [r7, #4]
    int rval;
    uint32_t index;
    uint32_t count = 0;
    5c38:	2300      	movs	r3, #0
    5c3a:	60fb      	str	r3, [r7, #12]
        rx_filter.mask = MATCH_ALL;
        rx_filter.ext = 0;
        rval = can_filter_add(&rx_filter);
    }
#endif
    while (n--) {
    5c3c:	e022      	b.n	5c84 <do_send_loop+0x54>
        memset(can_data, 0, 8);
    5c3e:	4b3b      	ldr	r3, [pc, #236]	; (5d2c <do_send_loop+0xfc>)
    5c40:	2208      	movs	r2, #8
    5c42:	2100      	movs	r1, #0
    5c44:	0018      	movs	r0, r3
    5c46:	4b3a      	ldr	r3, [pc, #232]	; (5d30 <do_send_loop+0x100>)
    5c48:	4798      	blx	r3
        index = n >> 8;
    5c4a:	687b      	ldr	r3, [r7, #4]
    5c4c:	0a1b      	lsrs	r3, r3, #8
    5c4e:	613b      	str	r3, [r7, #16]
        if (index > 7)
    5c50:	693b      	ldr	r3, [r7, #16]
    5c52:	2b07      	cmp	r3, #7
    5c54:	d901      	bls.n	5c5a <do_send_loop+0x2a>
            index = 7;
    5c56:	2307      	movs	r3, #7
    5c58:	613b      	str	r3, [r7, #16]
        can_data[index] = n & 0xff;
    5c5a:	687b      	ldr	r3, [r7, #4]
    5c5c:	b2d9      	uxtb	r1, r3
    5c5e:	4a33      	ldr	r2, [pc, #204]	; (5d2c <do_send_loop+0xfc>)
    5c60:	693b      	ldr	r3, [r7, #16]
    5c62:	18d3      	adds	r3, r2, r3
    5c64:	1c0a      	adds	r2, r1, #0
    5c66:	701a      	strb	r2, [r3, #0]
        rval = can_send(0x422, can_data);
    5c68:	4b30      	ldr	r3, [pc, #192]	; (5d2c <do_send_loop+0xfc>)
    5c6a:	4a32      	ldr	r2, [pc, #200]	; (5d34 <do_send_loop+0x104>)
    5c6c:	0019      	movs	r1, r3
    5c6e:	0010      	movs	r0, r2
    5c70:	4b31      	ldr	r3, [pc, #196]	; (5d38 <do_send_loop+0x108>)
    5c72:	4798      	blx	r3
    5c74:	0003      	movs	r3, r0
    5c76:	617b      	str	r3, [r7, #20]
        if (rval == 0)
    5c78:	697b      	ldr	r3, [r7, #20]
    5c7a:	2b00      	cmp	r3, #0
    5c7c:	d108      	bne.n	5c90 <do_send_loop+0x60>
            count++;
    5c7e:	68fb      	ldr	r3, [r7, #12]
    5c80:	3301      	adds	r3, #1
    5c82:	60fb      	str	r3, [r7, #12]
    while (n--) {
    5c84:	687b      	ldr	r3, [r7, #4]
    5c86:	1e5a      	subs	r2, r3, #1
    5c88:	607a      	str	r2, [r7, #4]
    5c8a:	2b00      	cmp	r3, #0
    5c8c:	d1d7      	bne.n	5c3e <do_send_loop+0xe>
    5c8e:	e000      	b.n	5c92 <do_send_loop+0x62>
        else
            break;
    5c90:	46c0      	nop			; (mov r8, r8)
#endif
#if 0
        vTaskDelay(1);    /* Delay 10 msec */
#endif
    }
    debug_msg("Packets sent = ");
    5c92:	4b2a      	ldr	r3, [pc, #168]	; (5d3c <do_send_loop+0x10c>)
    5c94:	0018      	movs	r0, r3
    5c96:	4b2a      	ldr	r3, [pc, #168]	; (5d40 <do_send_loop+0x110>)
    5c98:	4798      	blx	r3
    printhex(count, 1);
    5c9a:	68fb      	ldr	r3, [r7, #12]
    5c9c:	2101      	movs	r1, #1
    5c9e:	0018      	movs	r0, r3
    5ca0:	4b28      	ldr	r3, [pc, #160]	; (5d44 <do_send_loop+0x114>)
    5ca2:	4798      	blx	r3
    if (rval) {
    5ca4:	697b      	ldr	r3, [r7, #20]
    5ca6:	2b00      	cmp	r3, #0
    5ca8:	d03b      	beq.n	5d22 <do_send_loop+0xf2>
        debug_msg("\tError = ");
    5caa:	4b27      	ldr	r3, [pc, #156]	; (5d48 <do_send_loop+0x118>)
    5cac:	0018      	movs	r0, r3
    5cae:	4b24      	ldr	r3, [pc, #144]	; (5d40 <do_send_loop+0x110>)
    5cb0:	4798      	blx	r3
        printhex(-rval, 1);
    5cb2:	697b      	ldr	r3, [r7, #20]
    5cb4:	425b      	negs	r3, r3
    5cb6:	2101      	movs	r1, #1
    5cb8:	0018      	movs	r0, r3
    5cba:	4b22      	ldr	r3, [pc, #136]	; (5d44 <do_send_loop+0x114>)
    5cbc:	4798      	blx	r3
        debug_msg("\tTX FIFO status = ");
    5cbe:	4b23      	ldr	r3, [pc, #140]	; (5d4c <do_send_loop+0x11c>)
    5cc0:	0018      	movs	r0, r3
    5cc2:	4b1f      	ldr	r3, [pc, #124]	; (5d40 <do_send_loop+0x110>)
    5cc4:	4798      	blx	r3
        printhex(can_tx_get_fifo_queue_status(pCAN), 1);
    5cc6:	4b22      	ldr	r3, [pc, #136]	; (5d50 <do_send_loop+0x120>)
    5cc8:	681b      	ldr	r3, [r3, #0]
    5cca:	0018      	movs	r0, r3
    5ccc:	4b21      	ldr	r3, [pc, #132]	; (5d54 <do_send_loop+0x124>)
    5cce:	4798      	blx	r3
    5cd0:	0003      	movs	r3, r0
    5cd2:	2101      	movs	r1, #1
    5cd4:	0018      	movs	r0, r3
    5cd6:	4b1b      	ldr	r3, [pc, #108]	; (5d44 <do_send_loop+0x114>)
    5cd8:	4798      	blx	r3
        debug_msg("\tController status = ");
    5cda:	4b1f      	ldr	r3, [pc, #124]	; (5d58 <do_send_loop+0x128>)
    5cdc:	0018      	movs	r0, r3
    5cde:	4b18      	ldr	r3, [pc, #96]	; (5d40 <do_send_loop+0x110>)
    5ce0:	4798      	blx	r3
        printhex(pCAN->hw->CCCR.reg, 1);
    5ce2:	4b1b      	ldr	r3, [pc, #108]	; (5d50 <do_send_loop+0x120>)
    5ce4:	681b      	ldr	r3, [r3, #0]
    5ce6:	681b      	ldr	r3, [r3, #0]
    5ce8:	699b      	ldr	r3, [r3, #24]
    5cea:	2101      	movs	r1, #1
    5cec:	0018      	movs	r0, r3
    5cee:	4b15      	ldr	r3, [pc, #84]	; (5d44 <do_send_loop+0x114>)
    5cf0:	4798      	blx	r3
        debug_msg("\tError counter = ");
    5cf2:	4b1a      	ldr	r3, [pc, #104]	; (5d5c <do_send_loop+0x12c>)
    5cf4:	0018      	movs	r0, r3
    5cf6:	4b12      	ldr	r3, [pc, #72]	; (5d40 <do_send_loop+0x110>)
    5cf8:	4798      	blx	r3
        printhex(pCAN->hw->ECR.reg, 1);
    5cfa:	4b15      	ldr	r3, [pc, #84]	; (5d50 <do_send_loop+0x120>)
    5cfc:	681b      	ldr	r3, [r3, #0]
    5cfe:	681b      	ldr	r3, [r3, #0]
    5d00:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    5d02:	2101      	movs	r1, #1
    5d04:	0018      	movs	r0, r3
    5d06:	4b0f      	ldr	r3, [pc, #60]	; (5d44 <do_send_loop+0x114>)
    5d08:	4798      	blx	r3
        debug_msg("\tInterrupt flags = ");
    5d0a:	4b15      	ldr	r3, [pc, #84]	; (5d60 <do_send_loop+0x130>)
    5d0c:	0018      	movs	r0, r3
    5d0e:	4b0c      	ldr	r3, [pc, #48]	; (5d40 <do_send_loop+0x110>)
    5d10:	4798      	blx	r3
        printhex(pCAN->hw->IR.reg, 1);
    5d12:	4b0f      	ldr	r3, [pc, #60]	; (5d50 <do_send_loop+0x120>)
    5d14:	681b      	ldr	r3, [r3, #0]
    5d16:	681b      	ldr	r3, [r3, #0]
    5d18:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    5d1a:	2101      	movs	r1, #1
    5d1c:	0018      	movs	r0, r3
    5d1e:	4b09      	ldr	r3, [pc, #36]	; (5d44 <do_send_loop+0x114>)
    5d20:	4798      	blx	r3
    }
}
    5d22:	46c0      	nop			; (mov r8, r8)
    5d24:	0018      	movs	r0, r3
    5d26:	46bd      	mov	sp, r7
    5d28:	b006      	add	sp, #24
    5d2a:	bd80      	pop	{r7, pc}
    5d2c:	20003384 	.word	0x20003384
    5d30:	00006c37 	.word	0x00006c37
    5d34:	00000422 	.word	0x00000422
    5d38:	00005afd 	.word	0x00005afd
    5d3c:	00007494 	.word	0x00007494
    5d40:	000013b9 	.word	0x000013b9
    5d44:	000013e9 	.word	0x000013e9
    5d48:	000074a4 	.word	0x000074a4
    5d4c:	000074b0 	.word	0x000074b0
    5d50:	2000000c 	.word	0x2000000c
    5d54:	000056f7 	.word	0x000056f7
    5d58:	000074c4 	.word	0x000074c4
    5d5c:	000074dc 	.word	0x000074dc
    5d60:	000074f0 	.word	0x000074f0

00005d64 <do_help>:

int do_help(uint32_t cmd)
{
    5d64:	b580      	push	{r7, lr}
    5d66:	b084      	sub	sp, #16
    5d68:	af00      	add	r7, sp, #0
    5d6a:	6078      	str	r0, [r7, #4]
    int i;
    if (cmd) {
    5d6c:	687b      	ldr	r3, [r7, #4]
    5d6e:	2b00      	cmp	r3, #0
    5d70:	d012      	beq.n	5d98 <do_help+0x34>
        debug_msg(get_help(cmd));
    5d72:	687b      	ldr	r3, [r7, #4]
    5d74:	b2db      	uxtb	r3, r3
    5d76:	0018      	movs	r0, r3
    5d78:	4b14      	ldr	r3, [pc, #80]	; (5dcc <do_help+0x68>)
    5d7a:	4798      	blx	r3
    5d7c:	0003      	movs	r3, r0
    5d7e:	0018      	movs	r0, r3
    5d80:	4b13      	ldr	r3, [pc, #76]	; (5dd0 <do_help+0x6c>)
    5d82:	4798      	blx	r3
        debug_msg(get_help_verbose(cmd));
    5d84:	687b      	ldr	r3, [r7, #4]
    5d86:	b2db      	uxtb	r3, r3
    5d88:	0018      	movs	r0, r3
    5d8a:	4b12      	ldr	r3, [pc, #72]	; (5dd4 <do_help+0x70>)
    5d8c:	4798      	blx	r3
    5d8e:	0003      	movs	r3, r0
    5d90:	0018      	movs	r0, r3
    5d92:	4b0f      	ldr	r3, [pc, #60]	; (5dd0 <do_help+0x6c>)
    5d94:	4798      	blx	r3
    5d96:	e013      	b.n	5dc0 <do_help+0x5c>
    }
    else {
        for (i = 0; i < NUM_COMMANDS; i++)
    5d98:	2300      	movs	r3, #0
    5d9a:	60fb      	str	r3, [r7, #12]
    5d9c:	e00d      	b.n	5dba <do_help+0x56>
            debug_msg(get_help(i + 1));
    5d9e:	68fb      	ldr	r3, [r7, #12]
    5da0:	b2db      	uxtb	r3, r3
    5da2:	3301      	adds	r3, #1
    5da4:	b2db      	uxtb	r3, r3
    5da6:	0018      	movs	r0, r3
    5da8:	4b08      	ldr	r3, [pc, #32]	; (5dcc <do_help+0x68>)
    5daa:	4798      	blx	r3
    5dac:	0003      	movs	r3, r0
    5dae:	0018      	movs	r0, r3
    5db0:	4b07      	ldr	r3, [pc, #28]	; (5dd0 <do_help+0x6c>)
    5db2:	4798      	blx	r3
        for (i = 0; i < NUM_COMMANDS; i++)
    5db4:	68fb      	ldr	r3, [r7, #12]
    5db6:	3301      	adds	r3, #1
    5db8:	60fb      	str	r3, [r7, #12]
    5dba:	68fb      	ldr	r3, [r7, #12]
    5dbc:	2b0a      	cmp	r3, #10
    5dbe:	ddee      	ble.n	5d9e <do_help+0x3a>
    }
}
    5dc0:	46c0      	nop			; (mov r8, r8)
    5dc2:	0018      	movs	r0, r3
    5dc4:	46bd      	mov	sp, r7
    5dc6:	b004      	add	sp, #16
    5dc8:	bd80      	pop	{r7, pc}
    5dca:	46c0      	nop			; (mov r8, r8)
    5dcc:	00000d9d 	.word	0x00000d9d
    5dd0:	000013b9 	.word	0x000013b9
    5dd4:	00000e15 	.word	0x00000e15

00005dd8 <do_baud>:

void do_baud(int baud)
{
    5dd8:	b580      	push	{r7, lr}
    5dda:	b082      	sub	sp, #8
    5ddc:	af00      	add	r7, sp, #0
    5dde:	6078      	str	r0, [r7, #4]
    if (baud != 250 && baud != 500 & baud != 1000) {
    5de0:	687b      	ldr	r3, [r7, #4]
    5de2:	2bfa      	cmp	r3, #250	; 0xfa
    5de4:	d015      	beq.n	5e12 <do_baud+0x3a>
    5de6:	687b      	ldr	r3, [r7, #4]
    5de8:	3bf5      	subs	r3, #245	; 0xf5
    5dea:	3bff      	subs	r3, #255	; 0xff
    5dec:	1e5a      	subs	r2, r3, #1
    5dee:	4193      	sbcs	r3, r2
    5df0:	b2db      	uxtb	r3, r3
    5df2:	687a      	ldr	r2, [r7, #4]
    5df4:	4911      	ldr	r1, [pc, #68]	; (5e3c <do_baud+0x64>)
    5df6:	468c      	mov	ip, r1
    5df8:	4462      	add	r2, ip
    5dfa:	1e51      	subs	r1, r2, #1
    5dfc:	418a      	sbcs	r2, r1
    5dfe:	b2d2      	uxtb	r2, r2
    5e00:	4013      	ands	r3, r2
    5e02:	b2db      	uxtb	r3, r3
    5e04:	2b00      	cmp	r3, #0
    5e06:	d004      	beq.n	5e12 <do_baud+0x3a>
        debug_msg("Error: Invalid baud rate\r\n");
    5e08:	4b0d      	ldr	r3, [pc, #52]	; (5e40 <do_baud+0x68>)
    5e0a:	0018      	movs	r0, r3
    5e0c:	4b0d      	ldr	r3, [pc, #52]	; (5e44 <do_baud+0x6c>)
    5e0e:	4798      	blx	r3
        return;
    5e10:	e011      	b.n	5e36 <do_baud+0x5e>
    }
    can_stop(pCAN);
    5e12:	4b0d      	ldr	r3, [pc, #52]	; (5e48 <do_baud+0x70>)
    5e14:	681b      	ldr	r3, [r3, #0]
    5e16:	0018      	movs	r0, r3
    5e18:	4b0c      	ldr	r3, [pc, #48]	; (5e4c <do_baud+0x74>)
    5e1a:	4798      	blx	r3
    can_set_baudrate(pCAN->hw, baud);
    5e1c:	4b0a      	ldr	r3, [pc, #40]	; (5e48 <do_baud+0x70>)
    5e1e:	681b      	ldr	r3, [r3, #0]
    5e20:	681b      	ldr	r3, [r3, #0]
    5e22:	687a      	ldr	r2, [r7, #4]
    5e24:	0011      	movs	r1, r2
    5e26:	0018      	movs	r0, r3
    5e28:	4b09      	ldr	r3, [pc, #36]	; (5e50 <do_baud+0x78>)
    5e2a:	4798      	blx	r3
    can_start(pCAN);
    5e2c:	4b06      	ldr	r3, [pc, #24]	; (5e48 <do_baud+0x70>)
    5e2e:	681b      	ldr	r3, [r3, #0]
    5e30:	0018      	movs	r0, r3
    5e32:	4b08      	ldr	r3, [pc, #32]	; (5e54 <do_baud+0x7c>)
    5e34:	4798      	blx	r3
}
    5e36:	46bd      	mov	sp, r7
    5e38:	b002      	add	sp, #8
    5e3a:	bd80      	pop	{r7, pc}
    5e3c:	fffffc18 	.word	0xfffffc18
    5e40:	00007504 	.word	0x00007504
    5e44:	000013b9 	.word	0x000013b9
    5e48:	2000000c 	.word	0x2000000c
    5e4c:	000006eb 	.word	0x000006eb
    5e50:	0000061d 	.word	0x0000061d
    5e54:	000006bd 	.word	0x000006bd

00005e58 <do_start_reader>:

void do_start_reader(void)
{
    5e58:	b590      	push	{r4, r7, lr}
    5e5a:	b083      	sub	sp, #12
    5e5c:	af02      	add	r7, sp, #8
    if ((uint32_t) rxTaskHandle == 0)
    5e5e:	4b0e      	ldr	r3, [pc, #56]	; (5e98 <do_start_reader+0x40>)
    5e60:	681b      	ldr	r3, [r3, #0]
    5e62:	2b00      	cmp	r3, #0
    5e64:	d10b      	bne.n	5e7e <do_start_reader+0x26>
        xTaskCreate(can_rx_task,  
    5e66:	23c3      	movs	r3, #195	; 0xc3
    5e68:	005a      	lsls	r2, r3, #1
    5e6a:	490c      	ldr	r1, [pc, #48]	; (5e9c <do_start_reader+0x44>)
    5e6c:	480c      	ldr	r0, [pc, #48]	; (5ea0 <do_start_reader+0x48>)
    5e6e:	4b0a      	ldr	r3, [pc, #40]	; (5e98 <do_start_reader+0x40>)
    5e70:	9301      	str	r3, [sp, #4]
    5e72:	2302      	movs	r3, #2
    5e74:	9300      	str	r3, [sp, #0]
    5e76:	2300      	movs	r3, #0
    5e78:	4c0a      	ldr	r4, [pc, #40]	; (5ea4 <do_start_reader+0x4c>)
    5e7a:	47a0      	blx	r4
    else {
        /* Turn off the standard ID rejection filter */
        can_filter_switch(1, 0, 0);
        have_reader = 1;   /* Enable ISRs wake-up of the reader task */
    }
}
    5e7c:	e007      	b.n	5e8e <do_start_reader+0x36>
        can_filter_switch(1, 0, 0);
    5e7e:	2200      	movs	r2, #0
    5e80:	2100      	movs	r1, #0
    5e82:	2001      	movs	r0, #1
    5e84:	4b08      	ldr	r3, [pc, #32]	; (5ea8 <do_start_reader+0x50>)
    5e86:	4798      	blx	r3
        have_reader = 1;   /* Enable ISRs wake-up of the reader task */
    5e88:	4b08      	ldr	r3, [pc, #32]	; (5eac <do_start_reader+0x54>)
    5e8a:	2201      	movs	r2, #1
    5e8c:	601a      	str	r2, [r3, #0]
}
    5e8e:	46c0      	nop			; (mov r8, r8)
    5e90:	46bd      	mov	sp, r7
    5e92:	b001      	add	sp, #4
    5e94:	bd90      	pop	{r4, r7, pc}
    5e96:	46c0      	nop			; (mov r8, r8)
    5e98:	200032e0 	.word	0x200032e0
    5e9c:	00007520 	.word	0x00007520
    5ea0:	000058f5 	.word	0x000058f5
    5ea4:	00003f81 	.word	0x00003f81
    5ea8:	00000acd 	.word	0x00000acd
    5eac:	200032e4 	.word	0x200032e4

00005eb0 <do_xreader>:

void do_xreader(void)
{
    5eb0:	b580      	push	{r7, lr}
    5eb2:	af00      	add	r7, sp, #0
    have_reader = 0;
    5eb4:	4b05      	ldr	r3, [pc, #20]	; (5ecc <do_xreader+0x1c>)
    5eb6:	2200      	movs	r2, #0
    5eb8:	601a      	str	r2, [r3, #0]
    can_filter_switch(0, 0, 0);   /* Disable rejection filter for SIDs */
    5eba:	2200      	movs	r2, #0
    5ebc:	2100      	movs	r1, #0
    5ebe:	2000      	movs	r0, #0
    5ec0:	4b03      	ldr	r3, [pc, #12]	; (5ed0 <do_xreader+0x20>)
    5ec2:	4798      	blx	r3
}
    5ec4:	46c0      	nop			; (mov r8, r8)
    5ec6:	46bd      	mov	sp, r7
    5ec8:	bd80      	pop	{r7, pc}
    5eca:	46c0      	nop			; (mov r8, r8)
    5ecc:	200032e4 	.word	0x200032e4
    5ed0:	00000acd 	.word	0x00000acd

00005ed4 <dispatch_cmd>:

int dispatch_cmd(char *cmd)
{
    5ed4:	b580      	push	{r7, lr}
    5ed6:	b084      	sub	sp, #16
    5ed8:	af00      	add	r7, sp, #0
    5eda:	6078      	str	r0, [r7, #4]
#endif

    /* "cmd" is the full command string.  Parse the string, returning the
     * command code in 'rval', and the numeric args in 'param' and 'param2'
     */
    rval = get_command(cmd, &param, &param2);
    5edc:	2308      	movs	r3, #8
    5ede:	18fa      	adds	r2, r7, r3
    5ee0:	230a      	movs	r3, #10
    5ee2:	18f9      	adds	r1, r7, r3
    5ee4:	687b      	ldr	r3, [r7, #4]
    5ee6:	0018      	movs	r0, r3
    5ee8:	4b20      	ldr	r3, [pc, #128]	; (5f6c <dispatch_cmd+0x98>)
    5eea:	4798      	blx	r3
    5eec:	0003      	movs	r3, r0
    5eee:	60fb      	str	r3, [r7, #12]
    switch (rval) {
    5ef0:	68fb      	ldr	r3, [r7, #12]
    5ef2:	2b0b      	cmp	r3, #11
    5ef4:	d827      	bhi.n	5f46 <dispatch_cmd+0x72>
    5ef6:	68fb      	ldr	r3, [r7, #12]
    5ef8:	009a      	lsls	r2, r3, #2
    5efa:	4b1d      	ldr	r3, [pc, #116]	; (5f70 <dispatch_cmd+0x9c>)
    5efc:	18d3      	adds	r3, r2, r3
    5efe:	681b      	ldr	r3, [r3, #0]
    5f00:	469f      	mov	pc, r3
        case CMD_HELP:
            do_help(param); 
    5f02:	230a      	movs	r3, #10
    5f04:	18fb      	adds	r3, r7, r3
    5f06:	881b      	ldrh	r3, [r3, #0]
    5f08:	0018      	movs	r0, r3
    5f0a:	4b1a      	ldr	r3, [pc, #104]	; (5f74 <dispatch_cmd+0xa0>)
    5f0c:	4798      	blx	r3
            break;
    5f0e:	e022      	b.n	5f56 <dispatch_cmd+0x82>
        case CMD_CAN:
#if 0
            can_tx_task ((void *) 0);
#else
            do_can_init();
    5f10:	4b19      	ldr	r3, [pc, #100]	; (5f78 <dispatch_cmd+0xa4>)
    5f12:	4798      	blx	r3
#endif
            break;
    5f14:	e01f      	b.n	5f56 <dispatch_cmd+0x82>
        case CMD_READER:
            do_start_reader();
    5f16:	4b19      	ldr	r3, [pc, #100]	; (5f7c <dispatch_cmd+0xa8>)
    5f18:	4798      	blx	r3
            break;
    5f1a:	e01c      	b.n	5f56 <dispatch_cmd+0x82>
        case CMD_XREADER:
            do_xreader();
    5f1c:	4b18      	ldr	r3, [pc, #96]	; (5f80 <dispatch_cmd+0xac>)
    5f1e:	4798      	blx	r3
            break;
    5f20:	e019      	b.n	5f56 <dispatch_cmd+0x82>
        case CMD_SEND:
            do_send_loop(1);
    5f22:	2001      	movs	r0, #1
    5f24:	4b17      	ldr	r3, [pc, #92]	; (5f84 <dispatch_cmd+0xb0>)
    5f26:	4798      	blx	r3
            break;
    5f28:	e015      	b.n	5f56 <dispatch_cmd+0x82>
        case CMD_LOOP:
            do_send_loop(param);
    5f2a:	230a      	movs	r3, #10
    5f2c:	18fb      	adds	r3, r7, r3
    5f2e:	881b      	ldrh	r3, [r3, #0]
    5f30:	0018      	movs	r0, r3
    5f32:	4b14      	ldr	r3, [pc, #80]	; (5f84 <dispatch_cmd+0xb0>)
    5f34:	4798      	blx	r3
            break;
    5f36:	e00e      	b.n	5f56 <dispatch_cmd+0x82>
        case CMD_PING:
            break;
        case CMD_BAUD:
            do_baud(param);
    5f38:	230a      	movs	r3, #10
    5f3a:	18fb      	adds	r3, r7, r3
    5f3c:	881b      	ldrh	r3, [r3, #0]
    5f3e:	0018      	movs	r0, r3
    5f40:	4b11      	ldr	r3, [pc, #68]	; (5f88 <dispatch_cmd+0xb4>)
    5f42:	4798      	blx	r3
            break;
    5f44:	e007      	b.n	5f56 <dispatch_cmd+0x82>
        case CMD_LED:
            break;
        case CMD_XLED:
            break;
        default:
            rval = -1;
    5f46:	2301      	movs	r3, #1
    5f48:	425b      	negs	r3, r3
    5f4a:	60fb      	str	r3, [r7, #12]
            do_help(0);
    5f4c:	2000      	movs	r0, #0
    5f4e:	4b09      	ldr	r3, [pc, #36]	; (5f74 <dispatch_cmd+0xa0>)
    5f50:	4798      	blx	r3
            break;
    5f52:	e000      	b.n	5f56 <dispatch_cmd+0x82>
            break;
    5f54:	46c0      	nop			; (mov r8, r8)
    }
    if (rval > 0)
    5f56:	68fb      	ldr	r3, [r7, #12]
    5f58:	2b00      	cmp	r3, #0
    5f5a:	dd01      	ble.n	5f60 <dispatch_cmd+0x8c>
        return (0);
    5f5c:	2300      	movs	r3, #0
    5f5e:	e000      	b.n	5f62 <dispatch_cmd+0x8e>
    else
        return (rval);
    5f60:	68fb      	ldr	r3, [r7, #12]
}
    5f62:	0018      	movs	r0, r3
    5f64:	46bd      	mov	sp, r7
    5f66:	b004      	add	sp, #16
    5f68:	bd80      	pop	{r7, pc}
    5f6a:	46c0      	nop			; (mov r8, r8)
    5f6c:	00000f95 	.word	0x00000f95
    5f70:	00007528 	.word	0x00007528
    5f74:	00005d65 	.word	0x00005d65
    5f78:	00005831 	.word	0x00005831
    5f7c:	00005e59 	.word	0x00005e59
    5f80:	00005eb1 	.word	0x00005eb1
    5f84:	00005c31 	.word	0x00005c31
    5f88:	00005dd9 	.word	0x00005dd9

00005f8c <system_pinmux_get_group_from_gpio_pin>:
 *
 * \return Base address of the associated PORT module.
 */
static inline PortGroup* system_pinmux_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
    5f8c:	b580      	push	{r7, lr}
    5f8e:	b084      	sub	sp, #16
    5f90:	af00      	add	r7, sp, #0
    5f92:	0002      	movs	r2, r0
    5f94:	1dfb      	adds	r3, r7, #7
    5f96:	701a      	strb	r2, [r3, #0]
	uint8_t port_index  = (gpio_pin / 128);
    5f98:	230f      	movs	r3, #15
    5f9a:	18fb      	adds	r3, r7, r3
    5f9c:	1dfa      	adds	r2, r7, #7
    5f9e:	7812      	ldrb	r2, [r2, #0]
    5fa0:	09d2      	lsrs	r2, r2, #7
    5fa2:	701a      	strb	r2, [r3, #0]
	uint8_t group_index = (gpio_pin / 32);
    5fa4:	230e      	movs	r3, #14
    5fa6:	18fb      	adds	r3, r7, r3
    5fa8:	1dfa      	adds	r2, r7, #7
    5faa:	7812      	ldrb	r2, [r2, #0]
    5fac:	0952      	lsrs	r2, r2, #5
    5fae:	701a      	strb	r2, [r3, #0]

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;
    5fb0:	2382      	movs	r3, #130	; 0x82
    5fb2:	05db      	lsls	r3, r3, #23
    5fb4:	60bb      	str	r3, [r7, #8]

	if (port_index < PORT_INST_NUM) {
    5fb6:	230f      	movs	r3, #15
    5fb8:	18fb      	adds	r3, r7, r3
    5fba:	781b      	ldrb	r3, [r3, #0]
    5fbc:	2b00      	cmp	r3, #0
    5fbe:	d10f      	bne.n	5fe0 <system_pinmux_get_group_from_gpio_pin+0x54>
		return &(ports[port_index]->Group[group_index]);
    5fc0:	230f      	movs	r3, #15
    5fc2:	18fb      	adds	r3, r7, r3
    5fc4:	781b      	ldrb	r3, [r3, #0]
    5fc6:	009b      	lsls	r3, r3, #2
    5fc8:	2210      	movs	r2, #16
    5fca:	4694      	mov	ip, r2
    5fcc:	44bc      	add	ip, r7
    5fce:	4463      	add	r3, ip
    5fd0:	3b08      	subs	r3, #8
    5fd2:	681a      	ldr	r2, [r3, #0]
    5fd4:	230e      	movs	r3, #14
    5fd6:	18fb      	adds	r3, r7, r3
    5fd8:	781b      	ldrb	r3, [r3, #0]
    5fda:	01db      	lsls	r3, r3, #7
    5fdc:	18d3      	adds	r3, r2, r3
    5fde:	e000      	b.n	5fe2 <system_pinmux_get_group_from_gpio_pin+0x56>
	} else {
		Assert(false);
		return NULL;
    5fe0:	2300      	movs	r3, #0
	}
}
    5fe2:	0018      	movs	r0, r3
    5fe4:	46bd      	mov	sp, r7
    5fe6:	b004      	add	sp, #16
    5fe8:	bd80      	pop	{r7, pc}
	...

00005fec <port_get_group_from_gpio_pin>:
 *
 *  \return Base address of the associated PORT module.
 */
static inline PortGroup* port_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
    5fec:	b580      	push	{r7, lr}
    5fee:	b082      	sub	sp, #8
    5ff0:	af00      	add	r7, sp, #0
    5ff2:	0002      	movs	r2, r0
    5ff4:	1dfb      	adds	r3, r7, #7
    5ff6:	701a      	strb	r2, [r3, #0]
	return system_pinmux_get_group_from_gpio_pin(gpio_pin);
    5ff8:	1dfb      	adds	r3, r7, #7
    5ffa:	781b      	ldrb	r3, [r3, #0]
    5ffc:	0018      	movs	r0, r3
    5ffe:	4b03      	ldr	r3, [pc, #12]	; (600c <port_get_group_from_gpio_pin+0x20>)
    6000:	4798      	blx	r3
    6002:	0003      	movs	r3, r0
}
    6004:	0018      	movs	r0, r3
    6006:	46bd      	mov	sp, r7
    6008:	b002      	add	sp, #8
    600a:	bd80      	pop	{r7, pc}
    600c:	00005f8d 	.word	0x00005f8d

00006010 <port_pin_toggle_output_level>:
 *
 *  \param[in] gpio_pin  Index of the GPIO pin to toggle
 */
static inline void port_pin_toggle_output_level(
		const uint8_t gpio_pin)
{
    6010:	b580      	push	{r7, lr}
    6012:	b084      	sub	sp, #16
    6014:	af00      	add	r7, sp, #0
    6016:	0002      	movs	r2, r0
    6018:	1dfb      	adds	r3, r7, #7
    601a:	701a      	strb	r2, [r3, #0]
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
    601c:	1dfb      	adds	r3, r7, #7
    601e:	781b      	ldrb	r3, [r3, #0]
    6020:	0018      	movs	r0, r3
    6022:	4b09      	ldr	r3, [pc, #36]	; (6048 <port_pin_toggle_output_level+0x38>)
    6024:	4798      	blx	r3
    6026:	0003      	movs	r3, r0
    6028:	60fb      	str	r3, [r7, #12]
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    602a:	1dfb      	adds	r3, r7, #7
    602c:	781b      	ldrb	r3, [r3, #0]
    602e:	221f      	movs	r2, #31
    6030:	4013      	ands	r3, r2
    6032:	2201      	movs	r2, #1
    6034:	409a      	lsls	r2, r3
    6036:	0013      	movs	r3, r2
    6038:	60bb      	str	r3, [r7, #8]

	/* Toggle pin output level */
	port_base->OUTTGL.reg = pin_mask;
    603a:	68fb      	ldr	r3, [r7, #12]
    603c:	68ba      	ldr	r2, [r7, #8]
    603e:	61da      	str	r2, [r3, #28]
}
    6040:	46c0      	nop			; (mov r8, r8)
    6042:	46bd      	mov	sp, r7
    6044:	b004      	add	sp, #16
    6046:	bd80      	pop	{r7, pc}
    6048:	00005fed 	.word	0x00005fed

0000604c <main>:
static unsigned long ulClocksPer10thOfAMilliSecond = 0UL;

/*-----------------------------------------------------------*/

int main (void)
{
    604c:	b580      	push	{r7, lr}
    604e:	af00      	add	r7, sp, #0
    /* Prepare the hardware for the demo. */
    prvSetupHardware();
    6050:	4b06      	ldr	r3, [pc, #24]	; (606c <main+0x20>)
    6052:	4798      	blx	r3
        main_blinky();
    }
#else
    {
        /* Jimmy: console just does echo for now */
        vUARTCommandConsoleStart(configMINIMAL_STACK_SIZE * 3, tskIDLE_PRIORITY);
    6054:	23c3      	movs	r3, #195	; 0xc3
    6056:	005b      	lsls	r3, r3, #1
    6058:	2100      	movs	r1, #0
    605a:	0018      	movs	r0, r3
    605c:	4b04      	ldr	r3, [pc, #16]	; (6070 <main+0x24>)
    605e:	4798      	blx	r3
        main_blinky();
    6060:	4b04      	ldr	r3, [pc, #16]	; (6074 <main+0x28>)
    6062:	4798      	blx	r3
    6064:	2300      	movs	r3, #0
    }
#endif
}
    6066:	0018      	movs	r0, r3
    6068:	46bd      	mov	sp, r7
    606a:	bd80      	pop	{r7, pc}
    606c:	00006079 	.word	0x00006079
    6070:	00001285 	.word	0x00001285
    6074:	000057d9 	.word	0x000057d9

00006078 <prvSetupHardware>:
/*-----------------------------------------------------------*/

static void prvSetupHardware( void )
{
    6078:	b580      	push	{r7, lr}
    607a:	af00      	add	r7, sp, #0
	/* Initialisation is performed by the Atmel board support package. */
          system_init();
    607c:	4b02      	ldr	r3, [pc, #8]	; (6088 <prvSetupHardware+0x10>)
    607e:	4798      	blx	r3
}
    6080:	46c0      	nop			; (mov r8, r8)
    6082:	46bd      	mov	sp, r7
    6084:	bd80      	pop	{r7, pc}
    6086:	46c0      	nop			; (mov r8, r8)
    6088:	00002da1 	.word	0x00002da1

0000608c <vApplicationMallocFailedHook>:
/*-----------------------------------------------------------*/

void vApplicationMallocFailedHook( void )
{
    608c:	b580      	push	{r7, lr}
    608e:	af00      	add	r7, sp, #0
	demo application.  If heap_1.c or heap_2.c are used, then the size of the
	heap available to pvPortMalloc() is defined by configTOTAL_HEAP_SIZE in
	FreeRTOSConfig.h, and the xPortGetFreeHeapSize() API function can be used
	to query the size of free heap space that remains (although it does not
	provide information on how the remaining heap might be fragmented). */
	taskDISABLE_INTERRUPTS();
    6090:	b672      	cpsid	i
	for( ;; );
    6092:	e7fe      	b.n	6092 <vApplicationMallocFailedHook+0x6>

00006094 <vApplicationStackOverflowHook>:
	memory allocated by the kernel to any task that has since been deleted. */
}
/*-----------------------------------------------------------*/

void vApplicationStackOverflowHook( TaskHandle_t pxTask, char *pcTaskName )
{
    6094:	b580      	push	{r7, lr}
    6096:	b082      	sub	sp, #8
    6098:	af00      	add	r7, sp, #0
    609a:	6078      	str	r0, [r7, #4]
    609c:	6039      	str	r1, [r7, #0]
	( void ) pxTask;

	/* Run time stack overflow checking is performed if
	configCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook
	function is called if a stack overflow is detected. */
	taskDISABLE_INTERRUPTS();
    609e:	b672      	cpsid	i
	for( ;; );
    60a0:	e7fe      	b.n	60a0 <vApplicationStackOverflowHook+0xc>
	...

000060a4 <vApplicationTickHook>:
/*-----------------------------------------------------------*/

/* Jimmy, heartbeat LED, toggle every half second */
static int heartbeat = 0;
void vApplicationTickHook( void )
{
    60a4:	b580      	push	{r7, lr}
    60a6:	af00      	add	r7, sp, #0
	configUSE_TICK_HOOK is set to 1 in FreeRTOSConfig.h.  User code can be
	added here, but the tick hook is called from an interrupt context, so
	code must not attempt to block, and only the interrupt safe FreeRTOS API
	functions can be used (those that end in FromISR()). */

        if (++heartbeat == 50) {
    60a8:	4b08      	ldr	r3, [pc, #32]	; (60cc <vApplicationTickHook+0x28>)
    60aa:	681b      	ldr	r3, [r3, #0]
    60ac:	1c5a      	adds	r2, r3, #1
    60ae:	4b07      	ldr	r3, [pc, #28]	; (60cc <vApplicationTickHook+0x28>)
    60b0:	601a      	str	r2, [r3, #0]
    60b2:	4b06      	ldr	r3, [pc, #24]	; (60cc <vApplicationTickHook+0x28>)
    60b4:	681b      	ldr	r3, [r3, #0]
    60b6:	2b32      	cmp	r3, #50	; 0x32
    60b8:	d105      	bne.n	60c6 <vApplicationTickHook+0x22>
            port_pin_toggle_output_level( LED_0_PIN );
    60ba:	200f      	movs	r0, #15
    60bc:	4b04      	ldr	r3, [pc, #16]	; (60d0 <vApplicationTickHook+0x2c>)
    60be:	4798      	blx	r3
            heartbeat = 0;
    60c0:	4b02      	ldr	r3, [pc, #8]	; (60cc <vApplicationTickHook+0x28>)
    60c2:	2200      	movs	r2, #0
    60c4:	601a      	str	r2, [r3, #0]
		demonstrate using queue sets from an ISR. */
		vQueueSetAccessQueueSetFromISR();
	}
	#endif /* mainCREATE_SIMPLE_BLINKY_DEMO_ONLY */
#endif
}
    60c6:	46c0      	nop			; (mov r8, r8)
    60c8:	46bd      	mov	sp, r7
    60ca:	bd80      	pop	{r7, pc}
    60cc:	200032ec 	.word	0x200032ec
    60d0:	00006011 	.word	0x00006011

000060d4 <cpu_irq_enter_critical>:
 */
volatile bool g_interrupt_enabled = true;
#endif

void cpu_irq_enter_critical(void)
{
    60d4:	b580      	push	{r7, lr}
    60d6:	b082      	sub	sp, #8
    60d8:	af00      	add	r7, sp, #0
	if (cpu_irq_critical_section_counter == 0) {
    60da:	4b10      	ldr	r3, [pc, #64]	; (611c <cpu_irq_enter_critical+0x48>)
    60dc:	681b      	ldr	r3, [r3, #0]
    60de:	2b00      	cmp	r3, #0
    60e0:	d112      	bne.n	6108 <cpu_irq_enter_critical+0x34>
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
    60e2:	f3ef 8310 	mrs	r3, PRIMASK
    60e6:	607b      	str	r3, [r7, #4]
  return(result);
    60e8:	687b      	ldr	r3, [r7, #4]
		if (cpu_irq_is_enabled()) {
    60ea:	2b00      	cmp	r3, #0
    60ec:	d109      	bne.n	6102 <cpu_irq_enter_critical+0x2e>
  __ASM volatile ("cpsid i" : : : "memory");
    60ee:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
    60f0:	f3bf 8f5f 	dmb	sy
			cpu_irq_disable();
    60f4:	4b0a      	ldr	r3, [pc, #40]	; (6120 <cpu_irq_enter_critical+0x4c>)
    60f6:	2200      	movs	r2, #0
    60f8:	701a      	strb	r2, [r3, #0]
			cpu_irq_prev_interrupt_state = true;
    60fa:	4b0a      	ldr	r3, [pc, #40]	; (6124 <cpu_irq_enter_critical+0x50>)
    60fc:	2201      	movs	r2, #1
    60fe:	701a      	strb	r2, [r3, #0]
    6100:	e002      	b.n	6108 <cpu_irq_enter_critical+0x34>
		} else {
			/* Make sure the to save the prev state as false */
			cpu_irq_prev_interrupt_state = false;
    6102:	4b08      	ldr	r3, [pc, #32]	; (6124 <cpu_irq_enter_critical+0x50>)
    6104:	2200      	movs	r2, #0
    6106:	701a      	strb	r2, [r3, #0]
		}

	}

	cpu_irq_critical_section_counter++;
    6108:	4b04      	ldr	r3, [pc, #16]	; (611c <cpu_irq_enter_critical+0x48>)
    610a:	681b      	ldr	r3, [r3, #0]
    610c:	1c5a      	adds	r2, r3, #1
    610e:	4b03      	ldr	r3, [pc, #12]	; (611c <cpu_irq_enter_critical+0x48>)
    6110:	601a      	str	r2, [r3, #0]
}
    6112:	46c0      	nop			; (mov r8, r8)
    6114:	46bd      	mov	sp, r7
    6116:	b002      	add	sp, #8
    6118:	bd80      	pop	{r7, pc}
    611a:	46c0      	nop			; (mov r8, r8)
    611c:	200032f0 	.word	0x200032f0
    6120:	20000010 	.word	0x20000010
    6124:	200032f4 	.word	0x200032f4

00006128 <cpu_irq_leave_critical>:

void cpu_irq_leave_critical(void)
{
    6128:	b580      	push	{r7, lr}
    612a:	af00      	add	r7, sp, #0
	/* Check if the user is trying to leave a critical section when not in a critical section */
	Assert(cpu_irq_critical_section_counter > 0);

	cpu_irq_critical_section_counter--;
    612c:	4b0b      	ldr	r3, [pc, #44]	; (615c <cpu_irq_leave_critical+0x34>)
    612e:	681b      	ldr	r3, [r3, #0]
    6130:	1e5a      	subs	r2, r3, #1
    6132:	4b0a      	ldr	r3, [pc, #40]	; (615c <cpu_irq_leave_critical+0x34>)
    6134:	601a      	str	r2, [r3, #0]

	/* Only enable global interrupts when the counter reaches 0 and the state of the global interrupt flag
	   was enabled when entering critical state */
	if ((cpu_irq_critical_section_counter == 0) && (cpu_irq_prev_interrupt_state)) {
    6136:	4b09      	ldr	r3, [pc, #36]	; (615c <cpu_irq_leave_critical+0x34>)
    6138:	681b      	ldr	r3, [r3, #0]
    613a:	2b00      	cmp	r3, #0
    613c:	d10a      	bne.n	6154 <cpu_irq_leave_critical+0x2c>
    613e:	4b08      	ldr	r3, [pc, #32]	; (6160 <cpu_irq_leave_critical+0x38>)
    6140:	781b      	ldrb	r3, [r3, #0]
    6142:	b2db      	uxtb	r3, r3
    6144:	2b00      	cmp	r3, #0
    6146:	d005      	beq.n	6154 <cpu_irq_leave_critical+0x2c>
		cpu_irq_enable();
    6148:	4b06      	ldr	r3, [pc, #24]	; (6164 <cpu_irq_leave_critical+0x3c>)
    614a:	2201      	movs	r2, #1
    614c:	701a      	strb	r2, [r3, #0]
    614e:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
    6152:	b662      	cpsie	i
	}
}
    6154:	46c0      	nop			; (mov r8, r8)
    6156:	46bd      	mov	sp, r7
    6158:	bd80      	pop	{r7, pc}
    615a:	46c0      	nop			; (mov r8, r8)
    615c:	200032f0 	.word	0x200032f0
    6160:	200032f4 	.word	0x200032f4
    6164:	20000010 	.word	0x20000010

00006168 <system_pinmux_get_group_from_gpio_pin>:
{
    6168:	b580      	push	{r7, lr}
    616a:	b084      	sub	sp, #16
    616c:	af00      	add	r7, sp, #0
    616e:	0002      	movs	r2, r0
    6170:	1dfb      	adds	r3, r7, #7
    6172:	701a      	strb	r2, [r3, #0]
	uint8_t port_index  = (gpio_pin / 128);
    6174:	230f      	movs	r3, #15
    6176:	18fb      	adds	r3, r7, r3
    6178:	1dfa      	adds	r2, r7, #7
    617a:	7812      	ldrb	r2, [r2, #0]
    617c:	09d2      	lsrs	r2, r2, #7
    617e:	701a      	strb	r2, [r3, #0]
	uint8_t group_index = (gpio_pin / 32);
    6180:	230e      	movs	r3, #14
    6182:	18fb      	adds	r3, r7, r3
    6184:	1dfa      	adds	r2, r7, #7
    6186:	7812      	ldrb	r2, [r2, #0]
    6188:	0952      	lsrs	r2, r2, #5
    618a:	701a      	strb	r2, [r3, #0]
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;
    618c:	2382      	movs	r3, #130	; 0x82
    618e:	05db      	lsls	r3, r3, #23
    6190:	60bb      	str	r3, [r7, #8]
	if (port_index < PORT_INST_NUM) {
    6192:	230f      	movs	r3, #15
    6194:	18fb      	adds	r3, r7, r3
    6196:	781b      	ldrb	r3, [r3, #0]
    6198:	2b00      	cmp	r3, #0
    619a:	d10f      	bne.n	61bc <system_pinmux_get_group_from_gpio_pin+0x54>
		return &(ports[port_index]->Group[group_index]);
    619c:	230f      	movs	r3, #15
    619e:	18fb      	adds	r3, r7, r3
    61a0:	781b      	ldrb	r3, [r3, #0]
    61a2:	009b      	lsls	r3, r3, #2
    61a4:	2210      	movs	r2, #16
    61a6:	4694      	mov	ip, r2
    61a8:	44bc      	add	ip, r7
    61aa:	4463      	add	r3, ip
    61ac:	3b08      	subs	r3, #8
    61ae:	681a      	ldr	r2, [r3, #0]
    61b0:	230e      	movs	r3, #14
    61b2:	18fb      	adds	r3, r7, r3
    61b4:	781b      	ldrb	r3, [r3, #0]
    61b6:	01db      	lsls	r3, r3, #7
    61b8:	18d3      	adds	r3, r2, r3
    61ba:	e000      	b.n	61be <system_pinmux_get_group_from_gpio_pin+0x56>
		return NULL;
    61bc:	2300      	movs	r3, #0
}
    61be:	0018      	movs	r0, r3
    61c0:	46bd      	mov	sp, r7
    61c2:	b004      	add	sp, #16
    61c4:	bd80      	pop	{r7, pc}
	...

000061c8 <port_get_group_from_gpio_pin>:
{
    61c8:	b580      	push	{r7, lr}
    61ca:	b082      	sub	sp, #8
    61cc:	af00      	add	r7, sp, #0
    61ce:	0002      	movs	r2, r0
    61d0:	1dfb      	adds	r3, r7, #7
    61d2:	701a      	strb	r2, [r3, #0]
	return system_pinmux_get_group_from_gpio_pin(gpio_pin);
    61d4:	1dfb      	adds	r3, r7, #7
    61d6:	781b      	ldrb	r3, [r3, #0]
    61d8:	0018      	movs	r0, r3
    61da:	4b03      	ldr	r3, [pc, #12]	; (61e8 <port_get_group_from_gpio_pin+0x20>)
    61dc:	4798      	blx	r3
    61de:	0003      	movs	r3, r0
}
    61e0:	0018      	movs	r0, r3
    61e2:	46bd      	mov	sp, r7
    61e4:	b002      	add	sp, #8
    61e6:	bd80      	pop	{r7, pc}
    61e8:	00006169 	.word	0x00006169

000061ec <port_get_config_defaults>:
{
    61ec:	b580      	push	{r7, lr}
    61ee:	b082      	sub	sp, #8
    61f0:	af00      	add	r7, sp, #0
    61f2:	6078      	str	r0, [r7, #4]
	config->direction  = PORT_PIN_DIR_INPUT;
    61f4:	687b      	ldr	r3, [r7, #4]
    61f6:	2200      	movs	r2, #0
    61f8:	701a      	strb	r2, [r3, #0]
	config->input_pull = PORT_PIN_PULL_UP;
    61fa:	687b      	ldr	r3, [r7, #4]
    61fc:	2201      	movs	r2, #1
    61fe:	705a      	strb	r2, [r3, #1]
	config->powersave  = false;
    6200:	687b      	ldr	r3, [r7, #4]
    6202:	2200      	movs	r2, #0
    6204:	709a      	strb	r2, [r3, #2]
}
    6206:	46c0      	nop			; (mov r8, r8)
    6208:	46bd      	mov	sp, r7
    620a:	b002      	add	sp, #8
    620c:	bd80      	pop	{r7, pc}
	...

00006210 <port_pin_set_output_level>:
{
    6210:	b580      	push	{r7, lr}
    6212:	b084      	sub	sp, #16
    6214:	af00      	add	r7, sp, #0
    6216:	0002      	movs	r2, r0
    6218:	1dfb      	adds	r3, r7, #7
    621a:	701a      	strb	r2, [r3, #0]
    621c:	1dbb      	adds	r3, r7, #6
    621e:	1c0a      	adds	r2, r1, #0
    6220:	701a      	strb	r2, [r3, #0]
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
    6222:	1dfb      	adds	r3, r7, #7
    6224:	781b      	ldrb	r3, [r3, #0]
    6226:	0018      	movs	r0, r3
    6228:	4b0d      	ldr	r3, [pc, #52]	; (6260 <port_pin_set_output_level+0x50>)
    622a:	4798      	blx	r3
    622c:	0003      	movs	r3, r0
    622e:	60fb      	str	r3, [r7, #12]
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    6230:	1dfb      	adds	r3, r7, #7
    6232:	781b      	ldrb	r3, [r3, #0]
    6234:	221f      	movs	r2, #31
    6236:	4013      	ands	r3, r2
    6238:	2201      	movs	r2, #1
    623a:	409a      	lsls	r2, r3
    623c:	0013      	movs	r3, r2
    623e:	60bb      	str	r3, [r7, #8]
	if (level) {
    6240:	1dbb      	adds	r3, r7, #6
    6242:	781b      	ldrb	r3, [r3, #0]
    6244:	2b00      	cmp	r3, #0
    6246:	d003      	beq.n	6250 <port_pin_set_output_level+0x40>
		port_base->OUTSET.reg = pin_mask;
    6248:	68fb      	ldr	r3, [r7, #12]
    624a:	68ba      	ldr	r2, [r7, #8]
    624c:	619a      	str	r2, [r3, #24]
}
    624e:	e002      	b.n	6256 <port_pin_set_output_level+0x46>
		port_base->OUTCLR.reg = pin_mask;
    6250:	68fb      	ldr	r3, [r7, #12]
    6252:	68ba      	ldr	r2, [r7, #8]
    6254:	615a      	str	r2, [r3, #20]
}
    6256:	46c0      	nop			; (mov r8, r8)
    6258:	46bd      	mov	sp, r7
    625a:	b004      	add	sp, #16
    625c:	bd80      	pop	{r7, pc}
    625e:	46c0      	nop			; (mov r8, r8)
    6260:	000061c9 	.word	0x000061c9

00006264 <system_board_init>:
void board_init(void);
#  pragma weak board_init=system_board_init
#endif

void system_board_init(void)
{
    6264:	b580      	push	{r7, lr}
    6266:	b082      	sub	sp, #8
    6268:	af00      	add	r7, sp, #0
	struct port_config pin_conf;
	port_get_config_defaults(&pin_conf);
    626a:	1d3b      	adds	r3, r7, #4
    626c:	0018      	movs	r0, r3
    626e:	4b0e      	ldr	r3, [pc, #56]	; (62a8 <system_board_init+0x44>)
    6270:	4798      	blx	r3

	/* Configure LEDs as outputs, turn them off */
	pin_conf.direction  = PORT_PIN_DIR_OUTPUT;
    6272:	1d3b      	adds	r3, r7, #4
    6274:	2201      	movs	r2, #1
    6276:	701a      	strb	r2, [r3, #0]
	port_pin_set_config(LED_0_PIN, &pin_conf);
    6278:	1d3b      	adds	r3, r7, #4
    627a:	0019      	movs	r1, r3
    627c:	200f      	movs	r0, #15
    627e:	4b0b      	ldr	r3, [pc, #44]	; (62ac <system_board_init+0x48>)
    6280:	4798      	blx	r3
	port_pin_set_output_level(LED_0_PIN, LED_0_INACTIVE);
    6282:	2101      	movs	r1, #1
    6284:	200f      	movs	r0, #15
    6286:	4b0a      	ldr	r3, [pc, #40]	; (62b0 <system_board_init+0x4c>)
    6288:	4798      	blx	r3

	/* Set buttons as inputs */
	pin_conf.direction  = PORT_PIN_DIR_INPUT;
    628a:	1d3b      	adds	r3, r7, #4
    628c:	2200      	movs	r2, #0
    628e:	701a      	strb	r2, [r3, #0]
	pin_conf.input_pull = PORT_PIN_PULL_UP;
    6290:	1d3b      	adds	r3, r7, #4
    6292:	2201      	movs	r2, #1
    6294:	705a      	strb	r2, [r3, #1]
	port_pin_set_config(BUTTON_0_PIN, &pin_conf);
    6296:	1d3b      	adds	r3, r7, #4
    6298:	0019      	movs	r1, r3
    629a:	201c      	movs	r0, #28
    629c:	4b03      	ldr	r3, [pc, #12]	; (62ac <system_board_init+0x48>)
    629e:	4798      	blx	r3
}
    62a0:	46c0      	nop			; (mov r8, r8)
    62a2:	46bd      	mov	sp, r7
    62a4:	b002      	add	sp, #8
    62a6:	bd80      	pop	{r7, pc}
    62a8:	000061ed 	.word	0x000061ed
    62ac:	000062dd 	.word	0x000062dd
    62b0:	00006211 	.word	0x00006211

000062b4 <system_pinmux_get_config_defaults>:
{
    62b4:	b580      	push	{r7, lr}
    62b6:	b082      	sub	sp, #8
    62b8:	af00      	add	r7, sp, #0
    62ba:	6078      	str	r0, [r7, #4]
	config->mux_position = SYSTEM_PINMUX_GPIO;
    62bc:	687b      	ldr	r3, [r7, #4]
    62be:	2280      	movs	r2, #128	; 0x80
    62c0:	701a      	strb	r2, [r3, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    62c2:	687b      	ldr	r3, [r7, #4]
    62c4:	2200      	movs	r2, #0
    62c6:	705a      	strb	r2, [r3, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
    62c8:	687b      	ldr	r3, [r7, #4]
    62ca:	2201      	movs	r2, #1
    62cc:	709a      	strb	r2, [r3, #2]
	config->powersave    = false;
    62ce:	687b      	ldr	r3, [r7, #4]
    62d0:	2200      	movs	r2, #0
    62d2:	70da      	strb	r2, [r3, #3]
}
    62d4:	46c0      	nop			; (mov r8, r8)
    62d6:	46bd      	mov	sp, r7
    62d8:	b002      	add	sp, #8
    62da:	bd80      	pop	{r7, pc}

000062dc <port_pin_set_config>:
 *  \param[in] config    Configuration settings for the pin
 */
void port_pin_set_config(
		const uint8_t gpio_pin,
		const struct port_config *const config)
{
    62dc:	b580      	push	{r7, lr}
    62de:	b084      	sub	sp, #16
    62e0:	af00      	add	r7, sp, #0
    62e2:	0002      	movs	r2, r0
    62e4:	6039      	str	r1, [r7, #0]
    62e6:	1dfb      	adds	r3, r7, #7
    62e8:	701a      	strb	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(config);

	struct system_pinmux_config pinmux_config;
	system_pinmux_get_config_defaults(&pinmux_config);
    62ea:	230c      	movs	r3, #12
    62ec:	18fb      	adds	r3, r7, r3
    62ee:	0018      	movs	r0, r3
    62f0:	4b10      	ldr	r3, [pc, #64]	; (6334 <port_pin_set_config+0x58>)
    62f2:	4798      	blx	r3

	pinmux_config.mux_position = SYSTEM_PINMUX_GPIO;
    62f4:	230c      	movs	r3, #12
    62f6:	18fb      	adds	r3, r7, r3
    62f8:	2280      	movs	r2, #128	; 0x80
    62fa:	701a      	strb	r2, [r3, #0]
	pinmux_config.direction    = (enum system_pinmux_pin_dir)config->direction;
    62fc:	683b      	ldr	r3, [r7, #0]
    62fe:	781a      	ldrb	r2, [r3, #0]
    6300:	230c      	movs	r3, #12
    6302:	18fb      	adds	r3, r7, r3
    6304:	705a      	strb	r2, [r3, #1]
	pinmux_config.input_pull   = (enum system_pinmux_pin_pull)config->input_pull;
    6306:	683b      	ldr	r3, [r7, #0]
    6308:	785a      	ldrb	r2, [r3, #1]
    630a:	230c      	movs	r3, #12
    630c:	18fb      	adds	r3, r7, r3
    630e:	709a      	strb	r2, [r3, #2]
	pinmux_config.powersave    = config->powersave;
    6310:	683b      	ldr	r3, [r7, #0]
    6312:	789a      	ldrb	r2, [r3, #2]
    6314:	230c      	movs	r3, #12
    6316:	18fb      	adds	r3, r7, r3
    6318:	70da      	strb	r2, [r3, #3]

	system_pinmux_pin_set_config(gpio_pin, &pinmux_config);
    631a:	230c      	movs	r3, #12
    631c:	18fa      	adds	r2, r7, r3
    631e:	1dfb      	adds	r3, r7, #7
    6320:	781b      	ldrb	r3, [r3, #0]
    6322:	0011      	movs	r1, r2
    6324:	0018      	movs	r0, r3
    6326:	4b04      	ldr	r3, [pc, #16]	; (6338 <port_pin_set_config+0x5c>)
    6328:	4798      	blx	r3
}
    632a:	46c0      	nop			; (mov r8, r8)
    632c:	46bd      	mov	sp, r7
    632e:	b004      	add	sp, #16
    6330:	bd80      	pop	{r7, pc}
    6332:	46c0      	nop			; (mov r8, r8)
    6334:	000062b5 	.word	0x000062b5
    6338:	0000690d 	.word	0x0000690d

0000633c <system_apb_clock_set_mask>:
{
    633c:	b580      	push	{r7, lr}
    633e:	b082      	sub	sp, #8
    6340:	af00      	add	r7, sp, #0
    6342:	0002      	movs	r2, r0
    6344:	6039      	str	r1, [r7, #0]
    6346:	1dfb      	adds	r3, r7, #7
    6348:	701a      	strb	r2, [r3, #0]
	switch (bus) {
    634a:	1dfb      	adds	r3, r7, #7
    634c:	781b      	ldrb	r3, [r3, #0]
    634e:	2b01      	cmp	r3, #1
    6350:	d00a      	beq.n	6368 <system_apb_clock_set_mask+0x2c>
    6352:	2b02      	cmp	r3, #2
    6354:	d00f      	beq.n	6376 <system_apb_clock_set_mask+0x3a>
    6356:	2b00      	cmp	r3, #0
    6358:	d114      	bne.n	6384 <system_apb_clock_set_mask+0x48>
			MCLK->APBAMASK.reg |= mask;
    635a:	4b0e      	ldr	r3, [pc, #56]	; (6394 <system_apb_clock_set_mask+0x58>)
    635c:	4a0d      	ldr	r2, [pc, #52]	; (6394 <system_apb_clock_set_mask+0x58>)
    635e:	6951      	ldr	r1, [r2, #20]
    6360:	683a      	ldr	r2, [r7, #0]
    6362:	430a      	orrs	r2, r1
    6364:	615a      	str	r2, [r3, #20]
			break;
    6366:	e00f      	b.n	6388 <system_apb_clock_set_mask+0x4c>
			MCLK->APBBMASK.reg |= mask;
    6368:	4b0a      	ldr	r3, [pc, #40]	; (6394 <system_apb_clock_set_mask+0x58>)
    636a:	4a0a      	ldr	r2, [pc, #40]	; (6394 <system_apb_clock_set_mask+0x58>)
    636c:	6991      	ldr	r1, [r2, #24]
    636e:	683a      	ldr	r2, [r7, #0]
    6370:	430a      	orrs	r2, r1
    6372:	619a      	str	r2, [r3, #24]
			break;
    6374:	e008      	b.n	6388 <system_apb_clock_set_mask+0x4c>
			MCLK->APBCMASK.reg |= mask;
    6376:	4b07      	ldr	r3, [pc, #28]	; (6394 <system_apb_clock_set_mask+0x58>)
    6378:	4a06      	ldr	r2, [pc, #24]	; (6394 <system_apb_clock_set_mask+0x58>)
    637a:	69d1      	ldr	r1, [r2, #28]
    637c:	683a      	ldr	r2, [r7, #0]
    637e:	430a      	orrs	r2, r1
    6380:	61da      	str	r2, [r3, #28]
			break;
    6382:	e001      	b.n	6388 <system_apb_clock_set_mask+0x4c>
			return STATUS_ERR_INVALID_ARG;
    6384:	2317      	movs	r3, #23
    6386:	e000      	b.n	638a <system_apb_clock_set_mask+0x4e>
	return STATUS_OK;
    6388:	2300      	movs	r3, #0
}
    638a:	0018      	movs	r0, r3
    638c:	46bd      	mov	sp, r7
    638e:	b002      	add	sp, #8
    6390:	bd80      	pop	{r7, pc}
    6392:	46c0      	nop			; (mov r8, r8)
    6394:	40000800 	.word	0x40000800

00006398 <system_interrupt_enter_critical_section>:
{
    6398:	b580      	push	{r7, lr}
    639a:	af00      	add	r7, sp, #0
	cpu_irq_enter_critical();
    639c:	4b02      	ldr	r3, [pc, #8]	; (63a8 <system_interrupt_enter_critical_section+0x10>)
    639e:	4798      	blx	r3
}
    63a0:	46c0      	nop			; (mov r8, r8)
    63a2:	46bd      	mov	sp, r7
    63a4:	bd80      	pop	{r7, pc}
    63a6:	46c0      	nop			; (mov r8, r8)
    63a8:	000060d5 	.word	0x000060d5

000063ac <system_interrupt_leave_critical_section>:
{
    63ac:	b580      	push	{r7, lr}
    63ae:	af00      	add	r7, sp, #0
	cpu_irq_leave_critical();
    63b0:	4b02      	ldr	r3, [pc, #8]	; (63bc <system_interrupt_leave_critical_section+0x10>)
    63b2:	4798      	blx	r3
}
    63b4:	46c0      	nop			; (mov r8, r8)
    63b6:	46bd      	mov	sp, r7
    63b8:	bd80      	pop	{r7, pc}
    63ba:	46c0      	nop			; (mov r8, r8)
    63bc:	00006129 	.word	0x00006129

000063c0 <system_gclk_is_syncing>:
  *
  * \retval false if the module has completed synchronization
  * \retval true if the module synchronization is ongoing
  */
static inline bool system_gclk_is_syncing(const uint8_t generator)
{
    63c0:	b580      	push	{r7, lr}
    63c2:	b082      	sub	sp, #8
    63c4:	af00      	add	r7, sp, #0
    63c6:	0002      	movs	r2, r0
    63c8:	1dfb      	adds	r3, r7, #7
    63ca:	701a      	strb	r2, [r3, #0]

	 if (GCLK->SYNCBUSY.reg & GCLK_SYNCBUSY_GENCTRL(1 << generator )){
    63cc:	4b09      	ldr	r3, [pc, #36]	; (63f4 <system_gclk_is_syncing+0x34>)
    63ce:	685b      	ldr	r3, [r3, #4]
    63d0:	1dfa      	adds	r2, r7, #7
    63d2:	7812      	ldrb	r2, [r2, #0]
    63d4:	2101      	movs	r1, #1
    63d6:	4091      	lsls	r1, r2
    63d8:	000a      	movs	r2, r1
    63da:	0092      	lsls	r2, r2, #2
    63dc:	4013      	ands	r3, r2
    63de:	4a06      	ldr	r2, [pc, #24]	; (63f8 <system_gclk_is_syncing+0x38>)
    63e0:	4013      	ands	r3, r2
    63e2:	d001      	beq.n	63e8 <system_gclk_is_syncing+0x28>
		 return true;
    63e4:	2301      	movs	r3, #1
    63e6:	e000      	b.n	63ea <system_gclk_is_syncing+0x2a>
	}

	 return false;
    63e8:	2300      	movs	r3, #0
}
    63ea:	0018      	movs	r0, r3
    63ec:	46bd      	mov	sp, r7
    63ee:	b002      	add	sp, #8
    63f0:	bd80      	pop	{r7, pc}
    63f2:	46c0      	nop			; (mov r8, r8)
    63f4:	40001c00 	.word	0x40001c00
    63f8:	000007fc 	.word	0x000007fc

000063fc <system_gclk_init>:
 *
 * Initializes the Generic Clock module, disabling and resetting all active
 * Generic Clock Generators and Channels to their power-on default values.
 */
void system_gclk_init(void)
{
    63fc:	b580      	push	{r7, lr}
    63fe:	af00      	add	r7, sp, #0
	/* Turn on the digital interface clock */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBA, MCLK_APBAMASK_GCLK);
    6400:	2180      	movs	r1, #128	; 0x80
    6402:	2000      	movs	r0, #0
    6404:	4b07      	ldr	r3, [pc, #28]	; (6424 <system_gclk_init+0x28>)
    6406:	4798      	blx	r3

	/* Software reset the module to ensure it is re-initialized correctly */
	GCLK->CTRLA.reg = GCLK_CTRLA_SWRST;
    6408:	4b07      	ldr	r3, [pc, #28]	; (6428 <system_gclk_init+0x2c>)
    640a:	2201      	movs	r2, #1
    640c:	701a      	strb	r2, [r3, #0]
	while (GCLK->CTRLA.reg & GCLK_CTRLA_SWRST) {
    640e:	46c0      	nop			; (mov r8, r8)
    6410:	4b05      	ldr	r3, [pc, #20]	; (6428 <system_gclk_init+0x2c>)
    6412:	781b      	ldrb	r3, [r3, #0]
    6414:	b2db      	uxtb	r3, r3
    6416:	001a      	movs	r2, r3
    6418:	2301      	movs	r3, #1
    641a:	4013      	ands	r3, r2
    641c:	d1f8      	bne.n	6410 <system_gclk_init+0x14>
		/* Wait for reset to complete */
	}
}
    641e:	46c0      	nop			; (mov r8, r8)
    6420:	46bd      	mov	sp, r7
    6422:	bd80      	pop	{r7, pc}
    6424:	0000633d 	.word	0x0000633d
    6428:	40001c00 	.word	0x40001c00

0000642c <system_gclk_gen_set_config>:
 * \param[in] config     Configuration settings for the generator
 */
void system_gclk_gen_set_config(
		const uint8_t generator,
		struct system_gclk_gen_config *const config)
{
    642c:	b580      	push	{r7, lr}
    642e:	b086      	sub	sp, #24
    6430:	af00      	add	r7, sp, #0
    6432:	0002      	movs	r2, r0
    6434:	6039      	str	r1, [r7, #0]
    6436:	1dfb      	adds	r3, r7, #7
    6438:	701a      	strb	r2, [r3, #0]
	/* Cache new register configurations to minimize sync requirements. */
	uint32_t new_genctrl_config ;


	/* Select the requested source clock for the generator */
	new_genctrl_config = config->source_clock << GCLK_GENCTRL_SRC_Pos;
    643a:	683b      	ldr	r3, [r7, #0]
    643c:	781b      	ldrb	r3, [r3, #0]
    643e:	617b      	str	r3, [r7, #20]

	/* Configure the clock to be either high or low when disabled */
	if (config->high_when_disabled) {
    6440:	683b      	ldr	r3, [r7, #0]
    6442:	785b      	ldrb	r3, [r3, #1]
    6444:	2b00      	cmp	r3, #0
    6446:	d004      	beq.n	6452 <system_gclk_gen_set_config+0x26>
		new_genctrl_config |= GCLK_GENCTRL_OOV;
    6448:	697b      	ldr	r3, [r7, #20]
    644a:	2280      	movs	r2, #128	; 0x80
    644c:	00d2      	lsls	r2, r2, #3
    644e:	4313      	orrs	r3, r2
    6450:	617b      	str	r3, [r7, #20]
	}

	/* Configure if the clock output to I/O pin should be enabled. */
	if (config->output_enable) {
    6452:	683b      	ldr	r3, [r7, #0]
    6454:	7a5b      	ldrb	r3, [r3, #9]
    6456:	2b00      	cmp	r3, #0
    6458:	d004      	beq.n	6464 <system_gclk_gen_set_config+0x38>
		new_genctrl_config |= GCLK_GENCTRL_OE;
    645a:	697b      	ldr	r3, [r7, #20]
    645c:	2280      	movs	r2, #128	; 0x80
    645e:	0112      	lsls	r2, r2, #4
    6460:	4313      	orrs	r3, r2
    6462:	617b      	str	r3, [r7, #20]
	}

	/* Set division factor */
	if (config->division_factor > 1) {
    6464:	683b      	ldr	r3, [r7, #0]
    6466:	685b      	ldr	r3, [r3, #4]
    6468:	2b01      	cmp	r3, #1
    646a:	d92c      	bls.n	64c6 <system_gclk_gen_set_config+0x9a>
		/* Check if division is a power of two */
		if (((config->division_factor & (config->division_factor - 1)) == 0)) {
    646c:	683b      	ldr	r3, [r7, #0]
    646e:	685a      	ldr	r2, [r3, #4]
    6470:	683b      	ldr	r3, [r7, #0]
    6472:	685b      	ldr	r3, [r3, #4]
    6474:	3b01      	subs	r3, #1
    6476:	4013      	ands	r3, r2
    6478:	d11a      	bne.n	64b0 <system_gclk_gen_set_config+0x84>
			/* Determine the index of the highest bit set to get the
			 * division factor that must be loaded into the division
			 * register */

			uint32_t div2_count = 0;
    647a:	2300      	movs	r3, #0
    647c:	613b      	str	r3, [r7, #16]

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
    647e:	2302      	movs	r3, #2
    6480:	60fb      	str	r3, [r7, #12]
    6482:	e005      	b.n	6490 <system_gclk_gen_set_config+0x64>
						mask <<= 1) {
				div2_count++;
    6484:	693b      	ldr	r3, [r7, #16]
    6486:	3301      	adds	r3, #1
    6488:	613b      	str	r3, [r7, #16]
						mask <<= 1) {
    648a:	68fb      	ldr	r3, [r7, #12]
    648c:	005b      	lsls	r3, r3, #1
    648e:	60fb      	str	r3, [r7, #12]
			for (mask = (1UL << 1); mask < config->division_factor;
    6490:	683b      	ldr	r3, [r7, #0]
    6492:	685a      	ldr	r2, [r3, #4]
    6494:	68fb      	ldr	r3, [r7, #12]
    6496:	429a      	cmp	r2, r3
    6498:	d8f4      	bhi.n	6484 <system_gclk_gen_set_config+0x58>
			}

			/* Set binary divider power of 2 division factor */
			new_genctrl_config  |= div2_count << GCLK_GENCTRL_DIV_Pos;
    649a:	693b      	ldr	r3, [r7, #16]
    649c:	041b      	lsls	r3, r3, #16
    649e:	697a      	ldr	r2, [r7, #20]
    64a0:	4313      	orrs	r3, r2
    64a2:	617b      	str	r3, [r7, #20]
			new_genctrl_config |= GCLK_GENCTRL_DIVSEL;
    64a4:	697b      	ldr	r3, [r7, #20]
    64a6:	2280      	movs	r2, #128	; 0x80
    64a8:	0152      	lsls	r2, r2, #5
    64aa:	4313      	orrs	r3, r2
    64ac:	617b      	str	r3, [r7, #20]
    64ae:	e00a      	b.n	64c6 <system_gclk_gen_set_config+0x9a>
		} else {
			/* Set integer division factor */

			new_genctrl_config  |=
					(config->division_factor) << GCLK_GENCTRL_DIV_Pos;
    64b0:	683b      	ldr	r3, [r7, #0]
    64b2:	685b      	ldr	r3, [r3, #4]
    64b4:	041b      	lsls	r3, r3, #16
			new_genctrl_config  |=
    64b6:	697a      	ldr	r2, [r7, #20]
    64b8:	4313      	orrs	r3, r2
    64ba:	617b      	str	r3, [r7, #20]

			/* Enable non-binary division with increased duty cycle accuracy */
			new_genctrl_config |= GCLK_GENCTRL_IDC;
    64bc:	697b      	ldr	r3, [r7, #20]
    64be:	2280      	movs	r2, #128	; 0x80
    64c0:	0092      	lsls	r2, r2, #2
    64c2:	4313      	orrs	r3, r2
    64c4:	617b      	str	r3, [r7, #20]
		}

	}

	/* Enable or disable the clock in standby mode */
	if (config->run_in_standby) {
    64c6:	683b      	ldr	r3, [r7, #0]
    64c8:	7a1b      	ldrb	r3, [r3, #8]
    64ca:	2b00      	cmp	r3, #0
    64cc:	d004      	beq.n	64d8 <system_gclk_gen_set_config+0xac>
		new_genctrl_config |= GCLK_GENCTRL_RUNSTDBY;
    64ce:	697b      	ldr	r3, [r7, #20]
    64d0:	2280      	movs	r2, #128	; 0x80
    64d2:	0192      	lsls	r2, r2, #6
    64d4:	4313      	orrs	r3, r2
    64d6:	617b      	str	r3, [r7, #20]
	}

	while (system_gclk_is_syncing(generator)) {
    64d8:	46c0      	nop			; (mov r8, r8)
    64da:	1dfb      	adds	r3, r7, #7
    64dc:	781b      	ldrb	r3, [r3, #0]
    64de:	0018      	movs	r0, r3
    64e0:	4b12      	ldr	r3, [pc, #72]	; (652c <system_gclk_gen_set_config+0x100>)
    64e2:	4798      	blx	r3
    64e4:	1e03      	subs	r3, r0, #0
    64e6:	d1f8      	bne.n	64da <system_gclk_gen_set_config+0xae>
		/* Wait for synchronization */
	};

	system_interrupt_enter_critical_section();
    64e8:	4b11      	ldr	r3, [pc, #68]	; (6530 <system_gclk_gen_set_config+0x104>)
    64ea:	4798      	blx	r3

	GCLK->GENCTRL[generator].reg = new_genctrl_config | (GCLK->GENCTRL[generator].reg & GCLK_GENCTRL_GENEN);
    64ec:	4811      	ldr	r0, [pc, #68]	; (6534 <system_gclk_gen_set_config+0x108>)
    64ee:	1dfb      	adds	r3, r7, #7
    64f0:	781b      	ldrb	r3, [r3, #0]
    64f2:	4910      	ldr	r1, [pc, #64]	; (6534 <system_gclk_gen_set_config+0x108>)
    64f4:	1dfa      	adds	r2, r7, #7
    64f6:	7812      	ldrb	r2, [r2, #0]
    64f8:	3208      	adds	r2, #8
    64fa:	0092      	lsls	r2, r2, #2
    64fc:	5851      	ldr	r1, [r2, r1]
    64fe:	2280      	movs	r2, #128	; 0x80
    6500:	0052      	lsls	r2, r2, #1
    6502:	4011      	ands	r1, r2
    6504:	697a      	ldr	r2, [r7, #20]
    6506:	430a      	orrs	r2, r1
    6508:	3308      	adds	r3, #8
    650a:	009b      	lsls	r3, r3, #2
    650c:	501a      	str	r2, [r3, r0]

	while (system_gclk_is_syncing(generator)) {
    650e:	46c0      	nop			; (mov r8, r8)
    6510:	1dfb      	adds	r3, r7, #7
    6512:	781b      	ldrb	r3, [r3, #0]
    6514:	0018      	movs	r0, r3
    6516:	4b05      	ldr	r3, [pc, #20]	; (652c <system_gclk_gen_set_config+0x100>)
    6518:	4798      	blx	r3
    651a:	1e03      	subs	r3, r0, #0
    651c:	d1f8      	bne.n	6510 <system_gclk_gen_set_config+0xe4>
		/* Wait for synchronization */
	};

	system_interrupt_leave_critical_section();
    651e:	4b06      	ldr	r3, [pc, #24]	; (6538 <system_gclk_gen_set_config+0x10c>)
    6520:	4798      	blx	r3
}
    6522:	46c0      	nop			; (mov r8, r8)
    6524:	46bd      	mov	sp, r7
    6526:	b006      	add	sp, #24
    6528:	bd80      	pop	{r7, pc}
    652a:	46c0      	nop			; (mov r8, r8)
    652c:	000063c1 	.word	0x000063c1
    6530:	00006399 	.word	0x00006399
    6534:	40001c00 	.word	0x40001c00
    6538:	000063ad 	.word	0x000063ad

0000653c <system_gclk_gen_enable>:
 *
 * \param[in] generator  Generic Clock Generator index to enable
 */
void system_gclk_gen_enable(
		const uint8_t generator)
{
    653c:	b580      	push	{r7, lr}
    653e:	b082      	sub	sp, #8
    6540:	af00      	add	r7, sp, #0
    6542:	0002      	movs	r2, r0
    6544:	1dfb      	adds	r3, r7, #7
    6546:	701a      	strb	r2, [r3, #0]
	while (system_gclk_is_syncing(generator)) {
    6548:	46c0      	nop			; (mov r8, r8)
    654a:	1dfb      	adds	r3, r7, #7
    654c:	781b      	ldrb	r3, [r3, #0]
    654e:	0018      	movs	r0, r3
    6550:	4b0d      	ldr	r3, [pc, #52]	; (6588 <system_gclk_gen_enable+0x4c>)
    6552:	4798      	blx	r3
    6554:	1e03      	subs	r3, r0, #0
    6556:	d1f8      	bne.n	654a <system_gclk_gen_enable+0xe>
		/* Wait for synchronization */
	};

	system_interrupt_enter_critical_section();
    6558:	4b0c      	ldr	r3, [pc, #48]	; (658c <system_gclk_gen_enable+0x50>)
    655a:	4798      	blx	r3

	/* Enable generator */
	GCLK->GENCTRL[generator].reg |= GCLK_GENCTRL_GENEN;
    655c:	480c      	ldr	r0, [pc, #48]	; (6590 <system_gclk_gen_enable+0x54>)
    655e:	1dfb      	adds	r3, r7, #7
    6560:	781b      	ldrb	r3, [r3, #0]
    6562:	490b      	ldr	r1, [pc, #44]	; (6590 <system_gclk_gen_enable+0x54>)
    6564:	1dfa      	adds	r2, r7, #7
    6566:	7812      	ldrb	r2, [r2, #0]
    6568:	3208      	adds	r2, #8
    656a:	0092      	lsls	r2, r2, #2
    656c:	5852      	ldr	r2, [r2, r1]
    656e:	2180      	movs	r1, #128	; 0x80
    6570:	0049      	lsls	r1, r1, #1
    6572:	430a      	orrs	r2, r1
    6574:	3308      	adds	r3, #8
    6576:	009b      	lsls	r3, r3, #2
    6578:	501a      	str	r2, [r3, r0]

	system_interrupt_leave_critical_section();
    657a:	4b06      	ldr	r3, [pc, #24]	; (6594 <system_gclk_gen_enable+0x58>)
    657c:	4798      	blx	r3
}
    657e:	46c0      	nop			; (mov r8, r8)
    6580:	46bd      	mov	sp, r7
    6582:	b002      	add	sp, #8
    6584:	bd80      	pop	{r7, pc}
    6586:	46c0      	nop			; (mov r8, r8)
    6588:	000063c1 	.word	0x000063c1
    658c:	00006399 	.word	0x00006399
    6590:	40001c00 	.word	0x40001c00
    6594:	000063ad 	.word	0x000063ad

00006598 <system_gclk_gen_get_hz>:
 *
 * \return The frequency of the generic clock generator, in Hz.
 */
uint32_t system_gclk_gen_get_hz(
		const uint8_t generator)
{
    6598:	b580      	push	{r7, lr}
    659a:	b086      	sub	sp, #24
    659c:	af00      	add	r7, sp, #0
    659e:	0002      	movs	r2, r0
    65a0:	1dfb      	adds	r3, r7, #7
    65a2:	701a      	strb	r2, [r3, #0]
	while (system_gclk_is_syncing(generator)) {
    65a4:	46c0      	nop			; (mov r8, r8)
    65a6:	1dfb      	adds	r3, r7, #7
    65a8:	781b      	ldrb	r3, [r3, #0]
    65aa:	0018      	movs	r0, r3
    65ac:	4b24      	ldr	r3, [pc, #144]	; (6640 <system_gclk_gen_get_hz+0xa8>)
    65ae:	4798      	blx	r3
    65b0:	1e03      	subs	r3, r0, #0
    65b2:	d1f8      	bne.n	65a6 <system_gclk_gen_get_hz+0xe>
		/* Wait for synchronization */
	};

	system_interrupt_enter_critical_section();
    65b4:	4b23      	ldr	r3, [pc, #140]	; (6644 <system_gclk_gen_get_hz+0xac>)
    65b6:	4798      	blx	r3

	/* Get the frequency of the source connected to the GCLK generator */
	uint32_t gen_input_hz = system_clock_source_get_hz(
			(enum system_clock_source)GCLK->GENCTRL[generator].bit.SRC);
    65b8:	4a23      	ldr	r2, [pc, #140]	; (6648 <system_gclk_gen_get_hz+0xb0>)
    65ba:	1dfb      	adds	r3, r7, #7
    65bc:	781b      	ldrb	r3, [r3, #0]
    65be:	3308      	adds	r3, #8
    65c0:	009b      	lsls	r3, r3, #2
    65c2:	589b      	ldr	r3, [r3, r2]
    65c4:	075b      	lsls	r3, r3, #29
    65c6:	0f5b      	lsrs	r3, r3, #29
    65c8:	b2db      	uxtb	r3, r3
	uint32_t gen_input_hz = system_clock_source_get_hz(
    65ca:	0018      	movs	r0, r3
    65cc:	4b1f      	ldr	r3, [pc, #124]	; (664c <system_gclk_gen_get_hz+0xb4>)
    65ce:	4798      	blx	r3
    65d0:	0003      	movs	r3, r0
    65d2:	617b      	str	r3, [r7, #20]

	uint8_t divsel = GCLK->GENCTRL[generator].bit.DIVSEL;
    65d4:	4a1c      	ldr	r2, [pc, #112]	; (6648 <system_gclk_gen_get_hz+0xb0>)
    65d6:	1dfb      	adds	r3, r7, #7
    65d8:	781b      	ldrb	r3, [r3, #0]
    65da:	3308      	adds	r3, #8
    65dc:	009b      	lsls	r3, r3, #2
    65de:	589b      	ldr	r3, [r3, r2]
    65e0:	04db      	lsls	r3, r3, #19
    65e2:	0fdb      	lsrs	r3, r3, #31
    65e4:	b2da      	uxtb	r2, r3
    65e6:	2313      	movs	r3, #19
    65e8:	18fb      	adds	r3, r7, r3
    65ea:	701a      	strb	r2, [r3, #0]
	uint32_t divider = GCLK->GENCTRL[generator].bit.DIV;
    65ec:	4a16      	ldr	r2, [pc, #88]	; (6648 <system_gclk_gen_get_hz+0xb0>)
    65ee:	1dfb      	adds	r3, r7, #7
    65f0:	781b      	ldrb	r3, [r3, #0]
    65f2:	3308      	adds	r3, #8
    65f4:	009b      	lsls	r3, r3, #2
    65f6:	589b      	ldr	r3, [r3, r2]
    65f8:	0c1b      	lsrs	r3, r3, #16
    65fa:	b29b      	uxth	r3, r3
    65fc:	60fb      	str	r3, [r7, #12]

	system_interrupt_leave_critical_section();
    65fe:	4b14      	ldr	r3, [pc, #80]	; (6650 <system_gclk_gen_get_hz+0xb8>)
    6600:	4798      	blx	r3

	/* Check if the generator is using fractional or binary division */
	if (!divsel && divider > 1) {
    6602:	2313      	movs	r3, #19
    6604:	18fb      	adds	r3, r7, r3
    6606:	781b      	ldrb	r3, [r3, #0]
    6608:	2b00      	cmp	r3, #0
    660a:	d109      	bne.n	6620 <system_gclk_gen_get_hz+0x88>
    660c:	68fb      	ldr	r3, [r7, #12]
    660e:	2b01      	cmp	r3, #1
    6610:	d906      	bls.n	6620 <system_gclk_gen_get_hz+0x88>
		gen_input_hz /= divider;
    6612:	4b10      	ldr	r3, [pc, #64]	; (6654 <system_gclk_gen_get_hz+0xbc>)
    6614:	68f9      	ldr	r1, [r7, #12]
    6616:	6978      	ldr	r0, [r7, #20]
    6618:	4798      	blx	r3
    661a:	0003      	movs	r3, r0
    661c:	617b      	str	r3, [r7, #20]
    661e:	e00a      	b.n	6636 <system_gclk_gen_get_hz+0x9e>
	} else if (divsel) {
    6620:	2313      	movs	r3, #19
    6622:	18fb      	adds	r3, r7, r3
    6624:	781b      	ldrb	r3, [r3, #0]
    6626:	2b00      	cmp	r3, #0
    6628:	d005      	beq.n	6636 <system_gclk_gen_get_hz+0x9e>
		gen_input_hz >>= (divider+1);
    662a:	68fb      	ldr	r3, [r7, #12]
    662c:	3301      	adds	r3, #1
    662e:	697a      	ldr	r2, [r7, #20]
    6630:	40da      	lsrs	r2, r3
    6632:	0013      	movs	r3, r2
    6634:	617b      	str	r3, [r7, #20]
	}

	return gen_input_hz;
    6636:	697b      	ldr	r3, [r7, #20]
}
    6638:	0018      	movs	r0, r3
    663a:	46bd      	mov	sp, r7
    663c:	b006      	add	sp, #24
    663e:	bd80      	pop	{r7, pc}
    6640:	000063c1 	.word	0x000063c1
    6644:	00006399 	.word	0x00006399
    6648:	40001c00 	.word	0x40001c00
    664c:	00002c39 	.word	0x00002c39
    6650:	000063ad 	.word	0x000063ad
    6654:	00006a1d 	.word	0x00006a1d

00006658 <system_gclk_chan_set_config>:
 *
 */
void system_gclk_chan_set_config(
		const uint8_t channel,
		struct system_gclk_chan_config *const config)
{
    6658:	b580      	push	{r7, lr}
    665a:	b082      	sub	sp, #8
    665c:	af00      	add	r7, sp, #0
    665e:	0002      	movs	r2, r0
    6660:	6039      	str	r1, [r7, #0]
    6662:	1dfb      	adds	r3, r7, #7
    6664:	701a      	strb	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(config);

	/* Disable generic clock channel */
	system_gclk_chan_disable(channel);
    6666:	1dfb      	adds	r3, r7, #7
    6668:	781b      	ldrb	r3, [r3, #0]
    666a:	0018      	movs	r0, r3
    666c:	4b08      	ldr	r3, [pc, #32]	; (6690 <system_gclk_chan_set_config+0x38>)
    666e:	4798      	blx	r3

	/* Configure the peripheral channel */
	GCLK->PCHCTRL[channel].reg = GCLK_PCHCTRL_GEN(config->source_generator);
    6670:	4908      	ldr	r1, [pc, #32]	; (6694 <system_gclk_chan_set_config+0x3c>)
    6672:	1dfb      	adds	r3, r7, #7
    6674:	781b      	ldrb	r3, [r3, #0]
    6676:	683a      	ldr	r2, [r7, #0]
    6678:	7812      	ldrb	r2, [r2, #0]
    667a:	0010      	movs	r0, r2
    667c:	220f      	movs	r2, #15
    667e:	4002      	ands	r2, r0
    6680:	3320      	adds	r3, #32
    6682:	009b      	lsls	r3, r3, #2
    6684:	505a      	str	r2, [r3, r1]


}
    6686:	46c0      	nop			; (mov r8, r8)
    6688:	46bd      	mov	sp, r7
    668a:	b002      	add	sp, #8
    668c:	bd80      	pop	{r7, pc}
    668e:	46c0      	nop			; (mov r8, r8)
    6690:	000066f1 	.word	0x000066f1
    6694:	40001c00 	.word	0x40001c00

00006698 <system_gclk_chan_enable>:
 *
 * \param[in] channel   Generic Clock channel to enable
 */
void system_gclk_chan_enable(
		const uint8_t channel)
{
    6698:	b580      	push	{r7, lr}
    669a:	b082      	sub	sp, #8
    669c:	af00      	add	r7, sp, #0
    669e:	0002      	movs	r2, r0
    66a0:	1dfb      	adds	r3, r7, #7
    66a2:	701a      	strb	r2, [r3, #0]
	system_interrupt_enter_critical_section();
    66a4:	4b0f      	ldr	r3, [pc, #60]	; (66e4 <system_gclk_chan_enable+0x4c>)
    66a6:	4798      	blx	r3

	/* Enable the peripheral channel */
	GCLK->PCHCTRL[channel].reg |= GCLK_PCHCTRL_CHEN;
    66a8:	490f      	ldr	r1, [pc, #60]	; (66e8 <system_gclk_chan_enable+0x50>)
    66aa:	1dfb      	adds	r3, r7, #7
    66ac:	781b      	ldrb	r3, [r3, #0]
    66ae:	480e      	ldr	r0, [pc, #56]	; (66e8 <system_gclk_chan_enable+0x50>)
    66b0:	1dfa      	adds	r2, r7, #7
    66b2:	7812      	ldrb	r2, [r2, #0]
    66b4:	3220      	adds	r2, #32
    66b6:	0092      	lsls	r2, r2, #2
    66b8:	5812      	ldr	r2, [r2, r0]
    66ba:	2040      	movs	r0, #64	; 0x40
    66bc:	4302      	orrs	r2, r0
    66be:	3320      	adds	r3, #32
    66c0:	009b      	lsls	r3, r3, #2
    66c2:	505a      	str	r2, [r3, r1]

	while (!(GCLK->PCHCTRL[channel].reg & GCLK_PCHCTRL_CHEN)) {
    66c4:	46c0      	nop			; (mov r8, r8)
    66c6:	4a08      	ldr	r2, [pc, #32]	; (66e8 <system_gclk_chan_enable+0x50>)
    66c8:	1dfb      	adds	r3, r7, #7
    66ca:	781b      	ldrb	r3, [r3, #0]
    66cc:	3320      	adds	r3, #32
    66ce:	009b      	lsls	r3, r3, #2
    66d0:	589b      	ldr	r3, [r3, r2]
    66d2:	2240      	movs	r2, #64	; 0x40
    66d4:	4013      	ands	r3, r2
    66d6:	d0f6      	beq.n	66c6 <system_gclk_chan_enable+0x2e>
		/* Wait for clock synchronization */
	}

	system_interrupt_leave_critical_section();
    66d8:	4b04      	ldr	r3, [pc, #16]	; (66ec <system_gclk_chan_enable+0x54>)
    66da:	4798      	blx	r3
}
    66dc:	46c0      	nop			; (mov r8, r8)
    66de:	46bd      	mov	sp, r7
    66e0:	b002      	add	sp, #8
    66e2:	bd80      	pop	{r7, pc}
    66e4:	00006399 	.word	0x00006399
    66e8:	40001c00 	.word	0x40001c00
    66ec:	000063ad 	.word	0x000063ad

000066f0 <system_gclk_chan_disable>:
 *
 * \param[in] channel  Generic Clock channel to disable
 */
void system_gclk_chan_disable(
		const uint8_t channel)
{
    66f0:	b580      	push	{r7, lr}
    66f2:	b082      	sub	sp, #8
    66f4:	af00      	add	r7, sp, #0
    66f6:	0002      	movs	r2, r0
    66f8:	1dfb      	adds	r3, r7, #7
    66fa:	701a      	strb	r2, [r3, #0]
	system_interrupt_enter_critical_section();
    66fc:	4b0f      	ldr	r3, [pc, #60]	; (673c <system_gclk_chan_disable+0x4c>)
    66fe:	4798      	blx	r3

	/* Sanity check WRTLOCK */
	Assert(!GCLK->PCHCTRL[channel].bit.WRTLOCK);

	/* Disable the peripheral channel */
	GCLK->PCHCTRL[channel].reg &= ~GCLK_PCHCTRL_CHEN;
    6700:	490f      	ldr	r1, [pc, #60]	; (6740 <system_gclk_chan_disable+0x50>)
    6702:	1dfb      	adds	r3, r7, #7
    6704:	781b      	ldrb	r3, [r3, #0]
    6706:	480e      	ldr	r0, [pc, #56]	; (6740 <system_gclk_chan_disable+0x50>)
    6708:	1dfa      	adds	r2, r7, #7
    670a:	7812      	ldrb	r2, [r2, #0]
    670c:	3220      	adds	r2, #32
    670e:	0092      	lsls	r2, r2, #2
    6710:	5812      	ldr	r2, [r2, r0]
    6712:	2040      	movs	r0, #64	; 0x40
    6714:	4382      	bics	r2, r0
    6716:	3320      	adds	r3, #32
    6718:	009b      	lsls	r3, r3, #2
    671a:	505a      	str	r2, [r3, r1]

	while (GCLK->PCHCTRL[channel].reg & GCLK_PCHCTRL_CHEN) {
    671c:	46c0      	nop			; (mov r8, r8)
    671e:	4a08      	ldr	r2, [pc, #32]	; (6740 <system_gclk_chan_disable+0x50>)
    6720:	1dfb      	adds	r3, r7, #7
    6722:	781b      	ldrb	r3, [r3, #0]
    6724:	3320      	adds	r3, #32
    6726:	009b      	lsls	r3, r3, #2
    6728:	589b      	ldr	r3, [r3, r2]
    672a:	2240      	movs	r2, #64	; 0x40
    672c:	4013      	ands	r3, r2
    672e:	d1f6      	bne.n	671e <system_gclk_chan_disable+0x2e>
		/* Wait for clock synchronization */
	}

	system_interrupt_leave_critical_section();
    6730:	4b04      	ldr	r3, [pc, #16]	; (6744 <system_gclk_chan_disable+0x54>)
    6732:	4798      	blx	r3
}
    6734:	46c0      	nop			; (mov r8, r8)
    6736:	46bd      	mov	sp, r7
    6738:	b002      	add	sp, #8
    673a:	bd80      	pop	{r7, pc}
    673c:	00006399 	.word	0x00006399
    6740:	40001c00 	.word	0x40001c00
    6744:	000063ad 	.word	0x000063ad

00006748 <system_gclk_chan_get_hz>:
 *
 * \return The frequency of the generic clock channel, in Hz.
 */
uint32_t system_gclk_chan_get_hz(
		const uint8_t channel)
{
    6748:	b580      	push	{r7, lr}
    674a:	b084      	sub	sp, #16
    674c:	af00      	add	r7, sp, #0
    674e:	0002      	movs	r2, r0
    6750:	1dfb      	adds	r3, r7, #7
    6752:	701a      	strb	r2, [r3, #0]
	uint8_t gen_id;

	system_interrupt_enter_critical_section();
    6754:	4b0d      	ldr	r3, [pc, #52]	; (678c <system_gclk_chan_get_hz+0x44>)
    6756:	4798      	blx	r3
	/* Select the requested generic clock channel */
	gen_id = GCLK->PCHCTRL[channel].bit.GEN;
    6758:	4a0d      	ldr	r2, [pc, #52]	; (6790 <system_gclk_chan_get_hz+0x48>)
    675a:	1dfb      	adds	r3, r7, #7
    675c:	781b      	ldrb	r3, [r3, #0]
    675e:	3320      	adds	r3, #32
    6760:	009b      	lsls	r3, r3, #2
    6762:	589b      	ldr	r3, [r3, r2]
    6764:	071b      	lsls	r3, r3, #28
    6766:	0f1b      	lsrs	r3, r3, #28
    6768:	b2da      	uxtb	r2, r3
    676a:	230f      	movs	r3, #15
    676c:	18fb      	adds	r3, r7, r3
    676e:	701a      	strb	r2, [r3, #0]
	system_interrupt_leave_critical_section();
    6770:	4b08      	ldr	r3, [pc, #32]	; (6794 <system_gclk_chan_get_hz+0x4c>)
    6772:	4798      	blx	r3

	/* Return the clock speed of the associated GCLK generator */
	return system_gclk_gen_get_hz(gen_id);
    6774:	230f      	movs	r3, #15
    6776:	18fb      	adds	r3, r7, r3
    6778:	781b      	ldrb	r3, [r3, #0]
    677a:	0018      	movs	r0, r3
    677c:	4b06      	ldr	r3, [pc, #24]	; (6798 <system_gclk_chan_get_hz+0x50>)
    677e:	4798      	blx	r3
    6780:	0003      	movs	r3, r0
}
    6782:	0018      	movs	r0, r3
    6784:	46bd      	mov	sp, r7
    6786:	b004      	add	sp, #16
    6788:	bd80      	pop	{r7, pc}
    678a:	46c0      	nop			; (mov r8, r8)
    678c:	00006399 	.word	0x00006399
    6790:	40001c00 	.word	0x40001c00
    6794:	000063ad 	.word	0x000063ad
    6798:	00006599 	.word	0x00006599

0000679c <system_pinmux_get_group_from_gpio_pin>:
{
    679c:	b580      	push	{r7, lr}
    679e:	b084      	sub	sp, #16
    67a0:	af00      	add	r7, sp, #0
    67a2:	0002      	movs	r2, r0
    67a4:	1dfb      	adds	r3, r7, #7
    67a6:	701a      	strb	r2, [r3, #0]
	uint8_t port_index  = (gpio_pin / 128);
    67a8:	230f      	movs	r3, #15
    67aa:	18fb      	adds	r3, r7, r3
    67ac:	1dfa      	adds	r2, r7, #7
    67ae:	7812      	ldrb	r2, [r2, #0]
    67b0:	09d2      	lsrs	r2, r2, #7
    67b2:	701a      	strb	r2, [r3, #0]
	uint8_t group_index = (gpio_pin / 32);
    67b4:	230e      	movs	r3, #14
    67b6:	18fb      	adds	r3, r7, r3
    67b8:	1dfa      	adds	r2, r7, #7
    67ba:	7812      	ldrb	r2, [r2, #0]
    67bc:	0952      	lsrs	r2, r2, #5
    67be:	701a      	strb	r2, [r3, #0]
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;
    67c0:	2382      	movs	r3, #130	; 0x82
    67c2:	05db      	lsls	r3, r3, #23
    67c4:	60bb      	str	r3, [r7, #8]
	if (port_index < PORT_INST_NUM) {
    67c6:	230f      	movs	r3, #15
    67c8:	18fb      	adds	r3, r7, r3
    67ca:	781b      	ldrb	r3, [r3, #0]
    67cc:	2b00      	cmp	r3, #0
    67ce:	d10f      	bne.n	67f0 <system_pinmux_get_group_from_gpio_pin+0x54>
		return &(ports[port_index]->Group[group_index]);
    67d0:	230f      	movs	r3, #15
    67d2:	18fb      	adds	r3, r7, r3
    67d4:	781b      	ldrb	r3, [r3, #0]
    67d6:	009b      	lsls	r3, r3, #2
    67d8:	2210      	movs	r2, #16
    67da:	4694      	mov	ip, r2
    67dc:	44bc      	add	ip, r7
    67de:	4463      	add	r3, ip
    67e0:	3b08      	subs	r3, #8
    67e2:	681a      	ldr	r2, [r3, #0]
    67e4:	230e      	movs	r3, #14
    67e6:	18fb      	adds	r3, r7, r3
    67e8:	781b      	ldrb	r3, [r3, #0]
    67ea:	01db      	lsls	r3, r3, #7
    67ec:	18d3      	adds	r3, r2, r3
    67ee:	e000      	b.n	67f2 <system_pinmux_get_group_from_gpio_pin+0x56>
		return NULL;
    67f0:	2300      	movs	r3, #0
}
    67f2:	0018      	movs	r0, r3
    67f4:	46bd      	mov	sp, r7
    67f6:	b004      	add	sp, #16
    67f8:	bd80      	pop	{r7, pc}
	...

000067fc <_system_pinmux_config>:
 */
static void _system_pinmux_config(
		PortGroup *const port,
		const uint32_t pin_mask,
		const struct system_pinmux_config *const config)
{
    67fc:	b580      	push	{r7, lr}
    67fe:	b088      	sub	sp, #32
    6800:	af00      	add	r7, sp, #0
    6802:	60f8      	str	r0, [r7, #12]
    6804:	60b9      	str	r1, [r7, #8]
    6806:	607a      	str	r2, [r7, #4]
	Assert(port);
	Assert(config);

	/* Track the configuration bits into a temporary variable before writing */
	uint32_t pin_cfg = 0;
    6808:	2300      	movs	r3, #0
    680a:	61fb      	str	r3, [r7, #28]

	/* Enabled powersave mode, don't create configuration */
	if (!config->powersave) {
    680c:	687b      	ldr	r3, [r7, #4]
    680e:	78db      	ldrb	r3, [r3, #3]
    6810:	2201      	movs	r2, #1
    6812:	4053      	eors	r3, r2
    6814:	b2db      	uxtb	r3, r3
    6816:	2b00      	cmp	r3, #0
    6818:	d035      	beq.n	6886 <_system_pinmux_config+0x8a>
		/* Enable the pin peripheral MUX flag if non-GPIO selected (pinmux will
		 * be written later) and store the new MUX mask */
		if (config->mux_position != SYSTEM_PINMUX_GPIO) {
    681a:	687b      	ldr	r3, [r7, #4]
    681c:	781b      	ldrb	r3, [r3, #0]
    681e:	2b80      	cmp	r3, #128	; 0x80
    6820:	d00b      	beq.n	683a <_system_pinmux_config+0x3e>
			pin_cfg |= PORT_WRCONFIG_PMUXEN;
    6822:	69fb      	ldr	r3, [r7, #28]
    6824:	2280      	movs	r2, #128	; 0x80
    6826:	0252      	lsls	r2, r2, #9
    6828:	4313      	orrs	r3, r2
    682a:	61fb      	str	r3, [r7, #28]
			pin_cfg |= (config->mux_position << PORT_WRCONFIG_PMUX_Pos);
    682c:	687b      	ldr	r3, [r7, #4]
    682e:	781b      	ldrb	r3, [r3, #0]
    6830:	061b      	lsls	r3, r3, #24
    6832:	001a      	movs	r2, r3
    6834:	69fb      	ldr	r3, [r7, #28]
    6836:	4313      	orrs	r3, r2
    6838:	61fb      	str	r3, [r7, #28]
		}

		/* Check if the user has requested that the input buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_INPUT) ||
    683a:	687b      	ldr	r3, [r7, #4]
    683c:	785b      	ldrb	r3, [r3, #1]
    683e:	2b00      	cmp	r3, #0
    6840:	d003      	beq.n	684a <_system_pinmux_config+0x4e>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
    6842:	687b      	ldr	r3, [r7, #4]
    6844:	785b      	ldrb	r3, [r3, #1]
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_INPUT) ||
    6846:	2b02      	cmp	r3, #2
    6848:	d110      	bne.n	686c <_system_pinmux_config+0x70>
			/* Enable input buffer flag */
			pin_cfg |= PORT_WRCONFIG_INEN;
    684a:	69fb      	ldr	r3, [r7, #28]
    684c:	2280      	movs	r2, #128	; 0x80
    684e:	0292      	lsls	r2, r2, #10
    6850:	4313      	orrs	r3, r2
    6852:	61fb      	str	r3, [r7, #28]

			/* Enable pull-up/pull-down control flag if requested */
			if (config->input_pull != SYSTEM_PINMUX_PIN_PULL_NONE) {
    6854:	687b      	ldr	r3, [r7, #4]
    6856:	789b      	ldrb	r3, [r3, #2]
    6858:	2b00      	cmp	r3, #0
    685a:	d004      	beq.n	6866 <_system_pinmux_config+0x6a>
				pin_cfg |= PORT_WRCONFIG_PULLEN;
    685c:	69fb      	ldr	r3, [r7, #28]
    685e:	2280      	movs	r2, #128	; 0x80
    6860:	02d2      	lsls	r2, r2, #11
    6862:	4313      	orrs	r3, r2
    6864:	61fb      	str	r3, [r7, #28]
			}

			/* Clear the port DIR bits to disable the output buffer */
			port->DIRCLR.reg = pin_mask;
    6866:	68fb      	ldr	r3, [r7, #12]
    6868:	68ba      	ldr	r2, [r7, #8]
    686a:	605a      	str	r2, [r3, #4]
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    686c:	687b      	ldr	r3, [r7, #4]
    686e:	785b      	ldrb	r3, [r3, #1]
    6870:	2b01      	cmp	r3, #1
    6872:	d003      	beq.n	687c <_system_pinmux_config+0x80>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
    6874:	687b      	ldr	r3, [r7, #4]
    6876:	785b      	ldrb	r3, [r3, #1]
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    6878:	2b02      	cmp	r3, #2
    687a:	d107      	bne.n	688c <_system_pinmux_config+0x90>
			/* Cannot use a pull-up if the output driver is enabled,
			 * if requested the input buffer can only sample the current
			 * output state */
			pin_cfg &= ~PORT_WRCONFIG_PULLEN;
    687c:	69fb      	ldr	r3, [r7, #28]
    687e:	4a22      	ldr	r2, [pc, #136]	; (6908 <_system_pinmux_config+0x10c>)
    6880:	4013      	ands	r3, r2
    6882:	61fb      	str	r3, [r7, #28]
    6884:	e002      	b.n	688c <_system_pinmux_config+0x90>
		}
	} else {
		port->DIRCLR.reg = pin_mask;
    6886:	68fb      	ldr	r3, [r7, #12]
    6888:	68ba      	ldr	r2, [r7, #8]
    688a:	605a      	str	r2, [r3, #4]
	}

	/* The Write Configuration register (WRCONFIG) requires the
	 * pins to to grouped into two 16-bit half-words - split them out here */
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
    688c:	68bb      	ldr	r3, [r7, #8]
    688e:	041b      	lsls	r3, r3, #16
    6890:	0c1b      	lsrs	r3, r3, #16
    6892:	61bb      	str	r3, [r7, #24]
	uint32_t upper_pin_mask = (pin_mask >> 16);
    6894:	68bb      	ldr	r3, [r7, #8]
    6896:	0c1b      	lsrs	r3, r3, #16
    6898:	617b      	str	r3, [r7, #20]

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    689a:	69ba      	ldr	r2, [r7, #24]
    689c:	69fb      	ldr	r3, [r7, #28]
    689e:	4313      	orrs	r3, r2
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;
    68a0:	22a0      	movs	r2, #160	; 0xa0
    68a2:	05d2      	lsls	r2, r2, #23
    68a4:	431a      	orrs	r2, r3
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    68a6:	68fb      	ldr	r3, [r7, #12]
    68a8:	629a      	str	r2, [r3, #40]	; 0x28

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    68aa:	697a      	ldr	r2, [r7, #20]
    68ac:	69fb      	ldr	r3, [r7, #28]
    68ae:	4313      	orrs	r3, r2
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
    68b0:	22d0      	movs	r2, #208	; 0xd0
    68b2:	0612      	lsls	r2, r2, #24
    68b4:	431a      	orrs	r2, r3
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    68b6:	68fb      	ldr	r3, [r7, #12]
    68b8:	629a      	str	r2, [r3, #40]	; 0x28
			PORT_WRCONFIG_HWSEL;

	if(!config->powersave) {
    68ba:	687b      	ldr	r3, [r7, #4]
    68bc:	78db      	ldrb	r3, [r3, #3]
    68be:	2201      	movs	r2, #1
    68c0:	4053      	eors	r3, r2
    68c2:	b2db      	uxtb	r3, r3
    68c4:	2b00      	cmp	r3, #0
    68c6:	d01a      	beq.n	68fe <_system_pinmux_config+0x102>
		/* Set the pull-up state once the port pins are configured if one was
		 * requested and it does not violate the valid set of port
		 * configurations */
		if (pin_cfg & PORT_WRCONFIG_PULLEN) {
    68c8:	69fa      	ldr	r2, [r7, #28]
    68ca:	2380      	movs	r3, #128	; 0x80
    68cc:	02db      	lsls	r3, r3, #11
    68ce:	4013      	ands	r3, r2
    68d0:	d00a      	beq.n	68e8 <_system_pinmux_config+0xec>
			/* Set the OUT register bits to enable the pull-up if requested,
			 * clear to enable pull-down */
			if (config->input_pull == SYSTEM_PINMUX_PIN_PULL_UP) {
    68d2:	687b      	ldr	r3, [r7, #4]
    68d4:	789b      	ldrb	r3, [r3, #2]
    68d6:	2b01      	cmp	r3, #1
    68d8:	d103      	bne.n	68e2 <_system_pinmux_config+0xe6>
				port->OUTSET.reg = pin_mask;
    68da:	68fb      	ldr	r3, [r7, #12]
    68dc:	68ba      	ldr	r2, [r7, #8]
    68de:	619a      	str	r2, [r3, #24]
    68e0:	e002      	b.n	68e8 <_system_pinmux_config+0xec>
			} else {
				port->OUTCLR.reg = pin_mask;
    68e2:	68fb      	ldr	r3, [r7, #12]
    68e4:	68ba      	ldr	r2, [r7, #8]
    68e6:	615a      	str	r2, [r3, #20]
			}
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    68e8:	687b      	ldr	r3, [r7, #4]
    68ea:	785b      	ldrb	r3, [r3, #1]
    68ec:	2b01      	cmp	r3, #1
    68ee:	d003      	beq.n	68f8 <_system_pinmux_config+0xfc>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
    68f0:	687b      	ldr	r3, [r7, #4]
    68f2:	785b      	ldrb	r3, [r3, #1]
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    68f4:	2b02      	cmp	r3, #2
    68f6:	d102      	bne.n	68fe <_system_pinmux_config+0x102>
			/* Set the port DIR bits to enable the output buffer */
			port->DIRSET.reg = pin_mask;
    68f8:	68fb      	ldr	r3, [r7, #12]
    68fa:	68ba      	ldr	r2, [r7, #8]
    68fc:	609a      	str	r2, [r3, #8]
		}
	}
}
    68fe:	46c0      	nop			; (mov r8, r8)
    6900:	46bd      	mov	sp, r7
    6902:	b008      	add	sp, #32
    6904:	bd80      	pop	{r7, pc}
    6906:	46c0      	nop			; (mov r8, r8)
    6908:	fffbffff 	.word	0xfffbffff

0000690c <system_pinmux_pin_set_config>:
 * \param[in] config    Configuration settings for the pin
 */
void system_pinmux_pin_set_config(
		const uint8_t gpio_pin,
		const struct system_pinmux_config *const config)
{
    690c:	b580      	push	{r7, lr}
    690e:	b084      	sub	sp, #16
    6910:	af00      	add	r7, sp, #0
    6912:	0002      	movs	r2, r0
    6914:	6039      	str	r1, [r7, #0]
    6916:	1dfb      	adds	r3, r7, #7
    6918:	701a      	strb	r2, [r3, #0]
	PortGroup *const port = system_pinmux_get_group_from_gpio_pin(gpio_pin);
    691a:	1dfb      	adds	r3, r7, #7
    691c:	781b      	ldrb	r3, [r3, #0]
    691e:	0018      	movs	r0, r3
    6920:	4b0a      	ldr	r3, [pc, #40]	; (694c <system_pinmux_pin_set_config+0x40>)
    6922:	4798      	blx	r3
    6924:	0003      	movs	r3, r0
    6926:	60fb      	str	r3, [r7, #12]
	uint32_t pin_mask = (1UL << (gpio_pin % 32));
    6928:	1dfb      	adds	r3, r7, #7
    692a:	781b      	ldrb	r3, [r3, #0]
    692c:	221f      	movs	r2, #31
    692e:	4013      	ands	r3, r2
    6930:	2201      	movs	r2, #1
    6932:	409a      	lsls	r2, r3
    6934:	0013      	movs	r3, r2
    6936:	60bb      	str	r3, [r7, #8]

	_system_pinmux_config(port, pin_mask, config);
    6938:	683a      	ldr	r2, [r7, #0]
    693a:	68b9      	ldr	r1, [r7, #8]
    693c:	68fb      	ldr	r3, [r7, #12]
    693e:	0018      	movs	r0, r3
    6940:	4b03      	ldr	r3, [pc, #12]	; (6950 <system_pinmux_pin_set_config+0x44>)
    6942:	4798      	blx	r3
}
    6944:	46c0      	nop			; (mov r8, r8)
    6946:	46bd      	mov	sp, r7
    6948:	b004      	add	sp, #16
    694a:	bd80      	pop	{r7, pc}
    694c:	0000679d 	.word	0x0000679d
    6950:	000067fd 	.word	0x000067fd

00006954 <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
    6954:	b580      	push	{r7, lr}
    6956:	b082      	sub	sp, #8
    6958:	af00      	add	r7, sp, #0
        uint32_t *pSrc, *pDest;

        /* Initialize the relocate segment */
        pSrc = &_etext;
    695a:	4b16      	ldr	r3, [pc, #88]	; (69b4 <Reset_Handler+0x60>)
    695c:	607b      	str	r3, [r7, #4]
        pDest = &_srelocate;
    695e:	4b16      	ldr	r3, [pc, #88]	; (69b8 <Reset_Handler+0x64>)
    6960:	603b      	str	r3, [r7, #0]

        if (pSrc != pDest) {
    6962:	687a      	ldr	r2, [r7, #4]
    6964:	683b      	ldr	r3, [r7, #0]
    6966:	429a      	cmp	r2, r3
    6968:	d00c      	beq.n	6984 <Reset_Handler+0x30>
                for (; pDest < &_erelocate;) {
    696a:	e007      	b.n	697c <Reset_Handler+0x28>
                        *pDest++ = *pSrc++;
    696c:	683b      	ldr	r3, [r7, #0]
    696e:	1d1a      	adds	r2, r3, #4
    6970:	603a      	str	r2, [r7, #0]
    6972:	687a      	ldr	r2, [r7, #4]
    6974:	1d11      	adds	r1, r2, #4
    6976:	6079      	str	r1, [r7, #4]
    6978:	6812      	ldr	r2, [r2, #0]
    697a:	601a      	str	r2, [r3, #0]
                for (; pDest < &_erelocate;) {
    697c:	683a      	ldr	r2, [r7, #0]
    697e:	4b0f      	ldr	r3, [pc, #60]	; (69bc <Reset_Handler+0x68>)
    6980:	429a      	cmp	r2, r3
    6982:	d3f3      	bcc.n	696c <Reset_Handler+0x18>
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
    6984:	4b0e      	ldr	r3, [pc, #56]	; (69c0 <Reset_Handler+0x6c>)
    6986:	603b      	str	r3, [r7, #0]
    6988:	e004      	b.n	6994 <Reset_Handler+0x40>
                *pDest++ = 0;
    698a:	683b      	ldr	r3, [r7, #0]
    698c:	1d1a      	adds	r2, r3, #4
    698e:	603a      	str	r2, [r7, #0]
    6990:	2200      	movs	r2, #0
    6992:	601a      	str	r2, [r3, #0]
        for (pDest = &_szero; pDest < &_ezero;) {
    6994:	683a      	ldr	r2, [r7, #0]
    6996:	4b0b      	ldr	r3, [pc, #44]	; (69c4 <Reset_Handler+0x70>)
    6998:	429a      	cmp	r2, r3
    699a:	d3f6      	bcc.n	698a <Reset_Handler+0x36>
        }

        /* Set the vector table base address */
        pSrc = (uint32_t *) & _sfixed;
    699c:	4b0a      	ldr	r3, [pc, #40]	; (69c8 <Reset_Handler+0x74>)
    699e:	607b      	str	r3, [r7, #4]
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
    69a0:	4b0a      	ldr	r3, [pc, #40]	; (69cc <Reset_Handler+0x78>)
    69a2:	687a      	ldr	r2, [r7, #4]
    69a4:	21ff      	movs	r1, #255	; 0xff
    69a6:	438a      	bics	r2, r1
    69a8:	609a      	str	r2, [r3, #8]

        /* Initialize the C library */
        __libc_init_array();
    69aa:	4b09      	ldr	r3, [pc, #36]	; (69d0 <Reset_Handler+0x7c>)
    69ac:	4798      	blx	r3

        /* Branch to main function */
        main();
    69ae:	4b09      	ldr	r3, [pc, #36]	; (69d4 <Reset_Handler+0x80>)
    69b0:	4798      	blx	r3

        /* Infinite loop */
        while (1);
    69b2:	e7fe      	b.n	69b2 <Reset_Handler+0x5e>
    69b4:	00007684 	.word	0x00007684
    69b8:	20000000 	.word	0x20000000
    69bc:	200001e4 	.word	0x200001e4
    69c0:	200001e4 	.word	0x200001e4
    69c4:	20003394 	.word	0x20003394
    69c8:	00000000 	.word	0x00000000
    69cc:	e000ed00 	.word	0xe000ed00
    69d0:	00006b95 	.word	0x00006b95
    69d4:	0000604d 	.word	0x0000604d

000069d8 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
    69d8:	b580      	push	{r7, lr}
    69da:	af00      	add	r7, sp, #0
        while (1) {
    69dc:	e7fe      	b.n	69dc <Dummy_Handler+0x4>
	...

000069e0 <_sbrk>:
extern void _exit(int status);
extern void _kill(int pid, int sig);
extern int _getpid(void);

extern caddr_t _sbrk(int incr)
{
    69e0:	b580      	push	{r7, lr}
    69e2:	b084      	sub	sp, #16
    69e4:	af00      	add	r7, sp, #0
    69e6:	6078      	str	r0, [r7, #4]
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;

	if (heap == NULL) {
    69e8:	4b0a      	ldr	r3, [pc, #40]	; (6a14 <_sbrk+0x34>)
    69ea:	681b      	ldr	r3, [r3, #0]
    69ec:	2b00      	cmp	r3, #0
    69ee:	d102      	bne.n	69f6 <_sbrk+0x16>
		heap = (unsigned char *)&_end;
    69f0:	4b08      	ldr	r3, [pc, #32]	; (6a14 <_sbrk+0x34>)
    69f2:	4a09      	ldr	r2, [pc, #36]	; (6a18 <_sbrk+0x38>)
    69f4:	601a      	str	r2, [r3, #0]
	}
	prev_heap = heap;
    69f6:	4b07      	ldr	r3, [pc, #28]	; (6a14 <_sbrk+0x34>)
    69f8:	681b      	ldr	r3, [r3, #0]
    69fa:	60fb      	str	r3, [r7, #12]

	heap += incr;
    69fc:	4b05      	ldr	r3, [pc, #20]	; (6a14 <_sbrk+0x34>)
    69fe:	681a      	ldr	r2, [r3, #0]
    6a00:	687b      	ldr	r3, [r7, #4]
    6a02:	18d2      	adds	r2, r2, r3
    6a04:	4b03      	ldr	r3, [pc, #12]	; (6a14 <_sbrk+0x34>)
    6a06:	601a      	str	r2, [r3, #0]

	return (caddr_t) prev_heap;
    6a08:	68fb      	ldr	r3, [r7, #12]
}
    6a0a:	0018      	movs	r0, r3
    6a0c:	46bd      	mov	sp, r7
    6a0e:	b004      	add	sp, #16
    6a10:	bd80      	pop	{r7, pc}
    6a12:	46c0      	nop			; (mov r8, r8)
    6a14:	200032f8 	.word	0x200032f8
    6a18:	20005398 	.word	0x20005398

00006a1c <__udivsi3>:
    6a1c:	2200      	movs	r2, #0
    6a1e:	0843      	lsrs	r3, r0, #1
    6a20:	428b      	cmp	r3, r1
    6a22:	d374      	bcc.n	6b0e <__udivsi3+0xf2>
    6a24:	0903      	lsrs	r3, r0, #4
    6a26:	428b      	cmp	r3, r1
    6a28:	d35f      	bcc.n	6aea <__udivsi3+0xce>
    6a2a:	0a03      	lsrs	r3, r0, #8
    6a2c:	428b      	cmp	r3, r1
    6a2e:	d344      	bcc.n	6aba <__udivsi3+0x9e>
    6a30:	0b03      	lsrs	r3, r0, #12
    6a32:	428b      	cmp	r3, r1
    6a34:	d328      	bcc.n	6a88 <__udivsi3+0x6c>
    6a36:	0c03      	lsrs	r3, r0, #16
    6a38:	428b      	cmp	r3, r1
    6a3a:	d30d      	bcc.n	6a58 <__udivsi3+0x3c>
    6a3c:	22ff      	movs	r2, #255	; 0xff
    6a3e:	0209      	lsls	r1, r1, #8
    6a40:	ba12      	rev	r2, r2
    6a42:	0c03      	lsrs	r3, r0, #16
    6a44:	428b      	cmp	r3, r1
    6a46:	d302      	bcc.n	6a4e <__udivsi3+0x32>
    6a48:	1212      	asrs	r2, r2, #8
    6a4a:	0209      	lsls	r1, r1, #8
    6a4c:	d065      	beq.n	6b1a <__udivsi3+0xfe>
    6a4e:	0b03      	lsrs	r3, r0, #12
    6a50:	428b      	cmp	r3, r1
    6a52:	d319      	bcc.n	6a88 <__udivsi3+0x6c>
    6a54:	e000      	b.n	6a58 <__udivsi3+0x3c>
    6a56:	0a09      	lsrs	r1, r1, #8
    6a58:	0bc3      	lsrs	r3, r0, #15
    6a5a:	428b      	cmp	r3, r1
    6a5c:	d301      	bcc.n	6a62 <__udivsi3+0x46>
    6a5e:	03cb      	lsls	r3, r1, #15
    6a60:	1ac0      	subs	r0, r0, r3
    6a62:	4152      	adcs	r2, r2
    6a64:	0b83      	lsrs	r3, r0, #14
    6a66:	428b      	cmp	r3, r1
    6a68:	d301      	bcc.n	6a6e <__udivsi3+0x52>
    6a6a:	038b      	lsls	r3, r1, #14
    6a6c:	1ac0      	subs	r0, r0, r3
    6a6e:	4152      	adcs	r2, r2
    6a70:	0b43      	lsrs	r3, r0, #13
    6a72:	428b      	cmp	r3, r1
    6a74:	d301      	bcc.n	6a7a <__udivsi3+0x5e>
    6a76:	034b      	lsls	r3, r1, #13
    6a78:	1ac0      	subs	r0, r0, r3
    6a7a:	4152      	adcs	r2, r2
    6a7c:	0b03      	lsrs	r3, r0, #12
    6a7e:	428b      	cmp	r3, r1
    6a80:	d301      	bcc.n	6a86 <__udivsi3+0x6a>
    6a82:	030b      	lsls	r3, r1, #12
    6a84:	1ac0      	subs	r0, r0, r3
    6a86:	4152      	adcs	r2, r2
    6a88:	0ac3      	lsrs	r3, r0, #11
    6a8a:	428b      	cmp	r3, r1
    6a8c:	d301      	bcc.n	6a92 <__udivsi3+0x76>
    6a8e:	02cb      	lsls	r3, r1, #11
    6a90:	1ac0      	subs	r0, r0, r3
    6a92:	4152      	adcs	r2, r2
    6a94:	0a83      	lsrs	r3, r0, #10
    6a96:	428b      	cmp	r3, r1
    6a98:	d301      	bcc.n	6a9e <__udivsi3+0x82>
    6a9a:	028b      	lsls	r3, r1, #10
    6a9c:	1ac0      	subs	r0, r0, r3
    6a9e:	4152      	adcs	r2, r2
    6aa0:	0a43      	lsrs	r3, r0, #9
    6aa2:	428b      	cmp	r3, r1
    6aa4:	d301      	bcc.n	6aaa <__udivsi3+0x8e>
    6aa6:	024b      	lsls	r3, r1, #9
    6aa8:	1ac0      	subs	r0, r0, r3
    6aaa:	4152      	adcs	r2, r2
    6aac:	0a03      	lsrs	r3, r0, #8
    6aae:	428b      	cmp	r3, r1
    6ab0:	d301      	bcc.n	6ab6 <__udivsi3+0x9a>
    6ab2:	020b      	lsls	r3, r1, #8
    6ab4:	1ac0      	subs	r0, r0, r3
    6ab6:	4152      	adcs	r2, r2
    6ab8:	d2cd      	bcs.n	6a56 <__udivsi3+0x3a>
    6aba:	09c3      	lsrs	r3, r0, #7
    6abc:	428b      	cmp	r3, r1
    6abe:	d301      	bcc.n	6ac4 <__udivsi3+0xa8>
    6ac0:	01cb      	lsls	r3, r1, #7
    6ac2:	1ac0      	subs	r0, r0, r3
    6ac4:	4152      	adcs	r2, r2
    6ac6:	0983      	lsrs	r3, r0, #6
    6ac8:	428b      	cmp	r3, r1
    6aca:	d301      	bcc.n	6ad0 <__udivsi3+0xb4>
    6acc:	018b      	lsls	r3, r1, #6
    6ace:	1ac0      	subs	r0, r0, r3
    6ad0:	4152      	adcs	r2, r2
    6ad2:	0943      	lsrs	r3, r0, #5
    6ad4:	428b      	cmp	r3, r1
    6ad6:	d301      	bcc.n	6adc <__udivsi3+0xc0>
    6ad8:	014b      	lsls	r3, r1, #5
    6ada:	1ac0      	subs	r0, r0, r3
    6adc:	4152      	adcs	r2, r2
    6ade:	0903      	lsrs	r3, r0, #4
    6ae0:	428b      	cmp	r3, r1
    6ae2:	d301      	bcc.n	6ae8 <__udivsi3+0xcc>
    6ae4:	010b      	lsls	r3, r1, #4
    6ae6:	1ac0      	subs	r0, r0, r3
    6ae8:	4152      	adcs	r2, r2
    6aea:	08c3      	lsrs	r3, r0, #3
    6aec:	428b      	cmp	r3, r1
    6aee:	d301      	bcc.n	6af4 <__udivsi3+0xd8>
    6af0:	00cb      	lsls	r3, r1, #3
    6af2:	1ac0      	subs	r0, r0, r3
    6af4:	4152      	adcs	r2, r2
    6af6:	0883      	lsrs	r3, r0, #2
    6af8:	428b      	cmp	r3, r1
    6afa:	d301      	bcc.n	6b00 <__udivsi3+0xe4>
    6afc:	008b      	lsls	r3, r1, #2
    6afe:	1ac0      	subs	r0, r0, r3
    6b00:	4152      	adcs	r2, r2
    6b02:	0843      	lsrs	r3, r0, #1
    6b04:	428b      	cmp	r3, r1
    6b06:	d301      	bcc.n	6b0c <__udivsi3+0xf0>
    6b08:	004b      	lsls	r3, r1, #1
    6b0a:	1ac0      	subs	r0, r0, r3
    6b0c:	4152      	adcs	r2, r2
    6b0e:	1a41      	subs	r1, r0, r1
    6b10:	d200      	bcs.n	6b14 <__udivsi3+0xf8>
    6b12:	4601      	mov	r1, r0
    6b14:	4152      	adcs	r2, r2
    6b16:	4610      	mov	r0, r2
    6b18:	4770      	bx	lr
    6b1a:	e7ff      	b.n	6b1c <__udivsi3+0x100>
    6b1c:	b501      	push	{r0, lr}
    6b1e:	2000      	movs	r0, #0
    6b20:	f000 f806 	bl	6b30 <__aeabi_idiv0>
    6b24:	bd02      	pop	{r1, pc}
    6b26:	46c0      	nop			; (mov r8, r8)

00006b28 <__aeabi_uidivmod>:
    6b28:	2900      	cmp	r1, #0
    6b2a:	d0f7      	beq.n	6b1c <__udivsi3+0x100>
    6b2c:	e776      	b.n	6a1c <__udivsi3>
    6b2e:	4770      	bx	lr

00006b30 <__aeabi_idiv0>:
    6b30:	4770      	bx	lr
    6b32:	46c0      	nop			; (mov r8, r8)

00006b34 <__aeabi_lmul>:
    6b34:	b5f0      	push	{r4, r5, r6, r7, lr}
    6b36:	46ce      	mov	lr, r9
    6b38:	4647      	mov	r7, r8
    6b3a:	0415      	lsls	r5, r2, #16
    6b3c:	0c2d      	lsrs	r5, r5, #16
    6b3e:	002e      	movs	r6, r5
    6b40:	b580      	push	{r7, lr}
    6b42:	0407      	lsls	r7, r0, #16
    6b44:	0c14      	lsrs	r4, r2, #16
    6b46:	0c3f      	lsrs	r7, r7, #16
    6b48:	4699      	mov	r9, r3
    6b4a:	0c03      	lsrs	r3, r0, #16
    6b4c:	437e      	muls	r6, r7
    6b4e:	435d      	muls	r5, r3
    6b50:	4367      	muls	r7, r4
    6b52:	4363      	muls	r3, r4
    6b54:	197f      	adds	r7, r7, r5
    6b56:	0c34      	lsrs	r4, r6, #16
    6b58:	19e4      	adds	r4, r4, r7
    6b5a:	469c      	mov	ip, r3
    6b5c:	42a5      	cmp	r5, r4
    6b5e:	d903      	bls.n	6b68 <__aeabi_lmul+0x34>
    6b60:	2380      	movs	r3, #128	; 0x80
    6b62:	025b      	lsls	r3, r3, #9
    6b64:	4698      	mov	r8, r3
    6b66:	44c4      	add	ip, r8
    6b68:	464b      	mov	r3, r9
    6b6a:	4351      	muls	r1, r2
    6b6c:	4343      	muls	r3, r0
    6b6e:	0436      	lsls	r6, r6, #16
    6b70:	0c36      	lsrs	r6, r6, #16
    6b72:	0c25      	lsrs	r5, r4, #16
    6b74:	0424      	lsls	r4, r4, #16
    6b76:	4465      	add	r5, ip
    6b78:	19a4      	adds	r4, r4, r6
    6b7a:	1859      	adds	r1, r3, r1
    6b7c:	1949      	adds	r1, r1, r5
    6b7e:	0020      	movs	r0, r4
    6b80:	bc0c      	pop	{r2, r3}
    6b82:	4690      	mov	r8, r2
    6b84:	4699      	mov	r9, r3
    6b86:	bdf0      	pop	{r4, r5, r6, r7, pc}

00006b88 <atoi>:
    6b88:	b510      	push	{r4, lr}
    6b8a:	220a      	movs	r2, #10
    6b8c:	2100      	movs	r1, #0
    6b8e:	f000 f94f 	bl	6e30 <strtol>
    6b92:	bd10      	pop	{r4, pc}

00006b94 <__libc_init_array>:
    6b94:	b570      	push	{r4, r5, r6, lr}
    6b96:	2600      	movs	r6, #0
    6b98:	4d0c      	ldr	r5, [pc, #48]	; (6bcc <__libc_init_array+0x38>)
    6b9a:	4c0d      	ldr	r4, [pc, #52]	; (6bd0 <__libc_init_array+0x3c>)
    6b9c:	1b64      	subs	r4, r4, r5
    6b9e:	10a4      	asrs	r4, r4, #2
    6ba0:	42a6      	cmp	r6, r4
    6ba2:	d109      	bne.n	6bb8 <__libc_init_array+0x24>
    6ba4:	2600      	movs	r6, #0
    6ba6:	f000 fd5d 	bl	7664 <_init>
    6baa:	4d0a      	ldr	r5, [pc, #40]	; (6bd4 <__libc_init_array+0x40>)
    6bac:	4c0a      	ldr	r4, [pc, #40]	; (6bd8 <__libc_init_array+0x44>)
    6bae:	1b64      	subs	r4, r4, r5
    6bb0:	10a4      	asrs	r4, r4, #2
    6bb2:	42a6      	cmp	r6, r4
    6bb4:	d105      	bne.n	6bc2 <__libc_init_array+0x2e>
    6bb6:	bd70      	pop	{r4, r5, r6, pc}
    6bb8:	00b3      	lsls	r3, r6, #2
    6bba:	58eb      	ldr	r3, [r5, r3]
    6bbc:	4798      	blx	r3
    6bbe:	3601      	adds	r6, #1
    6bc0:	e7ee      	b.n	6ba0 <__libc_init_array+0xc>
    6bc2:	00b3      	lsls	r3, r6, #2
    6bc4:	58eb      	ldr	r3, [r5, r3]
    6bc6:	4798      	blx	r3
    6bc8:	3601      	adds	r6, #1
    6bca:	e7f2      	b.n	6bb2 <__libc_init_array+0x1e>
    6bcc:	00007670 	.word	0x00007670
    6bd0:	00007670 	.word	0x00007670
    6bd4:	00007670 	.word	0x00007670
    6bd8:	00007674 	.word	0x00007674

00006bdc <__locale_ctype_ptr_l>:
    6bdc:	30ec      	adds	r0, #236	; 0xec
    6bde:	6800      	ldr	r0, [r0, #0]
    6be0:	4770      	bx	lr
	...

00006be4 <__locale_ctype_ptr>:
    6be4:	4b04      	ldr	r3, [pc, #16]	; (6bf8 <__locale_ctype_ptr+0x14>)
    6be6:	681b      	ldr	r3, [r3, #0]
    6be8:	6a1b      	ldr	r3, [r3, #32]
    6bea:	2b00      	cmp	r3, #0
    6bec:	d100      	bne.n	6bf0 <__locale_ctype_ptr+0xc>
    6bee:	4b03      	ldr	r3, [pc, #12]	; (6bfc <__locale_ctype_ptr+0x18>)
    6bf0:	33ec      	adds	r3, #236	; 0xec
    6bf2:	6818      	ldr	r0, [r3, #0]
    6bf4:	4770      	bx	lr
    6bf6:	46c0      	nop			; (mov r8, r8)
    6bf8:	20000014 	.word	0x20000014
    6bfc:	20000078 	.word	0x20000078

00006c00 <__ascii_mbtowc>:
    6c00:	b082      	sub	sp, #8
    6c02:	2900      	cmp	r1, #0
    6c04:	d100      	bne.n	6c08 <__ascii_mbtowc+0x8>
    6c06:	a901      	add	r1, sp, #4
    6c08:	1e10      	subs	r0, r2, #0
    6c0a:	d006      	beq.n	6c1a <__ascii_mbtowc+0x1a>
    6c0c:	2b00      	cmp	r3, #0
    6c0e:	d006      	beq.n	6c1e <__ascii_mbtowc+0x1e>
    6c10:	7813      	ldrb	r3, [r2, #0]
    6c12:	600b      	str	r3, [r1, #0]
    6c14:	7810      	ldrb	r0, [r2, #0]
    6c16:	1e43      	subs	r3, r0, #1
    6c18:	4198      	sbcs	r0, r3
    6c1a:	b002      	add	sp, #8
    6c1c:	4770      	bx	lr
    6c1e:	2002      	movs	r0, #2
    6c20:	4240      	negs	r0, r0
    6c22:	e7fa      	b.n	6c1a <__ascii_mbtowc+0x1a>

00006c24 <memcpy>:
    6c24:	2300      	movs	r3, #0
    6c26:	b510      	push	{r4, lr}
    6c28:	429a      	cmp	r2, r3
    6c2a:	d100      	bne.n	6c2e <memcpy+0xa>
    6c2c:	bd10      	pop	{r4, pc}
    6c2e:	5ccc      	ldrb	r4, [r1, r3]
    6c30:	54c4      	strb	r4, [r0, r3]
    6c32:	3301      	adds	r3, #1
    6c34:	e7f8      	b.n	6c28 <memcpy+0x4>

00006c36 <memset>:
    6c36:	0003      	movs	r3, r0
    6c38:	1882      	adds	r2, r0, r2
    6c3a:	4293      	cmp	r3, r2
    6c3c:	d100      	bne.n	6c40 <memset+0xa>
    6c3e:	4770      	bx	lr
    6c40:	7019      	strb	r1, [r3, #0]
    6c42:	3301      	adds	r3, #1
    6c44:	e7f9      	b.n	6c3a <memset+0x4>

00006c46 <strcmp>:
    6c46:	7802      	ldrb	r2, [r0, #0]
    6c48:	780b      	ldrb	r3, [r1, #0]
    6c4a:	2a00      	cmp	r2, #0
    6c4c:	d003      	beq.n	6c56 <strcmp+0x10>
    6c4e:	3001      	adds	r0, #1
    6c50:	3101      	adds	r1, #1
    6c52:	429a      	cmp	r2, r3
    6c54:	d0f7      	beq.n	6c46 <strcmp>
    6c56:	1ad0      	subs	r0, r2, r3
    6c58:	4770      	bx	lr

00006c5a <strcpy>:
    6c5a:	1c03      	adds	r3, r0, #0
    6c5c:	780a      	ldrb	r2, [r1, #0]
    6c5e:	3101      	adds	r1, #1
    6c60:	701a      	strb	r2, [r3, #0]
    6c62:	3301      	adds	r3, #1
    6c64:	2a00      	cmp	r2, #0
    6c66:	d1f9      	bne.n	6c5c <strcpy+0x2>
    6c68:	4770      	bx	lr

00006c6a <strlen>:
    6c6a:	2300      	movs	r3, #0
    6c6c:	5cc2      	ldrb	r2, [r0, r3]
    6c6e:	3301      	adds	r3, #1
    6c70:	2a00      	cmp	r2, #0
    6c72:	d1fb      	bne.n	6c6c <strlen+0x2>
    6c74:	1e58      	subs	r0, r3, #1
    6c76:	4770      	bx	lr

00006c78 <strtok>:
    6c78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    6c7a:	4b12      	ldr	r3, [pc, #72]	; (6cc4 <strtok+0x4c>)
    6c7c:	0006      	movs	r6, r0
    6c7e:	681d      	ldr	r5, [r3, #0]
    6c80:	000f      	movs	r7, r1
    6c82:	6dac      	ldr	r4, [r5, #88]	; 0x58
    6c84:	2c00      	cmp	r4, #0
    6c86:	d116      	bne.n	6cb6 <strtok+0x3e>
    6c88:	2050      	movs	r0, #80	; 0x50
    6c8a:	f000 f8f1 	bl	6e70 <malloc>
    6c8e:	65a8      	str	r0, [r5, #88]	; 0x58
    6c90:	6004      	str	r4, [r0, #0]
    6c92:	6044      	str	r4, [r0, #4]
    6c94:	6084      	str	r4, [r0, #8]
    6c96:	60c4      	str	r4, [r0, #12]
    6c98:	6104      	str	r4, [r0, #16]
    6c9a:	6144      	str	r4, [r0, #20]
    6c9c:	6184      	str	r4, [r0, #24]
    6c9e:	6284      	str	r4, [r0, #40]	; 0x28
    6ca0:	62c4      	str	r4, [r0, #44]	; 0x2c
    6ca2:	6304      	str	r4, [r0, #48]	; 0x30
    6ca4:	6344      	str	r4, [r0, #52]	; 0x34
    6ca6:	6384      	str	r4, [r0, #56]	; 0x38
    6ca8:	63c4      	str	r4, [r0, #60]	; 0x3c
    6caa:	6404      	str	r4, [r0, #64]	; 0x40
    6cac:	6444      	str	r4, [r0, #68]	; 0x44
    6cae:	6484      	str	r4, [r0, #72]	; 0x48
    6cb0:	64c4      	str	r4, [r0, #76]	; 0x4c
    6cb2:	7704      	strb	r4, [r0, #28]
    6cb4:	6244      	str	r4, [r0, #36]	; 0x24
    6cb6:	6daa      	ldr	r2, [r5, #88]	; 0x58
    6cb8:	0039      	movs	r1, r7
    6cba:	0030      	movs	r0, r6
    6cbc:	2301      	movs	r3, #1
    6cbe:	f000 f803 	bl	6cc8 <__strtok_r>
    6cc2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    6cc4:	20000014 	.word	0x20000014

00006cc8 <__strtok_r>:
    6cc8:	b5f0      	push	{r4, r5, r6, r7, lr}
    6cca:	2800      	cmp	r0, #0
    6ccc:	d104      	bne.n	6cd8 <__strtok_r+0x10>
    6cce:	6810      	ldr	r0, [r2, #0]
    6cd0:	2800      	cmp	r0, #0
    6cd2:	d101      	bne.n	6cd8 <__strtok_r+0x10>
    6cd4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6cd6:	0020      	movs	r0, r4
    6cd8:	000e      	movs	r6, r1
    6cda:	7805      	ldrb	r5, [r0, #0]
    6cdc:	1c44      	adds	r4, r0, #1
    6cde:	7837      	ldrb	r7, [r6, #0]
    6ce0:	2f00      	cmp	r7, #0
    6ce2:	d104      	bne.n	6cee <__strtok_r+0x26>
    6ce4:	2d00      	cmp	r5, #0
    6ce6:	d110      	bne.n	6d0a <__strtok_r+0x42>
    6ce8:	6015      	str	r5, [r2, #0]
    6cea:	0028      	movs	r0, r5
    6cec:	e7f2      	b.n	6cd4 <__strtok_r+0xc>
    6cee:	3601      	adds	r6, #1
    6cf0:	42bd      	cmp	r5, r7
    6cf2:	d1f4      	bne.n	6cde <__strtok_r+0x16>
    6cf4:	2b00      	cmp	r3, #0
    6cf6:	d1ee      	bne.n	6cd6 <__strtok_r+0xe>
    6cf8:	6014      	str	r4, [r2, #0]
    6cfa:	7003      	strb	r3, [r0, #0]
    6cfc:	e7ea      	b.n	6cd4 <__strtok_r+0xc>
    6cfe:	0033      	movs	r3, r6
    6d00:	e00e      	b.n	6d20 <__strtok_r+0x58>
    6d02:	3501      	adds	r5, #1
    6d04:	001c      	movs	r4, r3
    6d06:	2f00      	cmp	r7, #0
    6d08:	d102      	bne.n	6d10 <__strtok_r+0x48>
    6d0a:	000d      	movs	r5, r1
    6d0c:	7826      	ldrb	r6, [r4, #0]
    6d0e:	1c63      	adds	r3, r4, #1
    6d10:	782f      	ldrb	r7, [r5, #0]
    6d12:	42be      	cmp	r6, r7
    6d14:	d1f5      	bne.n	6d02 <__strtok_r+0x3a>
    6d16:	2e00      	cmp	r6, #0
    6d18:	d0f1      	beq.n	6cfe <__strtok_r+0x36>
    6d1a:	2400      	movs	r4, #0
    6d1c:	1e59      	subs	r1, r3, #1
    6d1e:	700c      	strb	r4, [r1, #0]
    6d20:	6013      	str	r3, [r2, #0]
    6d22:	e7d7      	b.n	6cd4 <__strtok_r+0xc>

00006d24 <_strtol_l.isra.0>:
    6d24:	b5f0      	push	{r4, r5, r6, r7, lr}
    6d26:	001f      	movs	r7, r3
    6d28:	000e      	movs	r6, r1
    6d2a:	b087      	sub	sp, #28
    6d2c:	9005      	str	r0, [sp, #20]
    6d2e:	9103      	str	r1, [sp, #12]
    6d30:	9202      	str	r2, [sp, #8]
    6d32:	980c      	ldr	r0, [sp, #48]	; 0x30
    6d34:	7834      	ldrb	r4, [r6, #0]
    6d36:	f7ff ff51 	bl	6bdc <__locale_ctype_ptr_l>
    6d3a:	2208      	movs	r2, #8
    6d3c:	1900      	adds	r0, r0, r4
    6d3e:	7843      	ldrb	r3, [r0, #1]
    6d40:	1c75      	adds	r5, r6, #1
    6d42:	4013      	ands	r3, r2
    6d44:	d10c      	bne.n	6d60 <_strtol_l.isra.0+0x3c>
    6d46:	2c2d      	cmp	r4, #45	; 0x2d
    6d48:	d10c      	bne.n	6d64 <_strtol_l.isra.0+0x40>
    6d4a:	3301      	adds	r3, #1
    6d4c:	782c      	ldrb	r4, [r5, #0]
    6d4e:	9301      	str	r3, [sp, #4]
    6d50:	1cb5      	adds	r5, r6, #2
    6d52:	2f00      	cmp	r7, #0
    6d54:	d00c      	beq.n	6d70 <_strtol_l.isra.0+0x4c>
    6d56:	2f10      	cmp	r7, #16
    6d58:	d114      	bne.n	6d84 <_strtol_l.isra.0+0x60>
    6d5a:	2c30      	cmp	r4, #48	; 0x30
    6d5c:	d00a      	beq.n	6d74 <_strtol_l.isra.0+0x50>
    6d5e:	e011      	b.n	6d84 <_strtol_l.isra.0+0x60>
    6d60:	002e      	movs	r6, r5
    6d62:	e7e6      	b.n	6d32 <_strtol_l.isra.0+0xe>
    6d64:	9301      	str	r3, [sp, #4]
    6d66:	2c2b      	cmp	r4, #43	; 0x2b
    6d68:	d1f3      	bne.n	6d52 <_strtol_l.isra.0+0x2e>
    6d6a:	782c      	ldrb	r4, [r5, #0]
    6d6c:	1cb5      	adds	r5, r6, #2
    6d6e:	e7f0      	b.n	6d52 <_strtol_l.isra.0+0x2e>
    6d70:	2c30      	cmp	r4, #48	; 0x30
    6d72:	d12f      	bne.n	6dd4 <_strtol_l.isra.0+0xb0>
    6d74:	2220      	movs	r2, #32
    6d76:	782b      	ldrb	r3, [r5, #0]
    6d78:	4393      	bics	r3, r2
    6d7a:	2b58      	cmp	r3, #88	; 0x58
    6d7c:	d151      	bne.n	6e22 <_strtol_l.isra.0+0xfe>
    6d7e:	2710      	movs	r7, #16
    6d80:	786c      	ldrb	r4, [r5, #1]
    6d82:	3502      	adds	r5, #2
    6d84:	9b01      	ldr	r3, [sp, #4]
    6d86:	4a29      	ldr	r2, [pc, #164]	; (6e2c <_strtol_l.isra.0+0x108>)
    6d88:	0039      	movs	r1, r7
    6d8a:	189e      	adds	r6, r3, r2
    6d8c:	0030      	movs	r0, r6
    6d8e:	f7ff fecb 	bl	6b28 <__aeabi_uidivmod>
    6d92:	0030      	movs	r0, r6
    6d94:	9104      	str	r1, [sp, #16]
    6d96:	0039      	movs	r1, r7
    6d98:	f7ff fe40 	bl	6a1c <__udivsi3>
    6d9c:	2101      	movs	r1, #1
    6d9e:	2300      	movs	r3, #0
    6da0:	4249      	negs	r1, r1
    6da2:	0002      	movs	r2, r0
    6da4:	468c      	mov	ip, r1
    6da6:	0018      	movs	r0, r3
    6da8:	0021      	movs	r1, r4
    6daa:	3930      	subs	r1, #48	; 0x30
    6dac:	2909      	cmp	r1, #9
    6dae:	d813      	bhi.n	6dd8 <_strtol_l.isra.0+0xb4>
    6db0:	000c      	movs	r4, r1
    6db2:	42a7      	cmp	r7, r4
    6db4:	dd1c      	ble.n	6df0 <_strtol_l.isra.0+0xcc>
    6db6:	1c59      	adds	r1, r3, #1
    6db8:	d009      	beq.n	6dce <_strtol_l.isra.0+0xaa>
    6dba:	4663      	mov	r3, ip
    6dbc:	4282      	cmp	r2, r0
    6dbe:	d306      	bcc.n	6dce <_strtol_l.isra.0+0xaa>
    6dc0:	d102      	bne.n	6dc8 <_strtol_l.isra.0+0xa4>
    6dc2:	9904      	ldr	r1, [sp, #16]
    6dc4:	42a1      	cmp	r1, r4
    6dc6:	db02      	blt.n	6dce <_strtol_l.isra.0+0xaa>
    6dc8:	2301      	movs	r3, #1
    6dca:	4378      	muls	r0, r7
    6dcc:	1820      	adds	r0, r4, r0
    6dce:	782c      	ldrb	r4, [r5, #0]
    6dd0:	3501      	adds	r5, #1
    6dd2:	e7e9      	b.n	6da8 <_strtol_l.isra.0+0x84>
    6dd4:	270a      	movs	r7, #10
    6dd6:	e7d5      	b.n	6d84 <_strtol_l.isra.0+0x60>
    6dd8:	0021      	movs	r1, r4
    6dda:	3941      	subs	r1, #65	; 0x41
    6ddc:	2919      	cmp	r1, #25
    6dde:	d801      	bhi.n	6de4 <_strtol_l.isra.0+0xc0>
    6de0:	3c37      	subs	r4, #55	; 0x37
    6de2:	e7e6      	b.n	6db2 <_strtol_l.isra.0+0x8e>
    6de4:	0021      	movs	r1, r4
    6de6:	3961      	subs	r1, #97	; 0x61
    6de8:	2919      	cmp	r1, #25
    6dea:	d801      	bhi.n	6df0 <_strtol_l.isra.0+0xcc>
    6dec:	3c57      	subs	r4, #87	; 0x57
    6dee:	e7e0      	b.n	6db2 <_strtol_l.isra.0+0x8e>
    6df0:	1c5a      	adds	r2, r3, #1
    6df2:	d108      	bne.n	6e06 <_strtol_l.isra.0+0xe2>
    6df4:	9a05      	ldr	r2, [sp, #20]
    6df6:	3323      	adds	r3, #35	; 0x23
    6df8:	6013      	str	r3, [r2, #0]
    6dfa:	9b02      	ldr	r3, [sp, #8]
    6dfc:	0030      	movs	r0, r6
    6dfe:	2b00      	cmp	r3, #0
    6e00:	d10b      	bne.n	6e1a <_strtol_l.isra.0+0xf6>
    6e02:	b007      	add	sp, #28
    6e04:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6e06:	9a01      	ldr	r2, [sp, #4]
    6e08:	2a00      	cmp	r2, #0
    6e0a:	d000      	beq.n	6e0e <_strtol_l.isra.0+0xea>
    6e0c:	4240      	negs	r0, r0
    6e0e:	9a02      	ldr	r2, [sp, #8]
    6e10:	2a00      	cmp	r2, #0
    6e12:	d0f6      	beq.n	6e02 <_strtol_l.isra.0+0xde>
    6e14:	9a03      	ldr	r2, [sp, #12]
    6e16:	2b00      	cmp	r3, #0
    6e18:	d000      	beq.n	6e1c <_strtol_l.isra.0+0xf8>
    6e1a:	1e6a      	subs	r2, r5, #1
    6e1c:	9b02      	ldr	r3, [sp, #8]
    6e1e:	601a      	str	r2, [r3, #0]
    6e20:	e7ef      	b.n	6e02 <_strtol_l.isra.0+0xde>
    6e22:	2430      	movs	r4, #48	; 0x30
    6e24:	2f00      	cmp	r7, #0
    6e26:	d1ad      	bne.n	6d84 <_strtol_l.isra.0+0x60>
    6e28:	3708      	adds	r7, #8
    6e2a:	e7ab      	b.n	6d84 <_strtol_l.isra.0+0x60>
    6e2c:	7fffffff 	.word	0x7fffffff

00006e30 <strtol>:
    6e30:	b537      	push	{r0, r1, r2, r4, r5, lr}
    6e32:	0013      	movs	r3, r2
    6e34:	4a06      	ldr	r2, [pc, #24]	; (6e50 <strtol+0x20>)
    6e36:	0005      	movs	r5, r0
    6e38:	6810      	ldr	r0, [r2, #0]
    6e3a:	6a04      	ldr	r4, [r0, #32]
    6e3c:	2c00      	cmp	r4, #0
    6e3e:	d100      	bne.n	6e42 <strtol+0x12>
    6e40:	4c04      	ldr	r4, [pc, #16]	; (6e54 <strtol+0x24>)
    6e42:	000a      	movs	r2, r1
    6e44:	9400      	str	r4, [sp, #0]
    6e46:	0029      	movs	r1, r5
    6e48:	f7ff ff6c 	bl	6d24 <_strtol_l.isra.0>
    6e4c:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
    6e4e:	46c0      	nop			; (mov r8, r8)
    6e50:	20000014 	.word	0x20000014
    6e54:	20000078 	.word	0x20000078

00006e58 <__ascii_wctomb>:
    6e58:	1e0b      	subs	r3, r1, #0
    6e5a:	d004      	beq.n	6e66 <__ascii_wctomb+0xe>
    6e5c:	2aff      	cmp	r2, #255	; 0xff
    6e5e:	d904      	bls.n	6e6a <__ascii_wctomb+0x12>
    6e60:	238a      	movs	r3, #138	; 0x8a
    6e62:	6003      	str	r3, [r0, #0]
    6e64:	3b8b      	subs	r3, #139	; 0x8b
    6e66:	0018      	movs	r0, r3
    6e68:	4770      	bx	lr
    6e6a:	700a      	strb	r2, [r1, #0]
    6e6c:	2301      	movs	r3, #1
    6e6e:	e7fa      	b.n	6e66 <__ascii_wctomb+0xe>

00006e70 <malloc>:
    6e70:	b510      	push	{r4, lr}
    6e72:	4b03      	ldr	r3, [pc, #12]	; (6e80 <malloc+0x10>)
    6e74:	0001      	movs	r1, r0
    6e76:	6818      	ldr	r0, [r3, #0]
    6e78:	f000 f804 	bl	6e84 <_malloc_r>
    6e7c:	bd10      	pop	{r4, pc}
    6e7e:	46c0      	nop			; (mov r8, r8)
    6e80:	20000014 	.word	0x20000014

00006e84 <_malloc_r>:
    6e84:	2303      	movs	r3, #3
    6e86:	b570      	push	{r4, r5, r6, lr}
    6e88:	1ccd      	adds	r5, r1, #3
    6e8a:	439d      	bics	r5, r3
    6e8c:	3508      	adds	r5, #8
    6e8e:	0006      	movs	r6, r0
    6e90:	2d0c      	cmp	r5, #12
    6e92:	d21e      	bcs.n	6ed2 <_malloc_r+0x4e>
    6e94:	250c      	movs	r5, #12
    6e96:	42a9      	cmp	r1, r5
    6e98:	d81d      	bhi.n	6ed6 <_malloc_r+0x52>
    6e9a:	0030      	movs	r0, r6
    6e9c:	f000 f862 	bl	6f64 <__malloc_lock>
    6ea0:	4a25      	ldr	r2, [pc, #148]	; (6f38 <_malloc_r+0xb4>)
    6ea2:	6814      	ldr	r4, [r2, #0]
    6ea4:	0021      	movs	r1, r4
    6ea6:	2900      	cmp	r1, #0
    6ea8:	d119      	bne.n	6ede <_malloc_r+0x5a>
    6eaa:	4c24      	ldr	r4, [pc, #144]	; (6f3c <_malloc_r+0xb8>)
    6eac:	6823      	ldr	r3, [r4, #0]
    6eae:	2b00      	cmp	r3, #0
    6eb0:	d103      	bne.n	6eba <_malloc_r+0x36>
    6eb2:	0030      	movs	r0, r6
    6eb4:	f000 f844 	bl	6f40 <_sbrk_r>
    6eb8:	6020      	str	r0, [r4, #0]
    6eba:	0029      	movs	r1, r5
    6ebc:	0030      	movs	r0, r6
    6ebe:	f000 f83f 	bl	6f40 <_sbrk_r>
    6ec2:	1c43      	adds	r3, r0, #1
    6ec4:	d12c      	bne.n	6f20 <_malloc_r+0x9c>
    6ec6:	230c      	movs	r3, #12
    6ec8:	0030      	movs	r0, r6
    6eca:	6033      	str	r3, [r6, #0]
    6ecc:	f000 f84b 	bl	6f66 <__malloc_unlock>
    6ed0:	e003      	b.n	6eda <_malloc_r+0x56>
    6ed2:	2d00      	cmp	r5, #0
    6ed4:	dadf      	bge.n	6e96 <_malloc_r+0x12>
    6ed6:	230c      	movs	r3, #12
    6ed8:	6033      	str	r3, [r6, #0]
    6eda:	2000      	movs	r0, #0
    6edc:	bd70      	pop	{r4, r5, r6, pc}
    6ede:	680b      	ldr	r3, [r1, #0]
    6ee0:	1b5b      	subs	r3, r3, r5
    6ee2:	d41a      	bmi.n	6f1a <_malloc_r+0x96>
    6ee4:	2b0b      	cmp	r3, #11
    6ee6:	d903      	bls.n	6ef0 <_malloc_r+0x6c>
    6ee8:	600b      	str	r3, [r1, #0]
    6eea:	18cc      	adds	r4, r1, r3
    6eec:	6025      	str	r5, [r4, #0]
    6eee:	e003      	b.n	6ef8 <_malloc_r+0x74>
    6ef0:	428c      	cmp	r4, r1
    6ef2:	d10e      	bne.n	6f12 <_malloc_r+0x8e>
    6ef4:	6863      	ldr	r3, [r4, #4]
    6ef6:	6013      	str	r3, [r2, #0]
    6ef8:	0030      	movs	r0, r6
    6efa:	f000 f834 	bl	6f66 <__malloc_unlock>
    6efe:	0020      	movs	r0, r4
    6f00:	2207      	movs	r2, #7
    6f02:	300b      	adds	r0, #11
    6f04:	1d23      	adds	r3, r4, #4
    6f06:	4390      	bics	r0, r2
    6f08:	1ac3      	subs	r3, r0, r3
    6f0a:	d0e7      	beq.n	6edc <_malloc_r+0x58>
    6f0c:	425a      	negs	r2, r3
    6f0e:	50e2      	str	r2, [r4, r3]
    6f10:	e7e4      	b.n	6edc <_malloc_r+0x58>
    6f12:	684b      	ldr	r3, [r1, #4]
    6f14:	6063      	str	r3, [r4, #4]
    6f16:	000c      	movs	r4, r1
    6f18:	e7ee      	b.n	6ef8 <_malloc_r+0x74>
    6f1a:	000c      	movs	r4, r1
    6f1c:	6849      	ldr	r1, [r1, #4]
    6f1e:	e7c2      	b.n	6ea6 <_malloc_r+0x22>
    6f20:	2303      	movs	r3, #3
    6f22:	1cc4      	adds	r4, r0, #3
    6f24:	439c      	bics	r4, r3
    6f26:	42a0      	cmp	r0, r4
    6f28:	d0e0      	beq.n	6eec <_malloc_r+0x68>
    6f2a:	1a21      	subs	r1, r4, r0
    6f2c:	0030      	movs	r0, r6
    6f2e:	f000 f807 	bl	6f40 <_sbrk_r>
    6f32:	1c43      	adds	r3, r0, #1
    6f34:	d1da      	bne.n	6eec <_malloc_r+0x68>
    6f36:	e7c6      	b.n	6ec6 <_malloc_r+0x42>
    6f38:	200032fc 	.word	0x200032fc
    6f3c:	20003300 	.word	0x20003300

00006f40 <_sbrk_r>:
    6f40:	2300      	movs	r3, #0
    6f42:	b570      	push	{r4, r5, r6, lr}
    6f44:	4c06      	ldr	r4, [pc, #24]	; (6f60 <_sbrk_r+0x20>)
    6f46:	0005      	movs	r5, r0
    6f48:	0008      	movs	r0, r1
    6f4a:	6023      	str	r3, [r4, #0]
    6f4c:	f7ff fd48 	bl	69e0 <_sbrk>
    6f50:	1c43      	adds	r3, r0, #1
    6f52:	d103      	bne.n	6f5c <_sbrk_r+0x1c>
    6f54:	6823      	ldr	r3, [r4, #0]
    6f56:	2b00      	cmp	r3, #0
    6f58:	d000      	beq.n	6f5c <_sbrk_r+0x1c>
    6f5a:	602b      	str	r3, [r5, #0]
    6f5c:	bd70      	pop	{r4, r5, r6, pc}
    6f5e:	46c0      	nop			; (mov r8, r8)
    6f60:	20003390 	.word	0x20003390

00006f64 <__malloc_lock>:
    6f64:	4770      	bx	lr

00006f66 <__malloc_unlock>:
    6f66:	4770      	bx	lr
    6f68:	00000920 	.word	0x00000920
    6f6c:	0a0d0920 	.word	0x0a0d0920
    6f70:	00000000 	.word	0x00000000
    6f74:	006e6163 	.word	0x006e6163
    6f78:	6e616309 	.word	0x6e616309
    6f7c:	00000a0d 	.word	0x00000a0d
    6f80:	69202109 	.word	0x69202109
    6f84:	6974696e 	.word	0x6974696e
    6f88:	7a696c61 	.word	0x7a696c61
    6f8c:	68742065 	.word	0x68742065
    6f90:	41432065 	.word	0x41432065
    6f94:	6f63204e 	.word	0x6f63204e
    6f98:	6f72746e 	.word	0x6f72746e
    6f9c:	72656c6c 	.word	0x72656c6c
    6fa0:	00000a0d 	.word	0x00000a0d
    6fa4:	6e616378 	.word	0x6e616378
    6fa8:	00000000 	.word	0x00000000
    6fac:	61637809 	.word	0x61637809
    6fb0:	000a0d6e 	.word	0x000a0d6e
    6fb4:	73202109 	.word	0x73202109
    6fb8:	20706f74 	.word	0x20706f74
    6fbc:	20656874 	.word	0x20656874
    6fc0:	204e4143 	.word	0x204e4143
    6fc4:	746e6f63 	.word	0x746e6f63
    6fc8:	6c6c6f72 	.word	0x6c6c6f72
    6fcc:	0a0d7265 	.word	0x0a0d7265
    6fd0:	00000000 	.word	0x00000000
    6fd4:	64756162 	.word	0x64756162
    6fd8:	00000000 	.word	0x00000000
    6fdc:	75616209 	.word	0x75616209
    6fe0:	35322064 	.word	0x35322064
    6fe4:	30357c30 	.word	0x30357c30
    6fe8:	30317c30 	.word	0x30317c30
    6fec:	0a0d3030 	.word	0x0a0d3030
    6ff0:	00000000 	.word	0x00000000
    6ff4:	73202109 	.word	0x73202109
    6ff8:	74207465 	.word	0x74207465
    6ffc:	43206568 	.word	0x43206568
    7000:	62204e41 	.word	0x62204e41
    7004:	20647561 	.word	0x20647561
    7008:	65746172 	.word	0x65746172
    700c:	00000a0d 	.word	0x00000a0d
    7010:	676e6970 	.word	0x676e6970
    7014:	00000000 	.word	0x00000000
    7018:	6e697009 	.word	0x6e697009
    701c:	000a0d67 	.word	0x000a0d67
    7020:	73202109 	.word	0x73202109
    7024:	20646e65 	.word	0x20646e65
    7028:	32347830 	.word	0x32347830
    702c:	6e6f2032 	.word	0x6e6f2032
    7030:	4e414320 	.word	0x4e414320
    7034:	746e7520 	.word	0x746e7520
    7038:	52206c69 	.word	0x52206c69
    703c:	000a0d78 	.word	0x000a0d78
    7040:	646e6573 	.word	0x646e6573
    7044:	00000000 	.word	0x00000000
    7048:	6e657309 	.word	0x6e657309
    704c:	000a0d64 	.word	0x000a0d64
    7050:	73202109 	.word	0x73202109
    7054:	20646e65 	.word	0x20646e65
    7058:	20656e6f 	.word	0x20656e6f
    705c:	32347830 	.word	0x32347830
    7060:	61702032 	.word	0x61702032
    7064:	74656b63 	.word	0x74656b63
    7068:	00000a0d 	.word	0x00000a0d
    706c:	706f6f6c 	.word	0x706f6f6c
    7070:	00000000 	.word	0x00000000
    7074:	6f6f6c09 	.word	0x6f6f6c09
    7078:	633c2070 	.word	0x633c2070
    707c:	746e756f 	.word	0x746e756f
    7080:	000a0d3e 	.word	0x000a0d3e
    7084:	73202109 	.word	0x73202109
    7088:	20646e65 	.word	0x20646e65
    708c:	32347830 	.word	0x32347830
    7090:	6e6f2032 	.word	0x6e6f2032
    7094:	4e414320 	.word	0x4e414320
    7098:	6f633c20 	.word	0x6f633c20
    709c:	3e746e75 	.word	0x3e746e75
    70a0:	6d697420 	.word	0x6d697420
    70a4:	0a0d7365 	.word	0x0a0d7365
    70a8:	00000000 	.word	0x00000000
    70ac:	706c6568 	.word	0x706c6568
    70b0:	00000000 	.word	0x00000000
    70b4:	6c656809 	.word	0x6c656809
    70b8:	635b2070 	.word	0x635b2070
    70bc:	0d5d646d 	.word	0x0d5d646d
    70c0:	0000000a 	.word	0x0000000a
    70c4:	73202109 	.word	0x73202109
    70c8:	20776f68 	.word	0x20776f68
    70cc:	62726576 	.word	0x62726576
    70d0:	2065736f 	.word	0x2065736f
    70d4:	706c6568 	.word	0x706c6568
    70d8:	726f6620 	.word	0x726f6620
    70dc:	6d633c20 	.word	0x6d633c20
    70e0:	6f203e64 	.word	0x6f203e64
    70e4:	72622072 	.word	0x72622072
    70e8:	20666569 	.word	0x20666569
    70ec:	706c6568 	.word	0x706c6568
    70f0:	726f6620 	.word	0x726f6620
    70f4:	6c6c6120 	.word	0x6c6c6120
    70f8:	6d6f6320 	.word	0x6d6f6320
    70fc:	646e616d 	.word	0x646e616d
    7100:	000a0d73 	.word	0x000a0d73
    7104:	64616572 	.word	0x64616572
    7108:	00007265 	.word	0x00007265
    710c:	61657209 	.word	0x61657209
    7110:	0d726564 	.word	0x0d726564
    7114:	0000000a 	.word	0x0000000a
    7118:	54202109 	.word	0x54202109
    711c:	206e7275 	.word	0x206e7275
    7120:	43206e6f 	.word	0x43206e6f
    7124:	72204e41 	.word	0x72204e41
    7128:	20646165 	.word	0x20646165
    712c:	6b736174 	.word	0x6b736174
    7130:	00000a0d 	.word	0x00000a0d
    7134:	61657278 	.word	0x61657278
    7138:	00726564 	.word	0x00726564
    713c:	65727809 	.word	0x65727809
    7140:	72656461 	.word	0x72656461
    7144:	00000a0d 	.word	0x00000a0d
    7148:	54202109 	.word	0x54202109
    714c:	206e7275 	.word	0x206e7275
    7150:	2066666f 	.word	0x2066666f
    7154:	204e4143 	.word	0x204e4143
    7158:	64616572 	.word	0x64616572
    715c:	73617420 	.word	0x73617420
    7160:	000a0d6b 	.word	0x000a0d6b
    7164:	0064656c 	.word	0x0064656c
    7168:	64656c09 	.word	0x64656c09
    716c:	6c3c2020 	.word	0x6c3c2020
    7170:	6e206465 	.word	0x6e206465
    7174:	65626d75 	.word	0x65626d75
    7178:	0a0d3e72 	.word	0x0a0d3e72
    717c:	00000000 	.word	0x00000000
    7180:	54202109 	.word	0x54202109
    7184:	206e7275 	.word	0x206e7275
    7188:	4c206e6f 	.word	0x4c206e6f
    718c:	28204445 	.word	0x28204445
    7190:	29444254 	.word	0x29444254
    7194:	00000a0d 	.word	0x00000a0d
    7198:	64656c78 	.word	0x64656c78
    719c:	00000000 	.word	0x00000000
    71a0:	656c7809 	.word	0x656c7809
    71a4:	3c202064 	.word	0x3c202064
    71a8:	2064656c 	.word	0x2064656c
    71ac:	626d756e 	.word	0x626d756e
    71b0:	0d3e7265 	.word	0x0d3e7265
    71b4:	0000000a 	.word	0x0000000a
    71b8:	54202109 	.word	0x54202109
    71bc:	206e7275 	.word	0x206e7275
    71c0:	2066666f 	.word	0x2066666f
    71c4:	2044454c 	.word	0x2044454c
    71c8:	44425428 	.word	0x44425428
    71cc:	000a0d29 	.word	0x000a0d29

000071d0 <cli>:
    71d0:	00006f74 00006f78 00000004 00006f80     to..xo.......o..
    71e0:	00006fa4 00006fac 00000008 00006fb4     .o...o.......o..
    71f0:	00006fd4 00006fdc 00000005 00006ff4     .o...o.......o..
    7200:	00007010 00007018 00000006 00007020     .p...p...... p..
    7210:	00007040 00007048 0000000b 00007050     @p..Hp......Pp..
    7220:	0000706c 00007074 00000007 00007084     lp..tp.......p..
    7230:	000070ac 000070b4 00000001 000070c4     .p...p.......p..
    7240:	00007104 0000710c 00000009 00007118     .q...q.......q..
    7250:	00007134 0000713c 0000000a 00007148     4q..<q......Hq..
    7260:	00007164 00007168 00000002 00007180     dq..hq.......q..
    7270:	00007198 000071a0 00000003 000071b8     .q...q.......q..
    7280:	0000108e 0000106c 00001032 00001032     ....l...2...2...
    7290:	0000108e 00001032 0000108e 00001032     ....2.......2...
    72a0:	0a0d0a0d 65657246 534f5452 6d6f6320     ....FreeRTOS com
    72b0:	646e616d 72657320 2e726576 79540a0d     mand server...Ty
    72c0:	48206570 20706c65 76206f74 20776569     pe Help to view 
    72d0:	696c2061 6f207473 65722066 74736967     a list of regist
    72e0:	64657265 6d6f6320 646e616d 0a0d2e73     ered commands...
    72f0:	003e0a0d 003e0a0d 00000a0d 00494c43     ..>...>.....CLI.
    7300:	42000400 42000800 42000c00 42001000     ...B...B...B...B
    7310:	42001400 42001800 0c0b0a09 00000e0d     ...B...B........
    7320:	00002c56 00002ca0 00002ca0 00002c7c     V,...,...,..|,..
    7330:	00002c76 00002c82 00002c5c 00002c88     v,...,..\,...,..
    7340:	454c4449 00000000 09632509 25097525     IDLE.....%c.%u.%
    7350:	75250975 00000a0d 20726d54 00637653     u.%u....Tmr Svc.
    7360:	51726d54 00000000 000053c8 000053c8     TmrQ.....S...S..
    7370:	000053c8 00005456 00005420 0000544a     .S..VT.. T..JT..
    7380:	000053c8 000053c8 00005456 00005420     .S...S..VT.. T..
    7390:	204e4143 72617473 21646574 00000a0d     CAN started!....
    73a0:	65570a0d 6d6f636c 6f742065 65687420     ..Welcome to the
    73b0:	4e414320 73617420 0a0d216b 00000000      CAN task!......
    73c0:	66207874 206f6669 6e657665 6d202c74     tx fifo event, m
    73d0:	64696773 00203d20 66207874 206f6669     sgid = .tx fifo 
    73e0:	6e657665 72202c74 6c757365 203d2074     event, result = 
    73f0:	00000000 6d207872 69206773 203d2064     ....rx msg id = 
    7400:	00000000 6d207872 6d206773 20617465     ....rx msg meta 
    7410:	0000203d 6d207872 64206773 31617461     = ..rx msg data1
    7420:	00203d20 6d207872 64206773 32617461      = .rx msg data2
    7430:	00203d20 656d6974 2074756f 6520726f      = .timeout or e
    7440:	726f7272 206e6920 46205852 0d4f4649     rror in RX FIFO.
    7450:	0000000a 6620794d 726f7661 20657469     ....My favorite 
    7460:	6b636170 0d217465 0000000a 20215852     packet!.....RX! 
    7470:	3d204449 00000020 00203a20 00000020     ID = ... : . ...
    7480:	74696157 726f6620 46494620 0a0d214f     Wait for FIFO!..
    7490:	00000000 6b636150 20737465 746e6573     ....Packets sent
    74a0:	00203d20 72724509 3d20726f 00000020      = ..Error = ...
    74b0:	20585409 4f464946 61747320 20737574     .TX FIFO status 
    74c0:	0000203d 6e6f4309 6c6f7274 2072656c     = ...Controller 
    74d0:	74617473 3d207375 00000020 72724509     status = ....Err
    74e0:	6320726f 746e756f 3d207265 00000020     or counter = ...
    74f0:	746e4909 75727265 66207470 7367616c     .Interrupt flags
    7500:	00203d20 6f727245 49203a72 6c61766e      = .Error: Inval
    7510:	62206469 20647561 65746172 00000a0d     id baud rate....
    7520:	5f4e4143 00007852 00005f46 00005f02     CAN_Rx..F_..._..
    7530:	00005f54 00005f54 00005f10 00005f38     T_..T_..._..8_..
    7540:	00005f54 00005f2a 00005f46 00005f16     T_..*_..F_..._..
    7550:	00005f1c 00005f22 4f500043 00584953     ._.."_..C.POSIX.
    7560:	2000002e                                         ..

00007562 <_ctype_>:
    7562:	20202000 20202020 28282020 20282828     .         ((((( 
    7572:	20202020 20202020 20202020 20202020                     
    7582:	10108820 10101010 10101010 10101010      ...............
    7592:	04040410 04040404 10040404 10101010     ................
    75a2:	41411010 41414141 01010101 01010101     ..AAAAAA........
    75b2:	01010101 01010101 01010101 10101010     ................
    75c2:	42421010 42424242 02020202 02020202     ..BBBBBB........
    75d2:	02020202 02020202 02020202 10101010     ................
    75e2:	00000020 00000000 00000000 00000000      ...............
	...

00007664 <_init>:
    7664:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    7666:	46c0      	nop			; (mov r8, r8)
    7668:	bcf8      	pop	{r3, r4, r5, r6, r7}
    766a:	bc08      	pop	{r3}
    766c:	469e      	mov	lr, r3
    766e:	4770      	bx	lr

00007670 <__init_array_start>:
    7670:	000000e5 	.word	0x000000e5

00007674 <_fini>:
    7674:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    7676:	46c0      	nop			; (mov r8, r8)
    7678:	bcf8      	pop	{r3, r4, r5, r6, r7}
    767a:	bc08      	pop	{r3}
    767c:	469e      	mov	lr, r3
    767e:	4770      	bx	lr

00007680 <__fini_array_start>:
    7680:	000000bd 	.word	0x000000bd
